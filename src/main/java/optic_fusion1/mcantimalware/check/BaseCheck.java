package optic_fusion1.mcantimalware.check;

import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.utils.StringUtils;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodNode;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import optic_fusion1.mcantimalware.translations.TranslationFile;
import org.objectweb.asm.tree.LineNumberNode;

public abstract class BaseCheck {

    private String name = "";
    public Main main;
    public CustomLogger logger;
    private String classNodePath = "";
    private String sourceFilePath = "";
    private String logName = "";
    private String checkType = "";
    private int line = -1;
    public List<String> blacklistedMethodNames = new ArrayList<>();
    public List<String> blacklistedAuthors = new ArrayList<>();
    public List<String> blacklistedChecksums = new ArrayList<>();
    public List<String> blacklistedClassPaths = new ArrayList<>();
    public List<String> blacklistedStrings = new ArrayList<>();
    public List<String> blacklistedClassNames = new ArrayList<>();
    public List<String> blacklistedPluginNames = new ArrayList<>();
    public TranslationFile currentSessionTranslations;
    private int chanceOfBeingMalware = 0;
    private int threshold = 0;
    public boolean shouldDisableMaliciousPlugins;

    public BaseCheck(Main main, String name) {
        this.name = name;
        this.logger = main.getLogger();
        this.main = main;
        currentSessionTranslations = main.getTranslations();
        shouldDisableMaliciousPlugins = main.shouldDisableMaliciousPlugins();
    }

    public abstract boolean process(String fileName, ZipFile zipFile);

    public boolean checksumIsBlacklisted(String fileChecksum) {
        if (blacklistedChecksums.isEmpty()) {
            return false;
        }
        return blacklistedChecksums.stream().anyMatch((blacklistedChecksum) -> (fileChecksum.equals(blacklistedChecksum)));
    }

    public void setLogName(String logName) {
        this.logName = logName;
    }

    public String getLogName() {
        if (logName.isEmpty()) {
            return name;
        }
        return logName;
    }

    public void setBlacklistedMethodNames(List<String> blacklistedMethodNames) {
        this.blacklistedMethodNames = blacklistedMethodNames;
    }

    public void setBlacklistedStrings(List<String> blacklistedStrings) {
        this.blacklistedStrings = blacklistedStrings;
    }

    public void setBlacklistedClassPaths(List<String> blacklistedClassPaths) {
        this.blacklistedClassPaths = blacklistedClassPaths;
    }

    public void setBlacklistedChecksums(List<String> blacklistedChecksums) {
        this.blacklistedChecksums = blacklistedChecksums;
    }

    public void setBlacklistedAuthors(List<String> blacklistedAuthors) {
        this.blacklistedAuthors = blacklistedAuthors;
    }

    public void setCheckType(String checkType) {
        this.checkType = checkType;
    }

    public String getCheckType() {
        return checkType;
    }

    public String getName() {
        return name;
    }

    public boolean classNodeContainsBlacklistedWord(ClassNode classNode, List<String> blacklistedStrings) {
        boolean containsBlacklistedWord = false;
        List<MethodNode> nodes = classNode.methods;
        for (MethodNode node : nodes) {
            for (AbstractInsnNode insnNode : node.instructions.toArray()) {
                if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
                    String string = ((LdcInsnNode) insnNode).cst.toString();
                    for (String blacklistedString : blacklistedStrings) {
                        if (string.equals(blacklistedString)) {
                            if (main.shouldLogDebugMessages() && !string.isEmpty() && !blacklistedString.isEmpty()) {
                                logger.debug("String: " + string + " BlacklistedString: " + blacklistedString);
                            }
                            containsBlacklistedWord = true;
                            addOneToChanceOfBeingMalware();
                        }
                    }
                } else if (insnNode instanceof LineNumberNode) {
                    setLine(((LineNumberNode) insnNode).line);
                }
            }
        }
        return containsBlacklistedWord;
    }

    public boolean isForgeMod(ZipFile zipFile) {
        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry zipEntry = entries.nextElement();
            if (isMCModInfoFile(zipEntry.getName())) {
                return true;
            }
        }
        return false;
    }

    public boolean isPlugin(ZipFile zipFile) {
        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry zipEntry = entries.nextElement();
            String currentName = zipEntry.getName();
            if(isBungeeYmlFile(currentName) || isPluginYmlFile(currentName)){
                return true;
            }
        }
        return false;
    }

    public boolean isMCModInfoFile(String fileName) {
        return fileName.equals("mcmod.info");
    }

    public boolean isBungeeYmlFile(String fileName) {
        return fileName.equals("bungee.yml");
    }

    public boolean isPluginYmlFile(String fileName) {
        return fileName.equals("plugin.yml");
    }

    public boolean isTextFile(String fileName) {
        return fileName.endsWith(".yml") || fileName.endsWith(".txt") || isMCModInfoFile((fileName));
    }

    public void setClassNodePath(String string) {
        this.classNodePath = string;
    }

    public void setSourceFilePath(String sourceFilePath) {
        if (!StringUtils.isBlank(sourceFilePath)) {
            this.sourceFilePath = sourceFilePath;
        }
    }

    public void setLine(int line) {
        this.line = line;
    }

    public String getClassNodePath() {
        return classNodePath;
    }

    public String getSourceFilePath() {
        return sourceFilePath;
    }

    public int getLine() {
        return line;
    }

    public boolean validClassPath(String classPath) {
        return classPath.endsWith(".class") && !classPath.contains("__MACOSX");
    }

    public void setBlacklistedClassNames(List<String> blacklistedClassNames) {
        this.blacklistedClassNames = blacklistedClassNames;
    }

    public void addOneToChanceOfBeingMalware() {
        chanceOfBeingMalware++;
    }

    public void addToChanceOfBeingMalware(int amount) {
        chanceOfBeingMalware += amount;
    }

    public int getChanceOfBeingMalware() {
        return chanceOfBeingMalware;
    }

    public int getThreshold() {
        return threshold;
    }

    public void setThreshold(int threshold) {
        this.threshold = threshold;
    }

    public void setBlacklistedPluginNames(List<String> blacklistedPluginNames) {
        this.blacklistedPluginNames = blacklistedPluginNames;
    }

    public List<String> getBlacklistedPluginNames() {
        return blacklistedPluginNames;
    }

}
