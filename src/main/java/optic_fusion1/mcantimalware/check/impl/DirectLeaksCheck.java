package optic_fusion1.mcantimalware.check.impl;

import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.deobfuscator.StringDeobfuscator;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.*;

import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

public class DirectLeaksCheck extends BaseCheck {

    private Main main;

    public DirectLeaksCheck(Main main, String name) {
        super(main, name);
        this.main = main;
    }

    @Override
    public boolean process(String fileName, ZipFile zipFile) {
        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        InputStream inputStream = null;
        while (entries.hasMoreElements()) {
            ZipEntry current = entries.nextElement();
            try {
                inputStream = zipFile.getInputStream(current);
                if (validClassPath(current.getName())) {
                    ClassReader reader = new ClassReader(inputStream);
                    ClassNode classNode = new ClassNode();
                    reader.accept(classNode, 0);
                    List<MethodNode> nodes = classNode.methods;
                    for (MethodNode methodNode : nodes) {
                        for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
                            if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
                                String string = ((LdcInsnNode) insnNode).cst.toString();
                                for (String word : blacklistedStrings) {
                                    boolean xorv1 = containsBlacklistedWord(StringDeobfuscator.XORV1(string));
                                    boolean xorv2 = containsBlacklistedWord(StringDeobfuscator.XORV2(string));
                                    boolean xorv3 = containsBlacklistedWord(StringDeobfuscator.XORV3(string));
                                    boolean xorv4 = containsBlacklistedWord(StringDeobfuscator.decryptionArray(string));
                                    boolean sig = checkForDLSignature(classNode);
                                    boolean bootstrap1 = bootstrap1(classNode);
                                    boolean bootstrap2 = bootstrap2(classNode);
                                    boolean host = false;
                                    try {
                                        host = doesDLHostCheckExist(classNode);
                                    } catch (Throwable ex) {
                                        if (main.shouldLogDebugMessages()) {
                                            logger.exception(ex);
                                        }
                                    }

                                    if (xorv1 || xorv2 || xorv3 || xorv4 || host || sig || bootstrap1 || bootstrap2) {
                                        setClassNodePath(classNode.name);
                                        setSourceFilePath(classNode.sourceFile);
                                        inputStream.close();
                                        return true;
                                    }
                                }
                            } else if (insnNode instanceof LineNumberNode) {
                                setLine(((LineNumberNode) insnNode).line);
                            }
                        }
                    }
                }
            } catch (IOException ex) {
                logger.exception(ex);
            }
        }
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException ex) {
                logger.exception(ex);
            }
        }
        return false;
    }

    public boolean containsBlacklistedWord(String string) {
        String[] blacklistedWords = new String[]{"#directleaks", "Please contact DirectLeaks. 0x2",
            "http://api.directleaks.net/api/directleaks", "[DirectLeaks] Error Code: 0x1", "Anti-Releak",
            "DirectLeaks", "vmi209890.contaboserver.net", "167.86.75.51", "#DirectLeaks Anti-Releak",
            "DirectLeaks-API", "de.xbrowniecodez.dlapi.Main", "de.xbrowniecodez.dlapi.HostsCheck"};
        for (String blacklistedWord : blacklistedWords) {
            if (string.contains(blacklistedWord)) {
                return true;
            }
        }
        return false;
    }

    public static boolean doesDLHostCheckExist(ClassNode classNode) throws Throwable {
        Iterator<MethodNode> iterator = classNode.methods.iterator();
        while (iterator.hasNext()) {
            MethodNode attributeIterator = iterator.next();
            if (attributeIterator.name.equalsIgnoreCase("onEnable")) {
                InsnList attribute = attributeIterator.instructions;
                AbstractInsnNode insnNode = attribute.get(0);

                if (insnNode.getType() == 5 && insnNode.getOpcode() == 184
                        && ((MethodInsnNode) insnNode).desc.equals("()V")
                        && !((MethodInsnNode) insnNode).name.equalsIgnoreCase("loadConfig0")) {
                    return true;
                }
            } else if (attributeIterator.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")
                    && attributeIterator.access == 4170) {
                return true;
            }
        }
        return false;
    }

    public static boolean checkForDLSignature(ClassNode classNode) {
        if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
                || classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
            if (classNode.signature == null) {
                return false;
            }
            return classNode.signature.contains("directleaks");
        }
        return false;
    }

    public static boolean bootstrap1(ClassNode classNode) {
        Iterator<MethodNode> iterator = classNode.methods.iterator();
        while (iterator.hasNext()) {
            MethodNode methodNode = iterator.next();
            if (methodNode.desc.equalsIgnoreCase(
                    "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;")) {
                return true;
            }
        }
        return false;
    }

    public static boolean bootstrap2(ClassNode classNode) {
        if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
                || classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
            for (Iterator<FieldNode> it = classNode.fields.iterator(); it.hasNext();) {
                FieldNode fieldNode = it.next();
                if (fieldNode.access == 9 && fieldNode.desc.equalsIgnoreCase("I") && fieldNode.name.length() == 36) {
                    return true;
                } else if (fieldNode.access == 9 && fieldNode.desc.equalsIgnoreCase("Ljava/lang/String;")
                        && fieldNode.name.length() == 36) {
                    return true;
                }
            }
        }
        return false;
    }

}
