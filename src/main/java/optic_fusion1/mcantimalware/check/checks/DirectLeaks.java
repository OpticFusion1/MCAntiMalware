package optic_fusion1.mcantimalware.check.checks;

import com.javadeobfuscator.javavm.MethodExecution;
import com.javadeobfuscator.javavm.VirtualMachine;
import com.javadeobfuscator.javavm.mirrors.JavaClass;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Modifier;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.Check;
import optic_fusion1.mcantimalware.check.CheckType;
import optic_fusion1.mcantimalware.utils.JavaVMHelper;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public class DirectLeaks extends Check {
    private Map<String, ClassNode> classNodes;
    private Map<ClassNode, ClassReader> readers;

    public DirectLeaks(Main main) {
        super("DirectLeaks", main, CheckType.PUP);
    }

    @Override
    public boolean process(String fileName, ZipFile zipFile) {
        classNodes = new HashMap<>();
        readers = new HashMap<>();

        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        InputStream inputStream = null;

        while (entries.hasMoreElements()) {
            try {
                ZipEntry current = entries.nextElement();
                inputStream = zipFile.getInputStream(current);
                if (current.getName().endsWith(".class"))
                    try {
                        ClassReader reader = new ClassReader(inputStream);
                        ClassNode node = new ClassNode();
                        reader.accept(node, 0);

                        classNodes.put(node.name, node);
                        readers.put(node, reader);
                    } catch (Exception e) {
                        continue;
                    }

                inputStream.close();
            } catch (IOException ex) {
                Logger.getLogger(Minator.class.getName()).log(Level.SEVERE, null, ex);
            }
        }

        if (inputStream != null)
            try {
                inputStream.close();
            } catch (IOException ex) {
                Logger.getLogger(SkySneak.class.getName()).log(Level.SEVERE, null, ex);
            }

        deobfuscateNodes(new File(fileName));

        Optional<ClassNode> result = classNodes.values().stream().filter(classNode -> detect(classNode)).findFirst();
        if (result.isPresent())
            return true;

        return false;
    }

    private void deobfuscateNodes(File file) {
        VirtualMachine vm = JavaVMHelper.newVirtualMachine(file, classNodes.values(), readers);
        AtomicInteger count = new AtomicInteger();

        classNodes.values().forEach(classNode -> JavaClass.forName(vm, classNode.name)
                .setInitializationState(JavaClass.InitializationState.INITIALIZED, null));

        classNodes.values().forEach(classNode -> classNode.methods.forEach(methodNode -> {
            Stream.of(methodNode.instructions.toArray()).forEach(insn -> {
                if (insn instanceof MethodInsnNode && insn.getOpcode() == Opcodes.INVOKESTATIC
                        && insn.getPrevious() instanceof LdcInsnNode
                        && ((LdcInsnNode) insn.getPrevious()).cst instanceof String) {
                    MethodInsnNode invoke = (MethodInsnNode) insn;

                    if (classNode.name.equals(invoke.name)
                            && "(Ljava/lang/String;)Ljava/lang/String;".equals(invoke.desc)) {
                        MethodNode untouched = classNode.methods.stream().filter(mn -> mn.name.equals(invoke.name)
                                && mn.desc.equals(invoke.desc) && isDecryptor(mn)).findFirst().orElse(null);

                        if (untouched != null) {
                            MethodNode decryptorMethod = new MethodNode(Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC, "decrypt" + count.get(), "()Ljava/lang/String;", null, null);

                            decryptorMethod.instructions.add(insn.getPrevious());
                            decryptorMethod.instructions.add(invoke.clone(null));
                            decryptorMethod.instructions.add(new InsnNode(Opcodes.ARETURN));

                            MethodExecution execution;

                            ClassNode decryptorNode = new ClassNode();
                            decryptorNode.visit(49, Opcodes.ACC_PUBLIC, "decryptor" + count.get(), null, "java/lang/Object", null);
                            decryptorNode.methods.add(decryptorMethod);
                            try {
                                execution = vm.execute(decryptorNode, decryptorMethod);
                            } catch (Throwable e) {
                                e.printStackTrace();
                                System.out.println("Something went wrong");
                                return;
                            }

                            ((LdcInsnNode) insn.getPrevious()).cst = vm.convertJavaObjectToString(execution.getReturnValue());

                            count.incrementAndGet();
                        }
                    }
                }
            });
        }));

        vm.shutdown();
    }

    private boolean isDecryptor(MethodNode methodNode) {
        if (!Modifier.isPrivate(methodNode.access)) // Don't need to check for static because invokestatic
            return false;

        int anewarray = 0;
        int mod = 0;

        for (AbstractInsnNode insn : methodNode.instructions.toArray()) {
            if (insn instanceof IntInsnNode && ((IntInsnNode) insn).operand == Opcodes.T_CHAR)
                anewarray++;
            else if (insn.getOpcode() == Opcodes.IREM)
                mod++;
        }

        return (anewarray >= 2 && mod >= 1);
    }

    @Override
    public boolean detect(InputStream inputStream) {
        return false;
    }

    @Override
    public boolean detect(ClassNode classNode) {
        if (classNode.name.contains("de/xbrowniecodez/dlapi"))
            return true;

        List<MethodNode> nodes = classNode.methods;
        for (MethodNode node : nodes) {
            for (AbstractInsnNode insnNode : node.instructions.toArray()) {
                if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
                    String string = ((LdcInsnNode) insnNode).cst.toString();

                    if (containsBlacklistedWord(string))
                        return true;
                }
            }
        }
        return false;
    }

    private boolean containsBlacklistedWord(String string) {
        String[] blacklistedWords = new String[]{
                "#directleaks", "Please contact DirectLeaks. 0x2", "http://api.directleaks.net/api/directleaks",
                "[DirectLeaks] Error Code: 0x1", "Anti-Releak", "DirectLeaks", "vmi209890.contaboserver.net",
                "167.86.75.51", "#DirectLeaks Anti-Releak", "DirectLeaks-API", "de.xbrowniecodez.dlapi.Main",
                "de.xbrowniecodez.dlapi.HostsCheck"};
        for (String blacklistedWord : blacklistedWords)
            if (string.contains(blacklistedWord))
                return true;

        return false;
    }
}
