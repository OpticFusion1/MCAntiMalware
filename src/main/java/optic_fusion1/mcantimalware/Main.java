package optic_fusion1.mcantimalware;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Arrays;
import static java.util.Arrays.asList;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.check.CheckRegistery;
import optic_fusion1.mcantimalware.configuration.file.FileConfiguration;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.realtimescanning.RealTimeScanner;
import optic_fusion1.mcantimalware.runtimeprotect.AntiMalwareSecurityManager;
import optic_fusion1.mcantimalware.translations.TranslationFile;
import optic_fusion1.mcantimalware.translations.Translations;
import optic_fusion1.mcantimalware.utils.UpdateChecker;
import optic_fusion1.mcantimalware.utils.taskchain.AntiMalwareChainFactory;
import org.apache.commons.io.IOUtils;

public class Main implements Runnable {

    private String[] args;
    private CustomLogger logger = new CustomLogger();
    private boolean shouldLogDebugMessages;
    private boolean scanSingleFile;
    public boolean notifyOnWindowsWhenMalicious;
    private OptionSet options;
    private FileConfiguration checksumDatabase;
    private FileConfiguration checkDatabase;
    private CheckManager checkManager;
    private RealTimeScanner realTimeScanner;
    private CheckRegistery checkRegistery;
    private String databaseURL = "https://raw.githubusercontent.com/OpticFusion1/MCAntiMalwareDatabase/master/database.yml";
    private String checksumsURL = "https://raw.githubusercontent.com/OpticFusion1/MCAntiMalwareDatabase/master/checksums.yml";
    private TranslationFile currentSessionTranslations;
    private boolean running = false;
    private AntiMalwareChainFactory chainFactory;

    public static void main(String[] args) {
        Main main = new Main();
        main.args = args;
        main.run();
        main.running = true;
    }

    private void setupRuntimeProtection() {
        System.out.println("Setting up runtime protection");
        SecurityManager mgr = new AntiMalwareSecurityManager();
        System.setSecurityManager(mgr);
    }

    private void startSpigotServer(File serverJar, String[] args) {
        if (!serverJar.exists()) {
            logger.info(serverJar + " isn't a valid jar");
            return;
        }
        try {
            URLClassLoader serverJarClassLoader = new URLClassLoader(new URL[]{serverJar.toURI().toURL()},
                    this.getClass().getClassLoader());
            String[] finalArgs = args.length > 1 ? Arrays.copyOfRange(args, 1, args.length - 1) : args;
//            String[] finalArgs = Arrays.copyOfRange(args, 1, args.length - 1);
            String[] parameters = new String[]{};
            Class craftBukkitMainClass = Class.forName("org.bukkit.craftbukkit.Main", true, serverJarClassLoader);
            Object object = craftBukkitMainClass.newInstance();
            Object[] param = {parameters};
            Method mainMethod = craftBukkitMainClass.getDeclaredMethod("main", parameters.getClass());
            Object result = mainMethod.invoke(object, param);
        } catch (MalformedURLException | ClassNotFoundException
                | InstantiationException | IllegalAccessException
                | IllegalArgumentException | InvocationTargetException
                | NoSuchMethodException | SecurityException ex) {
            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void init() {
        chainFactory = new AntiMalwareChainFactory();
        AntiMalware.setMain(this);
        UpdateChecker updateChecker = new UpdateChecker();
        int resourceId = updateChecker.getResourceId();
        updateChecker.request(chainFactory).exceptionally(e -> {
            logger.exception(e);
            return null;
        }).thenAccept(fetchResult -> {
            if (fetchResult == UpdateChecker.FetchResult.UPDATE_NEEDED) {
                // using system.err because this shouldn't be in the log files of the program
                System.err.println("************************");
                System.err.println("This build of AntiMalware is outdated!");
                System.err.println("Keep in mind you'll get NO SUPPORT over it.");
                System.err.println("You can get latest build here: https://www.spigotmc.org/resources/" + resourceId + "/");
                System.err.println("The checks will start in 20 seconds.");
                System.err.println("************************");
                try {
                    Thread.sleep(TimeUnit.SECONDS.toMillis(20));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
            if (fetchResult == UpdateChecker.FetchResult.RUNNING_DEV_BUILD) {
                System.out.println("You are running a development build of AntiMalware");
                System.out.println("Any issues you're facing should be reported here: https://github.com/OpticFusion1/MCAntiMalware/issues");
                System.out.println("The checks will start in 5 seconds.");
                try {
                    Thread.sleep(TimeUnit.SECONDS.toMillis(5));
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        });
        setupRuntimeProtection();
        handleCommandLineArguments();
        downloadCheckDatabase(false);
        downloadChecksumDatabase(false);
        checkManager = new CheckManager();
        checkRegistery = new CheckRegistery(this);
        checkRegistery.registerChecks();
        realTimeScanner = new RealTimeScanner(this);
        if (scanSingleFile) {
            try {
                realTimeScanner.getScanner().scanFile(new File((String) options.valueOf("scanfile")));
            } catch (IOException ex) {
                if (shouldLogDebugMessages) {
                    logger.exception(ex);
                }
            }
            System.exit(0);
        }
        setupAutoUpdater();
        realTimeScanner.setupDirectoryWatcher();
    }

    public TranslationFile getTranslations() {
        return currentSessionTranslations;
    }

    public AntiMalwareChainFactory getChainFactory() {
        return chainFactory;
    }

    @Override
    public void run() {
        init();
    }

    private void handleCommandLineArguments() {
        OptionParser parser = new OptionParser() {
            {
                acceptsAll(asList("zipMalPlugins"), "Whether to put every malicious plugin in a .zip file or not")
                        .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
                acceptsAll(asList("debug"), "Whether or not to log debug messages").withRequiredArg()
                        .ofType(Boolean.class).defaultsTo(false);
                acceptsAll(asList("scandirectory"), "Which folder to scan").withRequiredArg()
                        .ofType(String.class).defaultsTo("plugins");
                acceptsAll(asList("scanfile"), "Scan a single file").withRequiredArg()
                        .ofType(String.class);
                acceptsAll(asList("printOnlyIfInfected"), "Only prints messages to the console if these are warnings about infected plugins.")
                        .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
                acceptsAll(asList("help"), "Show the help");
                acceptsAll(asList("language"), "Changes the language of the program").withRequiredArg()
                        .ofType(String.class).defaultsTo("en");
                acceptsAll(asList("windowsNotification"),
                        "If this is true, the program will make windows notify you if "
                        + "there was a malicious plugin found (if you run windows)"
                ).withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            }
        };
        try {
            options = parser.parse(args);
        } catch (joptsimple.OptionException ex) {
            logger.exception(ex);
        }
        if (options != null) {
            if (options.has("help")) {
                try {
                    parser.printHelpOn(System.out);
                } catch (IOException ex) {
                    logger.exception(ex);
                }
                System.exit(0);
            }
            if (options.has("debug")) {
                shouldLogDebugMessages = (Boolean) options.valueOf("debug");
            }
            if (options.has("scanfile")) {
                scanSingleFile = true;
            }
            Translations translations = new Translations();
            if (options.has("language")) {
                String specifiedLanguage = (String) options.valueOf("language");
                if (!translations.isSupported(specifiedLanguage)) {
                    System.err.println("Specified language isn't supported.");
                    System.exit(0);
                }
                currentSessionTranslations = translations.getTranslationFile(specifiedLanguage);
            } else {
                currentSessionTranslations = translations.getTranslationFile("en");
            }
            if (options.has("windowsNotification")) {
                notifyOnWindowsWhenMalicious = (boolean) options.valueOf("windowsNotification");
            } else {
                notifyOnWindowsWhenMalicious = false;
            }
        }
    }

    public CustomLogger getLogger() {
        return logger;
    }

    public boolean shouldLogDebugMessages() {
        return shouldLogDebugMessages;
    }

    private void setupAutoUpdater() {
        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
        executor.scheduleWithFixedDelay(() -> {
            downloadCheckDatabase(true);
            downloadChecksumDatabase(true);
        }, 1, 4, TimeUnit.HOURS);
    }

    private void downloadCheckDatabase(boolean updateDatabase) {
        try {
            if (shouldLogDebugMessages()) {
                logger.debug("DATABASE");
                logger.debug(IOUtils.toString(new URL(databaseURL), "UTF-8"));
            }
            logger.info(currentSessionTranslations.getMessage(
                    "downl_check_database", (updateDatabase ? "(AUTO-UPDATE)" : "")));
            checkDatabase = YamlConfiguration.loadConfiguration(IOUtils.toInputStream(IOUtils.toString(new URL(databaseURL), "UTF-8"), "UTF-8"));
            logger.info(currentSessionTranslations.getMessage(
                    "finish_download_check_database", (updateDatabase ? "(AUTO-UPDATE)" : "")));
            if (running) {
                return;
            }
            if (updateDatabase) {
                logger.info(currentSessionTranslations.getMessage("reloading_local_check_database"));
                checkRegistery.reloadCheckDatabase();
                checkRegistery.registerChecks();
                logger.info(currentSessionTranslations.getMessage("finish_reload_local_check_database"));
                logger.info(currentSessionTranslations.getMessage("rescan_updated"));
                realTimeScanner.getScanner().scanFiles();
                logger.info(currentSessionTranslations.getMessage("finish_rescan"));
            }
        } catch (IOException ex) {
            if (shouldLogDebugMessages()) {
                logger.exception(ex);
            }
        }
    }

    private void downloadChecksumDatabase(boolean update) {
        try {
            if (shouldLogDebugMessages()) {
                logger.debug("DATABASE");
                logger.debug(IOUtils.toString(new URL(checksumsURL), "UTF-8"));
            }
            logger.info(currentSessionTranslations.getMessage(
                    "downl_checksum_database", (update ? "(AUTO-UPDATE)" : "")));
            checksumDatabase = YamlConfiguration.loadConfiguration(IOUtils.toInputStream(IOUtils.toString(new URL(checksumsURL), "UTF-8"), "UTF-8"));
            logger.info(currentSessionTranslations.getMessage(
                    "finish_download_checksum_database", (update ? "(AUTO-UPDATE)" : "")));
            if (running) {
                return;
            }
            if (update) {
                logger.info(currentSessionTranslations.getMessage("reloading_checksum_database"));
                realTimeScanner.getScanner().reloadChecksumDatabase();
                logger.info(currentSessionTranslations.getMessage("reloaded_checksum_database"));
                logger.info(currentSessionTranslations.getMessage("rescan_updated"));
                realTimeScanner.getScanner().scanFiles();
                logger.info(currentSessionTranslations.getMessage("finish_rescan"));
            }
        } catch (IOException ex) {
            if (shouldLogDebugMessages()) {
                logger.exception(ex);
            }
        }
    }

    public CheckManager getCheckManager() {
        return checkManager;
    }

    public RealTimeScanner getRealTimeScanner() {
        return realTimeScanner;
    }

    public FileConfiguration getChecksumDatabase() {
        if (checksumDatabase == null) {
            downloadChecksumDatabase(true);
        }
        return checksumDatabase;
    }

    public FileConfiguration getCheckDatabase() {
        if (checkDatabase == null) {
            downloadCheckDatabase(true);
        }
        return checkDatabase;
    }

    public OptionSet getOptions() {
        return options;
    }

    public boolean scanSingleFile() {
        return scanSingleFile;
    }

}
