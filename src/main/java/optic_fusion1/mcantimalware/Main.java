package optic_fusion1.mcantimalware;

import jline.console.ConsoleReader;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.check.CheckRegistery;
import optic_fusion1.mcantimalware.configuration.file.FileConfiguration;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.gui.GuiLauncher;
import optic_fusion1.mcantimalware.logging.ConsoleLogManager;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.logging.LoggerOutputStream;
import optic_fusion1.mcantimalware.utils.JavaUtil;
import optic_fusion1.mcantimalware.utils.ZipUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;

import java.awt.*;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import jline.console.ConsoleReader;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.check.CheckRegistery;
import optic_fusion1.mcantimalware.configuration.file.FileConfiguration;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.utils.ZipUtils;
import org.apache.commons.io.IOUtils;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.LoggerContext;
import org.apache.logging.log4j.core.config.Configuration;
import org.apache.logging.log4j.core.config.LoggerConfig;

import static java.util.Arrays.asList;

public class Main implements Runnable {
    private File scriptsFile = new File("scripts");
    private File malPluginsFolder = new File("malplugins");
    private File scanDirectory = new File("plugins");
    private CheckManager checkManager;
    private Path path = Paths.get("");
    private DirectoryWatcherService watcher;

    private boolean zipMaliciousPlugins, showDebugMessages, maliciousPluginsFound, falsePositivesGalore, printOnlyIfInfected;
    private List<File> maliciousPlugins = new ArrayList<>();
    private String[] args;
    private static CustomLogger logger = CustomLogger.getLogger(Main.class);
    private ConsoleReader reader;
    private FileConfiguration checksumDatabase;
    private boolean scanSingleFile;
    private OptionSet options;

    private void parseArgs(){
        OptionParser parser = new OptionParser() {
            {
                acceptsAll(asList("zipMalPlugins"), "Whether to put every malicious plugin in a .zip file or not")
                        .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
                acceptsAll(asList("debug"), "Whether or not to log debug messages").withRequiredArg()
                        .ofType(Boolean.class).defaultsTo(false);
                acceptsAll(asList("scandirectory"), "Which folder to scan").withRequiredArg()
                        .ofType(String.class).defaultsTo("plugins");
                acceptsAll(asList("scanfile"), "Scan a single file").withRequiredArg()
                        .ofType(String.class);
                acceptsAll(asList("falsepositivesgalore"), "Register a check that 100% false positives")
                        .withRequiredArg().ofType(Boolean.class);
                acceptsAll(asList("printOnlyIfInfected"), "Only prints messages to the console if these are warnings about infected plugins.")
                        .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
                acceptsAll(asList("help"), "Show the help");
            }
        };
        options = null;
        try {
            options = parser.parse(args);
        } catch (joptsimple.OptionException ex) {
            logger.exception(ex.toString());
        }
        if (options != null) {
            if (options.has("help")) {
                try {
                    parser.printHelpOn(System.out);
                } catch (IOException ex) {
                    logger.exception(ex);
                }
                System.exit(0);
            }
            if (options.has("scandirectory")) {
                String scanDirectoryOption = (String) options.valueOf("scandirectory");
                scanDirectory = new File(scanDirectoryOption);
            }
            if (options.has("zipMalPlugins")) {
                zipMaliciousPlugins = (Boolean) options.valueOf("zipMalPlugins");
            }
            if (options.has("debug")) {
                showDebugMessages = (Boolean) options.valueOf("debug");
            }
            if (options.has("scanfile")) {
                scanSingleFile = true;
            }
            if (options.has("falsepositivesgalore")) {
                falsePositivesGalore = (Boolean) options.valueOf("falsepositivesgalore");
            }
            if (options.has("printOnlyIfInfected")) {
                printOnlyIfInfected = (Boolean) options.valueOf("printOnlyIfInfected");
            }
        }
    }

    public void init() {
        AntiMalware.setMain(this);
        LoggerContext ctx = (LoggerContext) LogManager.getContext(false);
        Configuration config = ctx.getConfiguration();
        LoggerConfig loggerConfig = config.getLoggerConfig(LogManager.ROOT_LOGGER_NAME);
        loggerConfig.setLevel(Level.ALL);
        ctx.updateLoggers();
        File file = new File("AntiMalware");
        if (!file.exists()) {
            file.mkdirs();
        }
        try {
            this.reader = new ConsoleReader();
        } catch (IOException ex) {
            logger.exception(ex);
        }
        ConsoleLogManager.init(this);
        try {
            System.setOut(new PrintStream(new LoggerOutputStream(logger.getLogger(), Level.INFO), true, "UTF-8"));
            System.setErr(new PrintStream(new LoggerOutputStream(logger.getLogger(), Level.SEVERE), true, "UTF-8"));
        } catch (UnsupportedEncodingException ex) {
            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
        }
        if (scriptsFile.exists()) {
            try {
                ZipUtils.zipDir(scriptsFile.toPath());
            } catch (IOException ex) {
                if (shouldLogDebugMessages()) {
                    logger.exception(ex);
                }
            }
        }
        downloadChecksumDatabase(false);
        checkManager = new CheckManager(this);
        new CheckRegistery(this).registerChecks();
    }

    @Override
    public void run() {
        init();
        parseArgs();
        if (scanSingleFile) {
            File f = new File((String) options.valueOf("scanfile"));
            if (!f.exists()) {
                logger.info(options.valueOf("scanfile") + " doesn't exist");
                return;
            }
            checkManager.process(f);
            return;
        }

        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
        executor.scheduleWithFixedDelay(() -> {
            downloadChecksumDatabase(true);
        }, 1, 4, TimeUnit.HOURS);
        try {
            watcher = new DirectoryWatcherService(this, scanDirectory.toPath(), true);
        } catch (IOException ex) {
            logger.exception(ex.toString());
        }
        if (showDebugMessages) {
            logger.debug("Should zip malicious plugins: " + zipMaliciousPlugins);
            logger.debug("Should print debug messages: " + showDebugMessages);
            logger.debug("Scan Directory: " + scanDirectory.toString());
            logger.debug("Show debug messages: " + showDebugMessages);
        }
        watcher.start();
        watcher.firstRun();
    }

    public File getMalPluginsFolder() {
        return malPluginsFolder;
    }

    public CheckManager getCheckManager() {
        return checkManager;
    }

    public boolean shouldZipMaliciousPlugins() {
        return zipMaliciousPlugins;
    }

    public boolean moveFile(String sourcePath, String targetPath) {
        boolean fileMoved = true;
        try {
            Files.move(Paths.get(sourcePath), Paths.get(targetPath), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            fileMoved = false;
        }
        return fileMoved;
    }

    public void addMaliciousPlugin(File file) {
        maliciousPlugins.add(file);
    }

    public void zipMaliciousPlugins() {
        if (!shouldZipMaliciousPlugins()) {
            return;
        }
        if (!malPluginsFolder.exists()) {
            malPluginsFolder.mkdirs();
        }
        for (Iterator<File> iter = maliciousPlugins.iterator(); maliciousPlugins.iterator().hasNext();) {
            File element = iter.next();
            moveFile(element.getPath(), malPluginsFolder + File.separator + element.getName());
            iter.remove();
        }
        try {
            ZipUtils.zipDir(malPluginsFolder.toPath());
        } catch (IOException ex) {
            if (shouldLogDebugMessages()) {
                logger.exception(ex);
            }
        }
    }

    public void setMaliciousPluginsFound(boolean foundMaliciousPlugins) {
        maliciousPluginsFound = foundMaliciousPlugins;
    }

    public void setScanDirectory(File scanDirectory) {
        this.scanDirectory = scanDirectory;
    }

    public void setFalsePositivesGalore(boolean falsePositivesGalore) {
        this.falsePositivesGalore = falsePositivesGalore;
    }

    public void setZipMaliciousPlugins(boolean zipMaliciousPlugins) {
        this.zipMaliciousPlugins = zipMaliciousPlugins;
    }

    public boolean shouldLogDebugMessages() {
        return showDebugMessages;
    }

    public boolean foundMaliciousPlugins() {
        return maliciousPluginsFound;
    }

    public ConsoleReader getConsoleReader() {
        return reader;
    }

    public CustomLogger getLogger() {
        return logger;
    }

    public File getScanDirectory() {
        return scanDirectory;
    }

    public FileConfiguration getChecksumDatabase() {
        return checksumDatabase;
    }

    public static void main(String[] args) {
        if(!GraphicsEnvironment.isHeadless()) {
            if(JavaUtil.getJavaVersion() < 11){
                GuiLauncher.start(); // do not use #launch() directly
                return;
            }
            // a simple trick to run javafx on java 11+
            try {
                Class.forName("javafx.application.Application"); // check if javafx is supported
                GuiLauncher.start();
            } catch (ClassNotFoundException ignored) {
                new Thread(() -> {
                    String javaFxPath = System.getenv("PATH_TO_FX");
                    try {
                        File currentJar = new File(Main.class.getProtectionDomain().getCodeSource().getLocation().toURI());
                        // rerun this application with javafx support
                        Runtime.getRuntime().exec("javaw -p \""+javaFxPath+"\" --add-modules javafx.controls,javafx.fxml -jar \""+currentJar.getPath()+"\" optic_fusion1.mcantimalware.Main");
                    } catch (IOException | URISyntaxException ex) {
                        ex.printStackTrace();
                    }
                }).start();
            }
            return;
        }
        Main main = new Main();
        main.args = args;
        new Thread(main).start();
    }

    private void downloadChecksumDatabase(boolean updateCheckManager) {
        try {
            if (shouldLogDebugMessages()) {
                logger.debug("DATABASE");
                logger.debug(IOUtils.toString(new URL("https://raw.githubusercontent.com/OpticFusion1/MCAntiMalwareChecksumList/master/checksums.yml"), "UTF-8"));
            }
            logger.info("Gathering checksum database" + (updateCheckManager ? "(AUTO-UPDATE)" : ""));
            checksumDatabase = YamlConfiguration.loadConfiguration(IOUtils.toInputStream(IOUtils.toString(new URL("https://raw.githubusercontent.com/OpticFusion1/MCAntiMalwareChecksumList/master/checksums.yml"), "UTF-8"), "UTF-8"));
            logger.info("Finished gathering checksum database" + (updateCheckManager ? "(AUTO-UPDATE)" : ""));
            if (updateCheckManager) {
                checkManager.reloadChecksumDatabase();
                logger.info("Rescanning due to updated database");
                watcher.scanFiles();
                logger.info("Finished rescanning");
            }
        } catch (IOException ex) {
            if (shouldLogDebugMessages()) {
                logger.exception(ex);
            }
        }
    }

    public boolean falsePositivesGalore() {
        return falsePositivesGalore;
    }

    public boolean printOnlyIfInfected() {
        return printOnlyIfInfected;
    }

}
