package xbrowniecodez.mcantimalware.check.directleaks;

import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Iterator;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.Check;
import optic_fusion1.mcantimalware.check.CheckType;
import optic_fusion1.mcantimalware.check.checks.Minator;
import optic_fusion1.mcantimalware.check.checks.SkySneak;
import optic_fusion1.mcantimalware.deobfuscator.StringDeobfuscator;

public class DirectLeaks extends Check {

	public DirectLeaks(Main main) {
		super("DirectLeaks", main, CheckType.PUP);
	}

	@Override
	public boolean process(String fileName, ZipFile zipFile) {
		Enumeration<? extends ZipEntry> entries = zipFile.entries();
		InputStream inputStream = null;
		while (entries.hasMoreElements()) {
			try {
				ZipEntry current = entries.nextElement();
				inputStream = zipFile.getInputStream(current);
				if (current.getName().endsWith(".class")) {
					try {
						ClassReader reader = new ClassReader(inputStream);
						ClassNode node = new ClassNode();
						reader.accept(node, 0);
						if (detect(node)) {
							inputStream.close();
							return true;
						}
					} catch (Exception e) {
						continue;
					}
				}
				inputStream.close();
			} catch (IOException ex) {
				Logger.getLogger(Minator.class.getName()).log(Level.SEVERE, null, ex);
			}
		}
		if (inputStream != null) {
			try {
				inputStream.close();
			} catch (IOException ex) {
				Logger.getLogger(SkySneak.class.getName()).log(Level.SEVERE, null, ex);
			}
		}
		return false;
	}

	@Override
	public boolean detect(InputStream inputStream) {
		return false;
	}

	@Override
	public boolean detect(ClassNode classNode) {
		if (classNode.name.contains("de/xbrowniecodez/dlapi")) {
			return true;
		}
		List<MethodNode> nodes = classNode.methods;
		for (MethodNode node : nodes) {
			for (AbstractInsnNode insnNode : node.instructions.toArray()) {
				if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
					String string = ((LdcInsnNode) insnNode).cst.toString();
					boolean xorv1 = containsBlacklistedWord(StringDeobfuscator.XORV1(string));
					boolean xorv2 = containsBlacklistedWord(StringDeobfuscator.XORV2(string));
					boolean xorv3 = containsBlacklistedWord(StringDeobfuscator.XORV3(string));
					boolean xorv4 = containsBlacklistedWord(StringDeobfuscator.decryptionArray(string));
					boolean sig = checkForDLSignature(classNode);
					boolean host = false;
					try {
						host = doesDLHostCheckexist(classNode);
					} catch (Throwable e) {
						
					}
					if (xorv1 || xorv2 || xorv3 || xorv4 || host || sig) {
						return true;
					}
				}
			}
		}
		return false;
	}

	public boolean containsBlacklistedWord(String string) {
		String[] blacklistedWords = new String[] { "#directleaks", "Please contact DirectLeaks. 0x2",
				"http://api.directleaks.net/api/directleaks", "[DirectLeaks] Error Code: 0x1", "Anti-Releak",
				"DirectLeaks", "vmi209890.contaboserver.net", "167.86.75.51", "#DirectLeaks Anti-Releak",
				"DirectLeaks-API", "de.xbrowniecodez.dlapi.Main", "de.xbrowniecodez.dlapi.HostsCheck" };
		for (String blacklistedWord : blacklistedWords) {
			if (string.contains(blacklistedWord)) {
				return true;
			}
		}
		return false;
	}

	public boolean doesDLHostCheckexist(ClassNode classNode) throws Throwable {
		Iterator<MethodNode> iterator = classNode.methods.iterator();
		while (iterator.hasNext()) {
			MethodNode attributeIterator = (MethodNode) iterator.next();
			if (attributeIterator.name.equalsIgnoreCase("onEnable")) {
				InsnList attribute = attributeIterator.instructions;
				AbstractInsnNode insnNode = attribute.get(0);
				if (insnNode.getType() == 5 && insnNode.getOpcode() == 184
						&& ((MethodInsnNode) insnNode).desc.equals("()V")) {
					return true;
				}
			} else if (attributeIterator.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")
					&& attributeIterator.access == 4170) {
				return true;
			}
		}
		return false;
	}

	public boolean checkForDLSignature(ClassNode classNode) {
		if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
				|| classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
			if (classNode.signature.contains("directleaks")) {
				return true;
			}
		}
		return false;
	}
}
