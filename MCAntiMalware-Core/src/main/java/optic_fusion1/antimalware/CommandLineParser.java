/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import optic_fusion1.antimalware.servers.runtimeprotect.PluginIndex;
import optic_fusion1.antimalware.utils.I18n;

import java.io.File;
import java.io.IOException;
import java.util.List;

import static optic_fusion1.antimalware.AntiMalware.LOGGER;

// TODO: Look into cleaning up this class if possible
public class CommandLineParser {

  private static final OptionParser OPTION_PARSER = new OptionParser() {
    {
      acceptsAll(List.of("scanDirectory"), "Which folder to scan")
              .withRequiredArg().ofType(String.class).defaultsTo("plugins");
      acceptsAll(List.of("scanFile"), "Which file to scan").withRequiredArg().ofType(String.class);
      acceptsAll(List.of("printNotInfectedMessages"), "Whether \"not infected\" messages should be logged")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
      acceptsAll(List.of("help"), "Show the help");
      acceptsAll(List.of("language"), "Which language to use")
              .withRequiredArg().ofType(String.class).defaultsTo("en");
      acceptsAll(List.of("notify"), "Which notification method should be used (method: console, discord, popup)")
              .withRequiredArg().ofType(String.class).defaultsTo("console");
      acceptsAll(List.of("serverJar"), "Server jar that should be ran")
              .withRequiredArg().ofType(String.class);
      acceptsAll(List.of("serverArguments"), "The server arguments that'll be used when starting the server")
              .withRequiredArg().ofType(String.class).withValuesSeparatedBy(",");
      acceptsAll(List.of("banMalAuthors"), "Whether to ban ban malicious authors")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
      acceptsAll(List.of("runSecurityManager"), "Whether we should run a custom Security Manager")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
      acceptsAll(List.of("useTransformers"), "Whether we should modify server code to limit malicious plugins")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
      acceptsAll(List.of("scanDrives"), "Whether all drives should be scanned")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
      acceptsAll(List.of("disableAutoUpdate"), "Whether auto-updating should be disabled")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
      acceptsAll(List.of("singleScan"), "Whether we should only scan once")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
      acceptsAll(List.of("scanZippedFiles"), "Whether we should scan zipped files (takes up space)")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
      acceptsAll(List.of("logSM"), "Whether the Security Manager should log security messages")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
      acceptsAll(List.of("enableMetrics"), "Whether metrics should be used or not")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
      acceptsAll(List.of("metricsToken"), "Metrics Organization")
              .withRequiredArg().ofType(String.class);
      acceptsAll(List.of("metricsOrg"), "Metrics Organization")
              .withRequiredArg().ofType(String.class);
      acceptsAll(List.of("metricsBucket"), "Metrics Bucket")
              .withRequiredArg().ofType(String.class).defaultsTo("metrics");
      acceptsAll(List.of("metricsUrl"), "Metrics URL")
              .withRequiredArg().ofType(String.class).defaultsTo("http://localhost:8086");
      acceptsAll(List.of("metricsInterval"), "When to send metrics")
              .withRequiredArg().ofType(Integer.class).defaultsTo(10);
      // TODO: Come up with a better name and description
      acceptsAll(List.of("dontLogINFOCR"), "Doesn't log any INFO check results")
              .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
    }
  };
  private static final I18n I18N = new I18n();
  private OptionSet options;
  private File serverJar;
  private File scanFile;
  private File scanDirectory = new File("plugins");
  private String[] serverArguments = new String[]{};
  private PluginIndex pluginIndex;
  private boolean scanSingleFile = false;
  private String notifyType = "console";
  private boolean banMaliciousAuthors = false;
  private boolean runServerJar = false;
  private boolean printNotInfectedMessage = false;
  private boolean runSecurityManager = true;
  private boolean useTransformers = false;
  private boolean scanDrives = false;
  private boolean disableAutoUpdate = false;
  private boolean singleScan = false;
  private boolean parsedArguments = false;
  private boolean scanZippedFiles = true;
  private boolean logSecurityManager = true;
  private boolean metricsEnabled = false;
  private boolean dontLogINFOCR = false;
  private char[] metricsToken;
  private String metricsOrg;
  private final String metricsBucket = "metrics";
  private final String metricsUrl = "http://localhost:8086";
  private int metricsInterval = 10;

  public void parseArguments(String[] args) {
    if (parsedArguments) {
      return;
    }
    try {
      options = OPTION_PARSER.parse(args);
    } catch (joptsimple.OptionException ex) {
      LOGGER.exception(ex);
      System.exit(0);
    }
    if (options != null) {
      if (options.has("help")) {
        try {
          OPTION_PARSER.printHelpOn(System.out);
        } catch (IOException ex) {
          LOGGER.exception(ex);
        }
        System.exit(0);
      }
      I18N.updateLocale(options.has("language") ? (String) options.valueOf("language") : "en");
      if (options.has("notify")) {
        notifyType = (String) options.valueOf("notify");
      }
      if (options.has("serverJar")) {
        runServerJar = true;
        banMaliciousAuthors = true;
        pluginIndex = new PluginIndex();
        pluginIndex.indexPlugins(new File("plugins"));
        if (options.has("serverArguments")) {
          List<Object> list = (List<Object>) options.valuesOf("serverArguments");
          serverArguments = new String[list.size()];
          list.toArray(serverArguments);
        }
        serverJar = new File((String) options.valueOf("serverJar"));
        if (!serverJar.exists()) {
          LOGGER.info(I18n.tl("file_doesn't_exist", serverJar));
          System.exit(0);
        }
      }
      if (options.has("scanFile")) {
        scanSingleFile = true;
        String value = (String) options.valueOf("scanFile");
        scanFile = new File(value.equals(".") ? "." : value);
        if (!scanFile.exists()) {
          LOGGER.info(I18n.tl("file_doesn't_exist", scanFile));
          System.exit(0);
        }
      }
      if (options.has("printNotInfectedMessages")) {
        printNotInfectedMessage = (boolean) options.valueOf("printNotInfectedMessages");
      }
      if (options.has("scanDirectory")) {
        scanDirectory = new File((String) options.valueOf("scanDirectory"));
        if (!scanDirectory.exists()) {
          LOGGER.info(I18n.tl("file_doesnt_exist", scanFile));
          System.exit(0);
        }
        if (pluginIndex != null) {
          pluginIndex.indexPlugins(scanDirectory);
        }
      }
      if (options.has("banMalAuthors")) {
        banMaliciousAuthors = (boolean) options.valueOf("banMalAuthors");
      }
      if (options.has("runSecurityManager")) {
        runSecurityManager = (boolean) options.valueOf("runSecurityManager");
      }
      if (options.has("useTransformers")) {
        useTransformers = (boolean) options.valueOf("useTransformers");
      }
      if (options.has("scanDrives")) {
        scanDrives = (boolean) options.valueOf("scanDrives");
      }
      if (options.has("disableAutoUpdate")) {
        disableAutoUpdate = (boolean) options.valueOf("disableAutoUpdate");
      }
      if (options.has("singleScan")) {
        singleScan = (boolean) options.valueOf("singleScan");
      }
      if (options.has("scanZippedFiles")) {
        scanZippedFiles = (boolean) options.valueOf("scanZippedFiles");
      }
      if (options.has("logSM")) {
        logSecurityManager = (boolean) options.valueOf("logSM");
      }
      if (options.has("enableMetrics")) {
        metricsEnabled = (boolean) options.valueOf("enableMetrics");
        if (metricsEnabled) {
          if (!checkArgs("metricsToken", "metricsOrg", "metricsBucket", "metricsUrl")) {
            metricsEnabled = false;
          }
        }
      }
      if (options.has("metricsInterval")) {
        metricsInterval = (int) options.valueOf("metricsInterval");
      }
      if (options.has("dontLogINFOCR")) {
        dontLogINFOCR = (boolean) options.valueOf("dontLogINFOCR");
      }
    }
    parsedArguments = true;
  }

  private boolean checkArgs(String... args) {
    for (String arg : args) {
      if (!options.has(arg) || ((String) options.valueOf(arg)).isEmpty()) {
        LOGGER.warn(I18n.tl("command_line_argument_invalid", arg));
        return false;
      }
    }
    return true;
  }

  public boolean shouldScanSingleFile() {
    return scanSingleFile;
  }

  public OptionSet getOptions() {
    return options;
  }

  public File getServerJar() {
    return serverJar;
  }

  public boolean shouldBanMaliciousAuthors() {
    return banMaliciousAuthors;
  }

  public boolean shouldRunServerJar() {
    return runServerJar;
  }

  public String[] getServerArguments() {
    return serverArguments;
  }

  public PluginIndex getPluginIndex() {
    return pluginIndex;
  }

  public File getScanFile() {
    return scanFile;
  }

  public boolean shouldPrintNotInfectedMessages() {
    return printNotInfectedMessage;
  }

  public File getScanDirectory() {
    return scanDirectory;
  }

  public boolean shouldRunSecurityManager() {
    return runSecurityManager;
  }

  public boolean shouldUseTransformers() {
    return useTransformers;
  }

  public boolean shouldScanDrives() {
    return scanDrives;
  }

  public boolean shouldDisableAutoUpdate() {
    return disableAutoUpdate;
  }

  public boolean singleScan() {
    return singleScan;
  }

  public boolean shouldScanZippedFiles() {
    return scanZippedFiles;
  }

  public boolean shouldLogSecurityManager() {
    return logSecurityManager;
  }

  public String getNotificationType() {
    return notifyType;
  }

  public char[] getMetricsToken() {
    return metricsToken;
  }

  public String getMetricsOrg() {
    return metricsOrg;
  }

  public String getMetricsBucket() {
    return metricsBucket;
  }

  public String getMetricsUrl() {
    return metricsUrl;
  }

  public boolean shouldUseMetrics() {
    return metricsEnabled;
  }

  public int getMetricsInterval() {
    return metricsInterval;
  }

  public boolean dontLogINFOCR() {
    return dontLogINFOCR;
  }

}
