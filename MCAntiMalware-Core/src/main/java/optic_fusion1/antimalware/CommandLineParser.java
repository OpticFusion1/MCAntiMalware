/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import optic_fusion1.antimalware.servers.runtimeprotect.PluginIndex;
import optic_fusion1.antimalware.utils.I18n;

import java.io.File;
import java.io.IOException;

import static java.util.Arrays.asList;
import java.util.List;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;

// TODO: Look into cleaning up this class if possible
public class CommandLineParser {

    private static final OptionParser OPTION_PARSER = new OptionParser() {
        {
            acceptsAll(asList("scanDirectory"), "Which folder to scan")
                    .withRequiredArg().ofType(String.class).defaultsTo("plugins");
            acceptsAll(asList("scanFile"), "Which file to scan").withRequiredArg().ofType(String.class);
            acceptsAll(asList("printNotInfectedMessages"), "Whether \"not infected\" messages should be logged")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("help"), "Show the help");
            acceptsAll(asList("gui"), "That the program is ran in GUI mode")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("language"), "Which language to use")
                    .withRequiredArg().ofType(String.class).defaultsTo("en");
            acceptsAll(asList("notify"), "Which notification method should be used (method: console, discord, popup)")
                    .withRequiredArg().ofType(String.class).defaultsTo("console");
            acceptsAll(asList("serverJar"), "Server jar that should be ran")
                    .withRequiredArg().ofType(String.class);
            acceptsAll(asList("serverArguments"), "The server arguments that'll be used when starting the server")
                    .withRequiredArg().ofType(String.class).withValuesSeparatedBy(",");
            acceptsAll(asList("banMalAuthors"), "Whether to ban ban malicious authors")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
            acceptsAll(asList("runSecurityManager"), "Whether we should run a custom Security Manager")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
            acceptsAll(asList("useTransformers"), "Whether we should modify server code to limit malicious plugins")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("scanDrives"), "Whether all drives should be scanned")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("disableAutoUpdate"), "Whether auto-updating should be disabled")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("singleScan"), "Whether we should only scan once")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("scanZippedFiles"), "Whether we should scan zipped files (takes up space)")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
            acceptsAll(asList("logSM"), "Whether the Security Manager should log security messages")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
            // TODO: Come up with a better name and description
            acceptsAll(asList("dontLogINFOCR"), "Doesn't log any INFO check results")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
        }
    };
    private static final I18n I18N = new I18n();
    private OptionSet options;
    private File serverJar;
    private File scanFile;
    private File scanDirectory = new File("plugins");
    private String[] serverArguments = new String[]{};
    private PluginIndex pluginIndex;
    private boolean scanSingleFile = false;
    private String notifyType = "console";
    private boolean banMaliciousAuthors = false;
    private boolean runServerJar = false;
    private boolean printNotInfectedMessage = false;
    private boolean runSecurityManager = true;
    private boolean useTransformers = false;
    private boolean scanDrives = false;
    private boolean disableAutoUpdate = false;
    private boolean singleScan = false;
    private boolean parsedArguments = false;
    private boolean scanZippedFiles = true;
    private boolean logSecurityManager = true;
    private boolean dontLogINFOCR = false;
    private boolean gui = false;

    public void parseArguments(String[] args) {
        if (parsedArguments) {
            return;
        }
        try {
            options = OPTION_PARSER.parse(args);
        } catch (joptsimple.OptionException ex) {
            LOGGER.exception(ex);
            System.exit(0);
        }
        if (options != null) {
            if (options.has("help")) {
                try {
                    OPTION_PARSER.printHelpOn(System.out);
                } catch (IOException ex) {
                    LOGGER.exception(ex);
                }
                System.exit(0);
            }
            I18N.updateLocale(options.has("language") ? (String) options.valueOf("language") : "en");
            if (options.has("notify")) {
                notifyType = (String) options.valueOf("notify");
            }

            if(options.has("gui")) {

                gui = true;
                parsedArguments = true;

                return;
            }

            if (options.has("serverJar")) {
                runServerJar = true;
                banMaliciousAuthors = true;
                pluginIndex = new PluginIndex();
                pluginIndex.indexPlugins(new File("plugins"));
                if (options.has("serverArguments")) {
                    List<Object> list = (List<Object>) options.valuesOf("serverArguments");
                    serverArguments = new String[list.size()];
                    list.toArray(serverArguments);
                }
                serverJar = new File((String) options.valueOf("serverJar"));
                if (!serverJar.exists()) {
                    LOGGER.info(I18n.tl("file_doesn't_exist", serverJar));
                    System.exit(0);
                }
            }
            if (options.has("scanFile")) {
                scanSingleFile = true;
                String value = (String) options.valueOf("scanFile");
                scanFile = new File(value.equals(".") ? "." : value);
                if (!scanFile.exists()) {
                    LOGGER.info(I18n.tl("file_doesn't_exist", scanFile));
                    System.exit(0);
                }
            }
            if (options.has("printNotInfectedMessages")) {
                printNotInfectedMessage = (boolean) options.valueOf("printNotInfectedMessages");
            }
            if (options.has("scanDirectory")) {
                scanDirectory = new File((String) options.valueOf("scanDirectory"));
                if (!scanDirectory.exists()) {
                    LOGGER.info(I18n.tl("file_doesnt_exist", scanFile));
                    System.exit(0);
                }
                if (pluginIndex != null) {
                    pluginIndex.indexPlugins(scanDirectory);
                }
            }
            if (options.has("banMalAuthors")) {
                banMaliciousAuthors = (boolean) options.valueOf("banMalAuthors");
            }
            if (options.has("runSecurityManager")) {
                runSecurityManager = (boolean) options.valueOf("runSecurityManager");
            }
            if (options.has("useTransformers")) {
                useTransformers = (boolean) options.valueOf("useTransformers");
            }
            if (options.has("scanDrives")) {
                scanDrives = (boolean) options.valueOf("scanDrives");
            }
            if (options.has("disableAutoUpdate")) {
                disableAutoUpdate = (boolean) options.valueOf("disableAutoUpdate");
            }
            if (options.has("singleScan")) {
                singleScan = (boolean) options.valueOf("singleScan");
            }
            if (options.has("scanZippedFiles")) {
                scanZippedFiles = (boolean) options.valueOf("scanZippedFiles");
            }
            if (options.has("logSM")) {
                logSecurityManager = (boolean) options.valueOf("logSM");
            }
            if (options.has("dontLogINFOCR")) {
                dontLogINFOCR = (boolean) options.valueOf("dontLogINFOCR");
            }
        }
        parsedArguments = true;
    }

    private boolean checkArgs(String... args) {
        for (String arg : args) {
            if (!options.has(arg) || ((String) options.valueOf(arg)).isEmpty()) {
                LOGGER.warn(I18n.tl("command_line_argument_invalid", arg));
                return false;
            }
        }
        return true;
    }

    public boolean isHeadless() {
        return !gui;
    }

    public boolean shouldScanSingleFile() {
        return scanSingleFile;
    }

    public OptionSet getOptions() {
        return options;
    }

    public File getServerJar() {
        return serverJar;
    }

    public boolean shouldBanMaliciousAuthors() {
        return banMaliciousAuthors;
    }

    public boolean shouldRunServerJar() {
        return runServerJar;
    }

    public String[] getServerArguments() {
        return serverArguments;
    }

    public PluginIndex getPluginIndex() {
        return pluginIndex;
    }

    public File getScanFile() {
        return scanFile;
    }

    public boolean shouldPrintNotInfectedMessages() {
        return printNotInfectedMessage;
    }

    public File getScanDirectory() {
        return scanDirectory;
    }

    public boolean shouldRunSecurityManager() {
        return runSecurityManager;
    }

    public boolean shouldUseTransformers() {
        return useTransformers;
    }

    public boolean shouldScanDrives() {
        return scanDrives;
    }

    public boolean shouldDisableAutoUpdate() {
        return disableAutoUpdate;
    }

    public boolean singleScan() {
        return singleScan;
    }

    public boolean shouldScanZippedFiles() {
        return scanZippedFiles;
    }

    public boolean shouldLogSecurityManager() {
        return logSecurityManager;
    }

    public String getNotificationType() {
        return notifyType;
    }

    public boolean dontLogINFOCR() {
        return dontLogINFOCR;
    }

}
