/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware;

import java.io.File;
import java.io.IOException;
import static java.util.Arrays.asList;
import joptsimple.OptionParser;
import joptsimple.OptionSet;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import optic_fusion1.antimalware.utils.I18n;

// TODO: Look into cleaning up this class if possible
public class CommandLineParser {

    private static final OptionParser OPTION_PARSER = new OptionParser() {
        {
            acceptsAll(asList("scanDirectory"), "Which folder to scan")
                    .withRequiredArg().ofType(String.class).defaultsTo("plugins");
            acceptsAll(asList("scanFile"), "Which file to scan").withRequiredArg().ofType(String.class);
            acceptsAll(asList("printNotInfectedMessages"), "Whether \"not infected\" messages should be logged")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("help"), "Show the help");
            acceptsAll(asList("gui"), "That the program is ran in GUI mode")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("language"), "Which language to use")
                    .withRequiredArg().ofType(String.class).defaultsTo("en");
            acceptsAll(asList("notify"), "Which notification method should be used (method: console, discord, popup)")
                    .withRequiredArg().ofType(String.class).defaultsTo("console");
            acceptsAll(asList("scanDrives"), "Whether all drives should be scanned")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("disableAutoUpdate"), "Whether auto-updating should be disabled")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("singleScan"), "Whether we should only scan once")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
            acceptsAll(asList("scanZippedFiles"), "Whether we should scan zipped files (takes up space)")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
            acceptsAll(asList("logSM"), "Whether the Security Manager should log security messages")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(true);
            // TODO: Come up with a better name and description
            acceptsAll(asList("dontLogINFOCR"), "Doesn't log any INFO check results")
                    .withRequiredArg().ofType(Boolean.class).defaultsTo(false);
        }
    };
    private static final I18n I18N = new I18n();
    private OptionSet options;
    private File scanFile;
    private File scanDirectory = new File("plugins");
    private boolean scanSingleFile = false;
    private String notifyType = "console";
    private boolean printNotInfectedMessage = false;
    private boolean scanDrives = false;
    private boolean disableAutoUpdate = false;
    private boolean singleScan = false;
    private boolean alreadyParsedArguments = false;
    private boolean scanZippedFiles = true;
    private boolean logSecurityManager = true;
    private boolean dontLogINFOCR = false;
    private boolean gui = false;

    /**
     * Parses command line arguments. If command line arguments have already been parsed then it just returns instead
     *
     * @param args The command line arguments to parse.
     */
      public void parseArguments(String[] args) {
        if (alreadyParsedArguments) {
            return;
        }
        try {
            options = OPTION_PARSER.parse(args);
        } catch (joptsimple.OptionException ex) {
            LOGGER.exception(ex);
            System.exit(0);
        }
        if (options != null) {
            if (options.has("help")) {
                try {
                    OPTION_PARSER.printHelpOn(System.out);
                } catch (IOException ex) {
                    LOGGER.exception(ex);
                }
                System.exit(0);
            }
            I18N.updateLocale(options.has("language") ? (String) options.valueOf("language") : "en");
            if (options.has("notify")) {
                notifyType = (String) options.valueOf("notify");
            }
            if(options.has("gui")) {
                gui = true;
                parsedArguments = true;
                return;
            }
            if (options.has("scanFile")) {
                scanSingleFile = true;
                String value = (String) options.valueOf("scanFile");
                scanFile = new File(value.equals(".") ? "." : value);
                if (!scanFile.exists()) {
                    LOGGER.info(I18n.tl("file_doesn't_exist", scanFile));
                    System.exit(0);
                }
            }
            if (options.has("printNotInfectedMessages")) {
                printNotInfectedMessage = (boolean) options.valueOf("printNotInfectedMessages");
            }
            if (options.has("scanDirectory")) {
                scanDirectory = new File((String) options.valueOf("scanDirectory"));
                if (!scanDirectory.exists()) {
                    LOGGER.info(I18n.tl("file_doesnt_exist", scanFile));
                    System.exit(0);
                }
            }
            if (options.has("scanDrives")) {
                scanDrives = (boolean) options.valueOf("scanDrives");
            }
            if (options.has("disableAutoUpdate")) {
                disableAutoUpdate = (boolean) options.valueOf("disableAutoUpdate");
            }
            if (options.has("singleScan")) {
                singleScan = (boolean) options.valueOf("singleScan");
            }
            if (options.has("scanZippedFiles")) {
                scanZippedFiles = (boolean) options.valueOf("scanZippedFiles");
            }
            if (options.has("logSM")) {
                logSecurityManager = (boolean) options.valueOf("logSM");
            }
            if (options.has("dontLogINFOCR")) {
                dontLogINFOCR = (boolean) options.valueOf("dontLogINFOCR");
            }
        }
        alreadyParsedArguments = true;
    }

    public boolean isHeadless() {
        return !gui;
    }

    public boolean shouldScanSingleFile() {
        return scanSingleFile;
    }

    public OptionSet getOptions() {
        return options;
    }

    public File getScanFile() {
        return scanFile;
    }

    public boolean shouldPrintNotInfectedMessages() {
        return printNotInfectedMessage;
    }

    public File getScanDirectory() {
        return scanDirectory;
    }

    public boolean shouldScanDrives() {
        return scanDrives;
    }

    public boolean shouldDisableAutoUpdate() {
        return disableAutoUpdate;
    }

    public boolean singleScan() {
        return singleScan;
    }

    public boolean shouldScanZippedFiles() {
        return scanZippedFiles;
    }

    public boolean shouldLogSecurityManager() {
        return logSecurityManager;
    }

    public String getNotificationType() {
        return notifyType;
    }

    public boolean dontLogINFOCR() {
        return dontLogINFOCR;
    }

}
