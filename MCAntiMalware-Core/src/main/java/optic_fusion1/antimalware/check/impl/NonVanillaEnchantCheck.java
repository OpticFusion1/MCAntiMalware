/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.check.impl;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import optic_fusion1.antimalware.check.BaseCheck;
import optic_fusion1.antimalware.check.CacheContainer;
import optic_fusion1.antimalware.check.CheckResult;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

// False-Positives a lot, perhaps move this to Kitsune instead?
public class NonVanillaEnchantCheck extends BaseCheck {

    private static final HashMap<String, Integer> ENCHANTMENT_MAX_LEVELS = new HashMap<>();

    public NonVanillaEnchantCheck() {
        ENCHANTMENT_MAX_LEVELS.put("PROTECTION_ENVIRONMENTAL", 4);
        ENCHANTMENT_MAX_LEVELS.put("PROTECTION_FIRE", 4);
        ENCHANTMENT_MAX_LEVELS.put("PROTECTION_FALL", 4);
        ENCHANTMENT_MAX_LEVELS.put("PROTECTION_EXPLOSIONS", 4);
        ENCHANTMENT_MAX_LEVELS.put("PROTECTION_PROJECTILE", 4);
        ENCHANTMENT_MAX_LEVELS.put("OXYGEN", 3);
        ENCHANTMENT_MAX_LEVELS.put("WATER_WORKER", 1);
        ENCHANTMENT_MAX_LEVELS.put("THORNS", 3);
        ENCHANTMENT_MAX_LEVELS.put("DEPTH_STRIDER", 3);
        ENCHANTMENT_MAX_LEVELS.put("FROST_WALKER", 2);
        ENCHANTMENT_MAX_LEVELS.put("BINDING_CURSE", 1);
        ENCHANTMENT_MAX_LEVELS.put("DAMAGE_ALL", 5);
        ENCHANTMENT_MAX_LEVELS.put("DAMAGE_UNDEAD", 5);
        ENCHANTMENT_MAX_LEVELS.put("DAMAGE_ARTHROPODS", 5);
        ENCHANTMENT_MAX_LEVELS.put("KNOCKBACK", 2);
        ENCHANTMENT_MAX_LEVELS.put("FIRE_ASPECT", 2);
        ENCHANTMENT_MAX_LEVELS.put("LOOT_BONUS_MOBS", 3);
        ENCHANTMENT_MAX_LEVELS.put("SWEEPING_EDGE", 3);
        ENCHANTMENT_MAX_LEVELS.put("DIG_SPEED", 5);
        ENCHANTMENT_MAX_LEVELS.put("SILK_TOUCH", 1);
        ENCHANTMENT_MAX_LEVELS.put("DURABILITY", 3);
        ENCHANTMENT_MAX_LEVELS.put("LOOT_BONUS_BLOCKS", 3);
        ENCHANTMENT_MAX_LEVELS.put("ARROW_DAMAGE", 6);
        ENCHANTMENT_MAX_LEVELS.put("ARROW_KNOCKBACK", 2);
        ENCHANTMENT_MAX_LEVELS.put("ARROW_FIRE", 1);
        ENCHANTMENT_MAX_LEVELS.put("ARROW_INFINITE", 1);
        ENCHANTMENT_MAX_LEVELS.put("LUCK", 3);
        ENCHANTMENT_MAX_LEVELS.put("LURE", 3);
        ENCHANTMENT_MAX_LEVELS.put("LOYALTY", 3);
        ENCHANTMENT_MAX_LEVELS.put("IMPALING", 5);
        ENCHANTMENT_MAX_LEVELS.put("RIPTIDE", 3);
        ENCHANTMENT_MAX_LEVELS.put("CHANNELING", 1);
        ENCHANTMENT_MAX_LEVELS.put("MULTISHOT", 1);
        ENCHANTMENT_MAX_LEVELS.put("QUICK_CHARGE", 3);
        ENCHANTMENT_MAX_LEVELS.put("PIERCING", 4);
        ENCHANTMENT_MAX_LEVELS.put("MENDING", 1);
        ENCHANTMENT_MAX_LEVELS.put("VANISHING_CURSE", 1);
        ENCHANTMENT_MAX_LEVELS.put("SOUL_SPEED", 3);
    }

    @Override
    public List<CheckResult> process(ClassNode classNode, Path rootFolder, Path zipFile, CacheContainer cache) {
        List<CheckResult> results = new ArrayList<>();
        for (MethodNode methodNode : classNode.methods) {
            int i = hasNonVanillaEnchant(methodNode);
            if (i != -1) {
                results.add(new CheckResult("Spigot", "INFO", "Non-Vanilla Enchantment", "A", classNode.sourceFile,
                        classNode.name, i));
            }
        }
        return results;
    }

    private int hasNonVanillaEnchant(MethodNode method) {
        int curLine = -1;
        int foundLine = -1;

        for (AbstractInsnNode abstractInsnNode : method.instructions) {
            if (abstractInsnNode instanceof MethodInsnNode methodInsnNode) {
                if (methodInsnNode.owner.equals("org/bukkit/inventory/meta/ItemMeta") && methodInsnNode.name.equals("addEnchant")
                        && methodInsnNode.desc.equals("(Lorg/bukkit/enchantments/Enchantment;IZ)Z")) {
                    AbstractInsnNode enchantLevelNode = methodInsnNode.getPrevious().getPrevious();
                    int enchantLevel = 1;
                    if (enchantLevelNode instanceof IntInsnNode intInsnNode) {
                        enchantLevel = intInsnNode.operand;
                    }
                    if (!(enchantLevelNode.getPrevious() instanceof FieldInsnNode)) {
                        continue;
                    }
                    FieldInsnNode enchantNameNode = (FieldInsnNode) enchantLevelNode.getPrevious();
                    if (ENCHANTMENT_MAX_LEVELS.containsKey(enchantNameNode.name)) {
                        if (enchantLevel > ENCHANTMENT_MAX_LEVELS.get(enchantNameNode.name)) {
                            foundLine = curLine;
                        }
                    }
                }
            } else if (abstractInsnNode instanceof LineNumberNode lineNumberNode) {
                curLine = lineNumberNode.line;
            }
        }
        return foundLine;
    }

}
