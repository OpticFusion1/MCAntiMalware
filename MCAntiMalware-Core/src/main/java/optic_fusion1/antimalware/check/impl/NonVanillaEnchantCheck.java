/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.check.impl;

import java.nio.file.Path;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import optic_fusion1.antimalware.check.BaseCheck;
import optic_fusion1.antimalware.check.CacheContainer;
import optic_fusion1.antimalware.check.CheckResult;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldInsnNode;
import org.objectweb.asm.tree.IntInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public class NonVanillaEnchantCheck extends BaseCheck {

    private static final Map<String, Integer> ENCHANTMENT_MAX_LEVELS = Map.ofEntries(
            new AbstractMap.SimpleEntry<>("PROTECTION_ENVIRONMENTAL", 4),
            new AbstractMap.SimpleEntry<>("PROTECTION_FIRE", 4),
            new AbstractMap.SimpleEntry<>("PROTECTION_FALL", 4),
            new AbstractMap.SimpleEntry<>("PROTECTION_EXPLOSIONS", 4),
            new AbstractMap.SimpleEntry<>("PROTECTION_PROJECTILE", 4),
            new AbstractMap.SimpleEntry<>("OXYGEN", 3),
            new AbstractMap.SimpleEntry<>("WATER_WORKER", 1),
            new AbstractMap.SimpleEntry<>("THORNS", 3),
            new AbstractMap.SimpleEntry<>("DEPTH_STRIDER", 3),
            new AbstractMap.SimpleEntry<>("FROST_WALKER", 2),
            new AbstractMap.SimpleEntry<>("BINDING_CURSE", 1),
            new AbstractMap.SimpleEntry<>("DAMAGE_ALL", 5),
            new AbstractMap.SimpleEntry<>("DAMAGE_UNDEAD", 5),
            new AbstractMap.SimpleEntry<>("DAMAGE_ARTHROPODS", 5),
            new AbstractMap.SimpleEntry<>("KNOCKBACK", 2),
            new AbstractMap.SimpleEntry<>("FIRE_ASPECT", 2),
            new AbstractMap.SimpleEntry<>("LOOT_BONUS_MOBS", 3),
            new AbstractMap.SimpleEntry<>("SWEEPING_EDGE", 3),
            new AbstractMap.SimpleEntry<>("DIG_SPEED", 5),
            new AbstractMap.SimpleEntry<>("SILK_TOUCH", 1),
            new AbstractMap.SimpleEntry<>("DURABILITY", 3),
            new AbstractMap.SimpleEntry<>("LOOT_BONUS_BLOCKS", 3),
            new AbstractMap.SimpleEntry<>("ARROW_DAMAGE", 6),
            new AbstractMap.SimpleEntry<>("ARROW_KNOCKBACK", 2),
            new AbstractMap.SimpleEntry<>("ARROW_FIRE", 1),
            new AbstractMap.SimpleEntry<>("ARROW_INFINITE", 1),
            new AbstractMap.SimpleEntry<>("LUCK", 3),
            new AbstractMap.SimpleEntry<>("LURE", 3),
            new AbstractMap.SimpleEntry<>("LOYALTY", 3),
            new AbstractMap.SimpleEntry<>("IMPALING", 5),
            new AbstractMap.SimpleEntry<>("RIPTIDE", 3),
            new AbstractMap.SimpleEntry<>("CHANNELING", 1),
            new AbstractMap.SimpleEntry<>("MULTISHOT", 1),
            new AbstractMap.SimpleEntry<>("QUICK_CHARGE", 3),
            new AbstractMap.SimpleEntry<>("PIERCING", 4),
            new AbstractMap.SimpleEntry<>("MENDING", 1),
            new AbstractMap.SimpleEntry<>("VANISHING_CURSE", 1),
            new AbstractMap.SimpleEntry<>("SOUL_SPEED", 3));

    @Override
    public List<CheckResult> process(ClassNode classNode, Path rootFolder, Path zipFile, CacheContainer cache) {
        List<CheckResult> results = new ArrayList<>();
        for (MethodNode methodNode : classNode.methods) {
            int i = hasNonVanillaEnchant(methodNode);
            if (i != -1) {
                results.add(new CheckResult("Spigot", "INFO", "Non-Vanilla Enchantment", "A", classNode.sourceFile,
                        classNode.name, i));
            }
        }
        return results;
    }

    private int hasNonVanillaEnchant(MethodNode method) {
        int curLine = -1;
        int foundLine = -1;

        for (AbstractInsnNode abstractInsnNode : method.instructions) {
            if (abstractInsnNode instanceof MethodInsnNode methodInsnNode) {
                if (methodInsnNode.owner.equals("org/bukkit/inventory/meta/ItemMeta") && methodInsnNode.name.equals("addEnchant")
                        && methodInsnNode.desc.equals("(Lorg/bukkit/enchantments/Enchantment;IZ)Z")) {
                    AbstractInsnNode enchantLevelNode = methodInsnNode.getPrevious().getPrevious();
                    int enchantLevel = 1;
                    if (enchantLevelNode instanceof IntInsnNode intInsnNode) {
                        enchantLevel = intInsnNode.operand;
                    }

                    if(enchantLevelNode.getPrevious() instanceof FieldInsnNode enchantNameNode &&
                       ENCHANTMENT_MAX_LEVELS.containsKey(enchantNameNode.name) &&
                       enchantLevel > ENCHANTMENT_MAX_LEVELS.get(enchantNameNode.name)) {
                        foundLine = curLine;
                    }
                }
            } else if (abstractInsnNode instanceof LineNumberNode lineNumberNode) {
                curLine = lineNumberNode.line;
            }
        }
        return foundLine;
    }

}
