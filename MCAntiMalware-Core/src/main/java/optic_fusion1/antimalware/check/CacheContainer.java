/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.check;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import optic_fusion1.antimalware.configuration.file.YamlConfiguration;
import optic_fusion1.antimalware.database.Database;
import static optic_fusion1.antimalware.utils.I18n.tl;
import org.apache.commons.codec.digest.DigestUtils;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

public class CacheContainer {

    private final CacheMap<ClassNode> cachedClasses = new CacheMap<>();
    private final CacheMap<YamlConfiguration> cachedConfigurations = new CacheMap<>();
    private final CacheMap<String> cachedHashes = new CacheMap<>();
    private HashSet<String> blacklistedClasspaths;
    private HashSet<String> blacklistedStrings;
    private HashSet<String> blacklistedAuthors;
    private HashSet<String> blacklistedWebsites;
    private HashSet<String> blacklistedCommands;
    private HashSet<String> blacklistedUrls;
    private HashSet<String> blacklistedExec;
    private HashSet<String> blacklistedWrite;
    private HashSet<String> blacklistedChecksums;
    private HashSet<String> blacklistedFileNames;
    private HashSet<String> blacklistedFilePaths;
    private HashSet<String> whitelistedChecksums;

    public CacheContainer(Database database) {
        try {
            blacklistedClasspaths = database.getBlacklistedClasspaths();
            blacklistedStrings = database.getBlacklistedStrings();
            blacklistedAuthors = database.getBlacklistedAuthors();
            blacklistedWebsites = database.getBlacklistedWebsites();
            blacklistedCommands = database.getBlacklistedCommands();
            blacklistedUrls = database.getBlacklistedUrls();
            blacklistedExec = database.getBlacklistedExec();
            blacklistedWrite = database.getBlacklistedWrite();
            blacklistedChecksums = database.getBlacklistedChecksums();
            blacklistedFileNames = database.getBlacklistedFileNames();
            blacklistedFilePaths = database.getBlacklistedFilePaths();
            whitelistedChecksums = database.getWhitelistedChecksums();
        } catch (SQLException ex) {
            LOGGER.exception(ex);
        }
    }

    public ClassNode fetchClass(Path filePath, Path path) {
        try {
            if (!cachedClasses.contains(filePath, path)) {
                return loadClass(filePath, path);
            }
            return cachedClasses.get(filePath, path);
        } catch (Exception ex) {
            // Caused by invalid classes that we can't do much, if anything about
//            LOGGER.exception(ex);
        }
        return null;
    }

    private ClassNode loadClass(Path filePath, Path path) {
        try {
            ClassReader classReader = new ClassReader(Files.newInputStream(path));
            ClassNode classNode = new ClassNode();
            classReader.accept(classNode, 0);
            cachedClasses.put(filePath, path, classNode);
            return classNode;
        } catch (IOException e) {
            // Caused by invalid classes that we can't do much, if anything about
//            LOGGER.info(filePath.toString());
//            LOGGER.warn(tl("couldnt_read_class", path.toString()));
//            LOGGER.exception(e);
            cachedClasses.put(filePath, path, null);
            return null;
        }
    }

    public YamlConfiguration fetchConfiguration(Path filePath, Path path) {
        if (!cachedConfigurations.contains(filePath, path)) {
            return loadConfiguration(filePath, path);
        }
        return null;
    }

    private YamlConfiguration loadConfiguration(Path filePath, Path path) {
        try {
            YamlConfiguration config = YamlConfiguration.loadConfiguration(Files.newInputStream(path));
            cachedConfigurations.put(filePath, path, config);
            return config;
        } catch (IOException e) {
            cachedConfigurations.put(filePath, path, null);
            return null;
        }
    }

    public String fetchSHA1(Path filePath, Path path) {
        String hash = cachedHashes.get(filePath, path);
        if (hash == null) {
            return loadSHA1(filePath, path);
        }
        return null;
    }

    public String loadSHA1(Path filePath, Path path) {
        try {
            String hash = DigestUtils.sha1Hex(Files.newInputStream(path));
            cachedHashes.put(filePath, path, hash);
            return hash;
        } catch (IOException e) {
            cachedHashes.put(filePath, path, "");
            e.printStackTrace();
            return "";
        }
    }

    // Attempt at fixing memory issues
    public void clearCache(Path filePath) {
        cachedClasses.remove(filePath.toAbsolutePath());
        cachedConfigurations.remove(filePath.toAbsolutePath());
        cachedHashes.remove(filePath.toAbsolutePath());
    }

    public boolean containsBlacklistedAuthor(String author) {
        return blacklistedAuthors.contains(author);
    }

    public boolean containsBlacklistedWebsite(String website) {
        return blacklistedWebsites.contains(website);
    }

    public boolean containsBlacklistedClassPath(String classPath) {
        return blacklistedClasspaths.contains(classPath);
    }

    public boolean containsBlacklistedString(String string) {
        return blacklistedStrings.contains(string);
    }

    public boolean containsBlacklistedCommand(String command) {
        return blacklistedCommands.contains(command);
    }

    public boolean containsBlacklistedUrl(String url) {
        return blacklistedUrls.contains(url);
    }

    public boolean containsBlacklistedExec(String exec) {
        return blacklistedExec.contains(exec);
    }

    public boolean containsBlacklistedWrite(String file) {
        return blacklistedWrite.contains(file);
    }

    public boolean containsBlacklistedChecksum(String checksum) {
        return blacklistedChecksums.contains(checksum);
    }

    public boolean containsBlacklistedFileName(String fileName) {
        return blacklistedFileNames.contains(fileName);
    }

    public boolean containsBlacklistedFilePath(String filePath) {
        return blacklistedFilePaths.contains(filePath);
    }

    public boolean containsWhitelistedChecksum(String checksum) {
        return whitelistedChecksums.contains(checksum);
    }

    private static class CacheMap<T> {

        private final Function<? super Path, ? extends Map<Path, T>> nestedCreator = p -> new HashMap<>();
        private final Map<Path, Map<Path, T>> map = new ConcurrentHashMap<>();

        public T put(Path filePath, Path path, T value) {
            return map.computeIfAbsent(filePath.toAbsolutePath(), nestedCreator).put(path, value);
        }

        public T get(Path filePath, Path path) {
            Map<Path, T> m = map.get(filePath.toAbsolutePath());
            if (m != null) {
                return m.get(path);
            }
            return null;
        }

        public Map<Path, T> remove(Path filePath) {
            return map.remove(filePath.toAbsolutePath());
        }

        public boolean contains(Path filePath, Path path) {
            Map<Path, T> m = map.get(filePath.toAbsolutePath());
            return m != null && m.containsKey(path);
        }
    }

}
