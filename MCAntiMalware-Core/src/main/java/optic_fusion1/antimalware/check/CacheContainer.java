/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.check;

import optic_fusion1.antimalware.configuration.file.YamlConfiguration;
import optic_fusion1.antimalware.database.Database;
import org.apache.commons.codec.digest.DigestUtils;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Function;

import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import static optic_fusion1.antimalware.utils.I18n.tl;

// TODO: Cache anything else from the database that would get called a lot
public class CacheContainer {

  private final CacheMap<ClassNode> cachedClasses = new CacheMap<>();
  private final CacheMap<YamlConfiguration> cachedConfigurations = new CacheMap<>();
  private final CacheMap<String> cachedHashes = new CacheMap<>();
  private HashSet<String> blacklistedClasspaths;
  private HashSet<String> blacklistedStrings;
  private HashSet<String> blacklistedAuthors;
  private HashSet<String> blacklistedWebsites;

  public CacheContainer(Database database) {
    try {
      blacklistedClasspaths = database.getBlacklistedClasspaths();
      blacklistedStrings = database.getBlacklistedStrings();
      blacklistedAuthors = database.getBlacklistedAuthors();
      blacklistedWebsites = database.getBlacklistedWebsites();
    } catch (SQLException ex) {
      LOGGER.exception(ex);
    }
  }

  public ClassNode fetchClass(Path filePath, Path path) {
    try {
      if (!cachedClasses.contains(filePath, path)) {
        return loadClass(filePath, path);
      }
    } catch (Exception ignored) {}
    return null;
  }

  private ClassNode loadClass(Path filePath, Path path) {
    try {
      ClassReader classReader = new ClassReader(Files.newInputStream(path));
      ClassNode classNode = new ClassNode();
      classReader.accept(classNode, 0);
      cachedClasses.put(filePath, path, classNode);
      return classNode;
    } catch (IOException e) {
      LOGGER.warn(tl("couldnt_read_class", path.toUri().toString()));
      cachedClasses.put(filePath, path, null);
      return null;
    }
  }

  public YamlConfiguration fetchConfiguration(Path filePath, Path path) {
    if (!cachedConfigurations.contains(filePath, path)) {
      return loadConfiguration(filePath, path);
    }
    return null;
  }

  private YamlConfiguration loadConfiguration(Path filePath, Path path) {
    try {
      YamlConfiguration config = YamlConfiguration.loadConfiguration(Files.newInputStream(path));
      cachedConfigurations.put(filePath, path, config);
      return config;
    } catch (IOException e) {
      cachedConfigurations.put(filePath, path, null);
      return null;
    }
  }

  public String fetchSHA1(Path filePath, Path path) {
    String hash = cachedHashes.get(filePath, path);
    if (hash == null) {
      return loadSHA1(filePath, path);
    }
    return null;
  }

  public String loadSHA1(Path filePath, Path path) {
    try {
      String hash = DigestUtils.sha1Hex(Files.newInputStream(path));
      cachedHashes.put(filePath, path, hash);
      return hash;
    } catch (IOException e) {
      cachedHashes.put(filePath, path, "");
      return "";
    }
  }

  // Attempt at fixing memory issues
  public void clearCache(Path filePath) {
    cachedClasses.remove(filePath.toAbsolutePath());
    cachedConfigurations.remove(filePath.toAbsolutePath());
    cachedHashes.remove(filePath.toAbsolutePath());
  }

  public boolean containsBlacklistedAuthor(String author) {
    return blacklistedAuthors.contains(author);
  }

  public boolean containsBlacklistedWebsite(String website) {
    return blacklistedWebsites.contains(website);
  }

  public HashSet<String> getBlacklistedClassPaths() {
    return blacklistedClasspaths;
  }

  public HashSet<String> getBlacklistedStrings() {
    return blacklistedStrings;
  }

  private static class CacheMap<T> {
    private final Function<? super Path, ? extends Map<Path, T>> nestedCreator = p -> new HashMap<>();
    private final Map<Path, Map<Path, T>> map = new ConcurrentHashMap<>();

    public T put(Path filePath, Path path, T value) {
      return map.computeIfAbsent(filePath.toAbsolutePath(), nestedCreator).put(path, value);
    }

    public T get(Path filePath, Path path) {
      Map<Path, T> m = map.get(filePath.toAbsolutePath());
      if (m != null) {
        return m.get(path);
      }
      return null;
    }

    public Map<Path, T> remove(Path filePath) {
      return map.remove(filePath.toAbsolutePath());
    }

    public boolean contains(Path filePath, Path path) {
      Map<Path, T> m = map.get(filePath.toAbsolutePath());
      return m != null && m.containsKey(path);
    }
  }

}
