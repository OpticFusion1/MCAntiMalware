/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.servers.runtimeprotect;

//TODO: Add a metric for this, either giving the total amount of times a plugin triggered the Security Manager, or adding a metric (and measurements) for each method

import optic_fusion1.antimalware.AntiMalware;
import optic_fusion1.antimalware.CommandLineParser;
import optic_fusion1.antimalware.check.CacheContainer;
import optic_fusion1.antimalware.exceptions.FormattedSecurityException;
import optic_fusion1.antimalware.servers.runtimeprotect.callerinfo.CallerInfo;
import optic_fusion1.antimalware.servers.runtimeprotect.callerinfo.RuntimeUtils;

import java.io.File;
import java.io.FileDescriptor;
import java.net.InetAddress;
import java.security.Permission;

import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import static optic_fusion1.antimalware.utils.I18n.tl;

public class AMSecurityManager extends SecurityManager {

  private final CacheContainer cache;
  private final CommandLineParser clp;
  private final AntiMalware antiMalware;

  public AMSecurityManager(AntiMalware antiMalware) {
    cache = antiMalware.getCache();
    this.antiMalware = antiMalware;
    clp = antiMalware.getCommandLineParser();
  }

  @Override
  public void checkSecurityAccess(String target) {
    log(RuntimeUtils.getCallerInfo(), "checkSecurityAccess Target: " + target);
  }

  @Override
  public void checkSetFactory() {
    log(RuntimeUtils.getCallerInfo(), "checkSetFactory");
  }

  @Override
  public void checkPackageDefinition(String pkg) {
    log(RuntimeUtils.getCallerInfo(), "checkPackageDefinition Pkg: " + pkg);
  }

  @Override
  public void checkPackageAccess(String pkg) {
    /*
     Fixes a StackoverFlowError in RuntimeUtils.getCallerInfo
     Could this be done better? Probably, but it works well enough
     */
    if (pkg.equals("optic_fusion1.antimalware.servers.runtimeprotect.callerinfo")) {
      return;
    }
    CallerInfo callerInfo = RuntimeUtils.getCallerInfo();
    if (callerInfo != null) {
//      File pluginJar = callerInfo.getPlugin().getJar();
//      if (database.isPackageBlacklisted(pkg)) {
//        throw new SecurityException(tl("security_manager_mal_packag", pluginJar, pkg));
//      }
      if (pkg.contains("optic_fusion1.mcantimalware") && !pkg.startsWith("optic_fusion1.mcantimalware.transformers")) {
        throw new FormattedSecurityException(tl("security_manager_access_antimalware_package"),
                callerInfo.getPlugin().getJar());
      }
    }
    log(RuntimeUtils.getCallerInfo(), "checkPackageAccess Pkg: " + pkg);
  }

  @Override
  public void checkPrintJobAccess() {
    log(RuntimeUtils.getCallerInfo(), "checkPrintJobAccess");
  }

  @Override
  public void checkPropertyAccess(String key) {
    log(RuntimeUtils.getCallerInfo(), "checkPropertyAccess Key: " + key);
  }

  @Override
  public void checkPropertiesAccess() {
    log(RuntimeUtils.getCallerInfo(), "checkPropertiesAccess");
  }

  @Override
  public void checkMulticast(InetAddress maddr, byte ttl) {
    log(RuntimeUtils.getCallerInfo(), "checkMulticast InetAddress: " + maddr.toString() + " ttl: " + ttl);
  }

  @Override
  public void checkMulticast(InetAddress maddr) {
    log(RuntimeUtils.getCallerInfo(), "checkMulticast InetAddress: " + maddr.toString());

  }

  @Override
  public void checkAccept(String host, int port) {
    log(RuntimeUtils.getCallerInfo(), "checkAccept Host: " + host + " Port:" + port);
  }

  @Override
  public void checkListen(int port) {
    log(RuntimeUtils.getCallerInfo(), "checkListen Port: " + port);
  }

  @Override
  public void checkConnect(String host, int port, Object context) {
    checkConnect0(host, port, context);
  }

  @Override
  public void checkConnect(String host, int port) {
    checkConnect0(host, port, null);
  }

  private void checkConnect0(String host, int port, Object context) {
    CallerInfo callerInfo = RuntimeUtils.getCallerInfo();
    if (callerInfo != null) {
      File pluginJar = callerInfo.getPlugin().getJar();
      if (cache.containsBlacklistedUrl(host)) {
        throw new SecurityException(tl("security_manager_mal_connection", pluginJar, host, port));
      }
    }
    log(RuntimeUtils.getCallerInfo(), "checkConnect Host: " + host + " Port: " + port + (context != null ? "Context: " + context : ""));
  }

  @Override
  public void checkDelete(String file) {
    CallerInfo callerInfo = RuntimeUtils.getCallerInfo();
    if (callerInfo != null) {
      File pluginJar = callerInfo.getPlugin().getJar();
      if (file.contains("MCAntiMalware.jar")) {
        throw new SecurityException(tl("security_manager_delete_antimalware_jar", pluginJar));
      }
      if (antiMalware.getCheckManager().isPluginJarBlacklisted(callerInfo.getPlugin().getJar())) {
        throw new FormattedSecurityException(tl("security_manager_delete_file", pluginJar, file));
      }
      if (file.contains("AntiMalware")) {
        throw new FormattedSecurityException(tl("security_manager_delete_antimalware_dir_file", pluginJar));
      }
    }
    log(RuntimeUtils.getCallerInfo(), "checkDelete File: " + file);
  }

  @Override
  public void checkWrite(String file) {
    CallerInfo callerInfo = RuntimeUtils.getCallerInfo();
    if (callerInfo != null) {
      File pluginJar = callerInfo.getPlugin().getJar();
      if (cache.containsBlacklistedWrite(file)) {
        throw new FormattedSecurityException(tl("security_manager_write_mal_file", pluginJar, file));
      }
      if (file.contains("AntiMalware")) {
        throw new FormattedSecurityException(tl("security_manager_write_antimalware_dir", pluginJar));
      }
      if (file.contains("MCAntiMalware.jar")) {
        throw new FormattedSecurityException(tl("security_manager_write_antimalware_jar", pluginJar));
      }
      if (antiMalware.getCommandLineParser().shouldRunServerJar() && file.contains(clp.getServerJar().toString())) {
        throw new FormattedSecurityException(tl("security_manager_write_server_ja"), pluginJar);
      }
      if (antiMalware.getCheckManager().isPluginJarBlacklisted(callerInfo.getPlugin().getJar())) {
        throw new FormattedSecurityException(tl("security_manager_write_file", pluginJar, file));
      }
      log(callerInfo, "checkWrite File:" + file);
    }
  }

  @Override
  public void checkWrite(FileDescriptor fd) {
    LOGGER.debug(fd.toString());
  }

  @Override
  public void checkRead(String file, Object context) {
    checkRead0(file, context);
  }

  @Override
  public void checkRead(String file) {
    checkRead0(file, null);
  }

  @Override
  public void checkRead(FileDescriptor fd) {
    LOGGER.debug(fd.toString());
  }

  private void checkRead0(String file, Object context) {
    CallerInfo callerInfo = RuntimeUtils.getCallerInfo();
    if (callerInfo != null) {
      if (file.contains("AntiMalware")) {
        throw new FormattedSecurityException(tl("security_manager_read_antimalware_dir",
                callerInfo.getPlugin().getJar()));
      }
    }
    log(RuntimeUtils.getCallerInfo(), "checkRead File: " + file + (context != null ? "Context: " + context : ""));
  }

  @Override
  public void checkLink(String lib) {
    log(RuntimeUtils.getCallerInfo(), "checkLink Lib: " + lib);
  }

  @Override
  public void checkExec(String cmd) {
    CallerInfo callerInfo = RuntimeUtils.getCallerInfo();
    if (callerInfo != null) {
      File pluginJar = callerInfo.getPlugin().getJar();
      if (cache.containsBlacklistedExec(cmd)) {
        throw new FormattedSecurityException(tl("security_manager_ran_exec", pluginJar, cmd));
      }
    }
    log(RuntimeUtils.getCallerInfo(), "checkExec: " + cmd);
  }

  @Override
  public void checkExit(int status) {
    log(RuntimeUtils.getCallerInfo(), "checkExit Status: " + status);
  }

  @Override
  public void checkAccess(ThreadGroup g) {
    log(RuntimeUtils.getCallerInfo(), "checkAccess ThreadGroup: " + g.toString());
  }

  @Override
  public void checkAccess(Thread t) {
    log(RuntimeUtils.getCallerInfo(), "checkAccess Thread: " + t.toString());
  }

  @Override
  public void checkCreateClassLoader() {
    log(RuntimeUtils.getCallerInfo(), "checkCreateClassLoader");
  }

  @Override
  public void checkPermission(Permission perm, Object context) {
    checkPermission0(perm, context);
  }

  @Override
  public void checkPermission(Permission perm) {
    checkPermission0(perm, null);
  }

  private void checkPermission0(Permission perm, Object context) {
    if (perm.getName().equals("setSecurityManager")) {
      CallerInfo callerInfo = RuntimeUtils.getCallerInfo();
      if (callerInfo != null) {
        File pluginJar = callerInfo.getPlugin().getJar();
        throw new FormattedSecurityException(tl("security_manager_tried_setting_security_manager", pluginJar));
      }
    }
    log(RuntimeUtils.getCallerInfo(), "checkPermission Perm: " + perm + (context != null ? " Context: " + context : ""));
  }

  private void log(CallerInfo callerInfo, String string) {
    if (clp.shouldLogSecurityManager()) {
      if (callerInfo != null) {
        LOGGER.debug("[AntiMalwareSecurityManager] " + callerInfo + " " + string);
      } else {
        LOGGER.debug("[AntiMalwareSecurityManager] " + string);
      }
    }
  }

}
