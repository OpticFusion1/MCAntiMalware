/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.servers.handler;

import net.bytebuddy.dynamic.ClassFileLocator;
import optic_fusion1.antimalware.AntiMalware;
import optic_fusion1.antimalware.CommandLineParser;
import optic_fusion1.antimalware.scanner.Scanner;
import optic_fusion1.antimalware.servers.handler.paper.PaperServerHandler;
import optic_fusion1.antimalware.servers.handler.spigot.SpigotServerHandler;
import optic_fusion1.antimalware.servers.runtimeprotect.AMSecurityManager;
import optic_fusion1.antimalware.servers.runtimeprotect.PluginIndex;
import optic_fusion1.antimalware.servers.transformers.Transformers;
import optic_fusion1.antimalware.utils.I18n;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.ArrayList;
import java.util.List;

import static optic_fusion1.antimalware.AntiMalware.LOGGER;

public abstract class ServerHandler {

  private static final List<ServerHandler> HANDLERS = new ArrayList<>();

  static {
    HANDLERS.add(new PaperServerHandler());
    HANDLERS.add(new SpigotServerHandler());
  }

  private AntiMalware antiMalware;
  private CommandLineParser clp;
  private Scanner scanner;
  private boolean canUseSpigotMethods;
  private PluginIndex pluginIndex;

  public static ServerHandler getServerHandler(AntiMalware antiMalware) {
    for (ServerHandler handler : HANDLERS) {
      handler.setAntiMalware(antiMalware);
      if (handler.checkServerType(antiMalware.getCommandLineParser().getServerJar())) {
        return handler;
      }
    }
    return null;
  }

  public abstract String getServerTypeName();

  protected abstract boolean checkServerType(File serverFile);

  protected abstract boolean prepareServer();

  protected abstract void startServer();

  protected String[] getServerArguments() {
    return clp.getServerArguments();
  }

  protected File getServerFile() {
    return clp.getServerJar();
  }

  protected ClassLoader createClassLoader(URL... urls) {
    return new URLClassLoader(urls, ClassLoader.getSystemClassLoader());
  }

  protected void applyTransformers(ClassLoader classLoader, File jarFile, String version) {
    LOGGER.info(I18n.tl("security_manager_transformers_load_start"));
    try {
      Transformers.applyTransformers(classLoader, ClassFileLocator.ForJarFile.of(jarFile), version);
    } catch (IOException e) {
      LOGGER.exception(e);
      System.exit(1);
      return;
    }
    LOGGER.info(I18n.tl("security_manager_transformers_load_end"));
  }

  protected Thread createChildProcess(ClassLoader classLoader, String className, String methodName,
          Class<?>[] argumentTypes, Object[] args) {
    Thread serverThread = new Thread(() -> {
      try {
        Thread.currentThread().setContextClassLoader(classLoader);
        LOGGER.info(I18n.tl("security_manager_setup_start"));
        classLoader.loadClass(className).getMethod(methodName, argumentTypes).invoke(null, args);
      } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException
              | SecurityException | ClassNotFoundException e) {
        try {
          classLoader.loadClass("org.bukkit.craftbukkit.bootstrap.Main").getMethod(methodName, argumentTypes).invoke(null, args);
        } catch (NoSuchMethodException | SecurityException | ClassNotFoundException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
          LOGGER.exception(ex);
        }
      }
    });
    serverThread.start();
    return serverThread;
  }

  protected boolean setSecurityManager(SecurityManager sm) {
    LOGGER.info(I18n.tl("security_manager_setup_start"));
    try {
      System.setSecurityManager(sm);
    } catch (SecurityException se) {
      LOGGER.exception(se);
      return false;
    }
    LOGGER.info(I18n.tl("security_manager_setup_end"));
    return true;
  }

  public void handleServer() {
    if (clp.shouldRunServerJar()) {
      File serverJar = clp.getServerJar();
      scanner.addFileToQueue(serverJar.toPath());
      if (!prepareServer()) {
        LOGGER.info(I18n.tl("security_manager_server_setup_error"));
        System.exit(0);
      }
      if (clp.shouldRunSecurityManager()) {
        if (!setSecurityManager(new AMSecurityManager(antiMalware))) {
          LOGGER.info(I18n.tl("security_manager__setup_error"));
          System.exit(0);
        }
      }
      startServer();
    }
  }

  public void setAntiMalware(AntiMalware antiMalware) {
    clp = antiMalware.getCommandLineParser();
    scanner = antiMalware.getScanner();
    this.antiMalware = antiMalware;
  }

  public PluginIndex getPluginIndex() {
    return pluginIndex;
  }

  public boolean canUseSpigotMethods() {
    return canUseSpigotMethods;
  }

  public void setCanUseSpigotMethods(boolean canUseSpigotMethods) {
    this.canUseSpigotMethods = canUseSpigotMethods;
  }

  public CommandLineParser getCommandLineParser() {
    return clp;
  }

}
