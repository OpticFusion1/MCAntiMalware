package optic_fusion1.antimalware.scanner.file;

import optic_fusion1.antimalware.AntiMalware;
import optic_fusion1.antimalware.CommandLineParser;
import optic_fusion1.antimalware.check.CacheContainer;
import optic_fusion1.antimalware.check.CheckManager;
import optic_fusion1.antimalware.check.CheckResult;
import optic_fusion1.antimalware.database.Database;
import optic_fusion1.antimalware.scanner.ScanHelper;
import optic_fusion1.antimalware.scanner.Scanner;
import org.apache.commons.codec.digest.DigestUtils;

import java.io.File;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.io.File;
import java.nio.file.Path;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;
import java.util.zip.ZipFile;

import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import optic_fusion1.antimalware.check.BaseCheck;
import static optic_fusion1.antimalware.utils.I18n.tl;
import static optic_fusion1.antimalware.utils.Utils.fileSystemForZip;
import static optic_fusion1.antimalware.utils.Utils.validClassPath;
import org.objectweb.asm.tree.ClassNode;

/**
 * @author IkeVoodoo
 *
 */
public class FileScanner {

    private static final Path ANTI_MALWARE_PATH;

    static {
        try {
            ANTI_MALWARE_PATH = new File(AntiMalware.class.getProtectionDomain().getCodeSource().getLocation().toURI()).toPath();
        } catch (URISyntaxException e) {
            throw new IllegalStateException(e);
        }
    }

    private static final String SPIGOT_PLATFORM = "Spigot";

    private final CacheContainer cache;
    private final Database database;
    private final CommandLineParser commandLineParser;
    private final CheckManager checkManager;
    private final BiConsumer<Path, CheckResult> notifications;
    private List<Path> alreadyScanned = new ArrayList<>();

    public FileScanner(CacheContainer cache, Database database, CommandLineParser commandLineParser, CheckManager checkManager, BiConsumer<Path, CheckResult> notifications) {
        this.cache = cache;
        this.database = database;
        this.commandLineParser = commandLineParser;
        this.checkManager = checkManager;
        this.notifications = notifications;
    }

    public void scanFile(Path file) {
        if (alreadyScanned.contains(file)) {
            return;
        }
        alreadyScanned.add(file);
        // Not needed because this method shouldn't be called with a directory like tf it's FileScanner.scanFile like bruh
//        if (Files.isDirectory(file)) {
//            scanDirectory(file);
//            return;
//        }
        if (ScanHelper.isFileEmpty(file)) {
            return;
        }

        String fileName = file.getFileName().toString();

        checkBlacklistedFileName(file, fileName);
        checkBlacklistedFilePath(file);

        if (fileName.equals("VaultLib.jar")) {
            submitNotification(file.toAbsolutePath(), new CheckResult(SPIGOT_PLATFORM, "MALWARE", "Qlutch", "C"));
        }

        if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar") && !isPlugin(file)) {
            return;
        }

        checkFileHash(file);

        try (FileSystem fs = fileSystemForZip(file)) {
            if (fs == null) {
                return;
            }

            Path rootFolder = fs.getRootDirectories().iterator().next();
            if (commandLineParser.shouldScanZippedFiles() && (fileName.endsWith(".zip") || fileName.endsWith(".rar"))) {
                scanZip(file);
                return;
            }

            Scanner.WhitelistResult result = isFileWhitelisted(file);
            if (result == Scanner.WhitelistResult.INVALID_FILE || result == Scanner.WhitelistResult.WHITELISTED) {
                return;
            }

            //region KillMe
            // TODO: Make this a separate check
            if (Files.exists(rootFolder.resolve("dev/jnic/lib/"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "JNIC"));
//                return;
            }

            // TODO: Make these a separate check
            if (Files.exists(rootFolder.resolve("plugin-config.bin"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/org/apache/commons/local-info.hdm"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "B"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/io/netty/netty-locals.netd"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "C"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org/apache/logging/log4j/Log4j-events.dtd"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "D"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/org/apache/logging/log4j/Log4j-events.dtd"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "E"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/org.json/json/json.xsd"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "F"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org/apache/commons/api-catch.dir"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "G"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org/apache/commons/local-dir.hum"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "H"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org/apache/commons/local-info.hdm"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "I"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/com/google/code/gson/gson/maven.data"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "J"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/com.google.code.gson/gson/maven.data"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "K"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org.json/json/gson.xsd"))) {
                submitNotification(file, new CheckResult(SPIGOT_PLATFORM, "Malware", "SG", "L"));
//                return;
            }
            //endregion

            AtomicBoolean possiblyMalicious = new AtomicBoolean(false);

            // Walks through every file within the .jar, .zip, or .rar file
            walkThroughFiles(rootFolder, zipEntryPath -> {
                // Checks if the zipEntryPath is a valid .class file
                if (!validClassPath(zipEntryPath)) {
                    return;
                }

                // Gets an instance of the .class. Returns null if not possible
                ClassNode classNode = cache.fetchClass(file, zipEntryPath);
                if (classNode == null) {
                    return;
                }

                // Loops through every Anti-Malware check
                for (BaseCheck check : checkManager.getChecks()) {
                    // Processes the classNode, rootFolder, and the file itself
                    List<CheckResult> results = check.process(classNode, rootFolder, file, cache);
                    if (results == null || results.isEmpty()) {
                        continue;
                    }

                    // Used to determine if the "probably_safe" notification should be used
                    possiblyMalicious.set(true);

                    // Loops through the Check results and sends a notification
                    for (CheckResult checkResult : results) {
                        if (commandLineParser.dontLogINFOCR() && checkResult.getType().equals("INFO")) {
                            continue;
                        }
                        submitNotification(file, checkResult);
                    }
                    // Resets the check to its default state
                    check.reset();
                }
            });

            cache.clearCache(file); // Attempt at fixing memory issues
            if (commandLineParser.shouldPrintNotInfectedMessages() && !possiblyMalicious.get()) {
                LOGGER.info(tl("scanner_probably_safe", file));
            }
        } catch (IOException ex) {
            LOGGER.exception(ex);
        }
    }

    private void checkBlacklistedFileName(Path file, String fileName) {
        if (!cache.containsBlacklistedFileName(fileName)) {
            return;
        }

        try {
            CheckResult result = database.getCheckResultForFileName(fileName);
            submitNotification(file.toAbsolutePath(), result);
        } catch (SQLException ex) {
            LOGGER.exception(ex);
        }
    }

    private void checkBlacklistedFilePath(Path file) {
        if (!cache.containsBlacklistedFilePath(file.toString())) {
            return;
        }

        try {
            CheckResult result = database.getCheckResultForFilePath(file.toString());
            submitNotification(file.toAbsolutePath(), result);
        } catch (SQLException ex) {
            LOGGER.exception(ex);
        }
    }

    private void checkFileHash(Path file) {
        String checksum = cache.fetchSHA1(file, file);

        if (checksum == null) {
            LOGGER.warn("The SHA-1 checksum for '" + file + "' couldn't be loaded");
            return;
        }

        checksum = checksum.toUpperCase();
        if (!cache.containsBlacklistedChecksum(checksum)) {
            return;
        }

        try {
            CheckResult checkResult = database.getCheckResultForChecksum(checksum);
            if (checkResult == null) {
                LOGGER.info(tl("scanner_blacklisted_not_in_database", file)); // Sysout replaced with logger
                return;
            }

            if (commandLineParser.dontLogINFOCR() && checkResult.getType().equals("INFO")) {
                return;
            }

            submitNotification(file, checkResult);
        } catch (SQLException ex) {
            LOGGER.exception(ex);
        }
    }

    private void submitNotification(Path path, CheckResult result) {
        if (result == null) {
            return;
        }

        notifications.accept(path, result);
    }

    private boolean isPlugin(Path file) {
        try (ZipFile zipFile = new ZipFile(file.toFile())) {
            return zipFile.getEntry("plugin.yml") != null;
        } catch (IOException ex) {
            return false;
        }
    }

    private Scanner.WhitelistResult isFileWhitelisted(Path file) {
        if (file == null || ScanHelper.isFileEmpty(file)) {
            return Scanner.WhitelistResult.INVALID_FILE;
        }

        try {
            if (Files.isSameFile(file, ANTI_MALWARE_PATH)) {
                return Scanner.WhitelistResult.WHITELISTED;
            }

            String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file));
            Scanner.WhitelistResult result = isChecksumWhitelisted(fileChecksum);

            if (result == Scanner.WhitelistResult.WHITELISTED && commandLineParser.shouldPrintNotInfectedMessages()) {
                LOGGER.info(tl("scanner_probably_safe_whitelisted", file.getFileName().toString()));
            }

            return result;
        } catch (IOException e) {
            LOGGER.exception(e);
        }

        return Scanner.WhitelistResult.NOT_WHITELISTED;
    }

    protected void walkThroughFiles(Path dir, Consumer<Path> pathConsumer) {
        if (".".equals(String.valueOf(dir.getFileName()))) { // if (dir.getFileName() != null && dir.getFileName().toString().equals(".")) {
            return;
        }

        if (Files.isDirectory(dir, LinkOption.NOFOLLOW_LINKS)) {
            walkTroughDirectory(dir, pathConsumer);
            return;
        }

        if (Files.isSymbolicLink(dir)) {
            return;
        }

        pathConsumer.accept(dir);
    }

    private void walkTroughDirectory(Path dir, Consumer<Path> pathConsumer) {
        LinkedList<Path> stack = new LinkedList<Path>();
        stack.add(dir);

        while (!stack.isEmpty()) {
            Path current = stack.pollLast();

            try (Stream<Path> list = Files.list(current).filter(path -> !Files.isSymbolicLink(path))) {
                Iterator<Path> iterator = list.iterator();

                while (iterator.hasNext()) {
                    Path next = iterator.next();
                    pathConsumer.accept(next);

                    if (Files.isDirectory(next, LinkOption.NOFOLLOW_LINKS)) {
                        stack.addLast(next);
                    }
                }
            } catch (IOException e) {
                LOGGER.exception(e);
            }
        }
    }

    private void scanZip(Path zippedFile) {
        LOGGER.info("Scanning zip file " + zippedFile);

        try (Stream<Path> walk = Files.walk(zippedFile)) {
            walk.forEach(found -> {
                if (Files.isDirectory(found)) {
                    // Scan dir
                    scanDirectory(found);
                    return;
                }

                // Scan file
                scanFile(found);
            });
        } catch (IOException ex) {
            Logger.getLogger(Scanner.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void scanDirectory(Path directory) {
        try (Stream<Path> list = Files.list(directory)) {
            list.forEach((path) -> {
                if (!path.getFileSystem().isOpen()) {
                    return;
                }

                if (Files.isDirectory(path)) {
                    scanDirectory(path);
                    return;
                }

                scanFile(path);
            });
        } catch (IOException e) {
            LOGGER.exception(e);
        }
    }

    private Scanner.WhitelistResult isChecksumWhitelisted(String checksum) {
        return cache.containsWhitelistedChecksum(checksum) ? Scanner.WhitelistResult.WHITELISTED : Scanner.WhitelistResult.NOT_WHITELISTED;
    }

}
