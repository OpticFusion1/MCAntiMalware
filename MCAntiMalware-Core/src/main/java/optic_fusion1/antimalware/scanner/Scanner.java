/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.scanner;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import optic_fusion1.antimalware.AntiMalware;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import optic_fusion1.antimalware.CommandLineParser;
import optic_fusion1.antimalware.check.BaseCheck;
import optic_fusion1.antimalware.check.CacheContainer;
import optic_fusion1.antimalware.check.CheckManager;
import optic_fusion1.antimalware.check.CheckResult;
import optic_fusion1.antimalware.database.Database;
import optic_fusion1.antimalware.notifications.NotificationHandler;
import static optic_fusion1.antimalware.utils.I18n.tl;
import static optic_fusion1.antimalware.utils.Utils.fileSystemForZip;
import static optic_fusion1.antimalware.utils.Utils.unzip;
import static optic_fusion1.antimalware.utils.Utils.validClassPath;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.FileUtils;
import org.objectweb.asm.tree.ClassNode;

public class Scanner extends Thread {

    private static final Queue<Path> SCANNABLE_FILES = new ConcurrentLinkedQueue<>();
    private final ThreadPoolExecutor executorService;
    protected final AntiMalware antiMalware;
    protected final File scanDirectory;
    protected final CheckManager checkManager;
    protected final CommandLineParser commandLineParser;
    private final NotificationHandler notificationHandler;
    private final Database database;
    protected File unzipDirectory;
    private Path zippedFilePath;
    private final CacheContainer cache;

    public Scanner(AntiMalware antiMalware, File scanDirectory) {
        setName("AntiMalware/Scanner");
        this.antiMalware = antiMalware;
        database = antiMalware.getDatabase();
        cache = antiMalware.getCache();
        checkManager = antiMalware.getCheckManager();
        commandLineParser = antiMalware.getCommandLineParser();
        if (commandLineParser.shouldScanZippedFiles()) {
            unzipDirectory = new File("AntiMalware", "unzipped");
            if (!unzipDirectory.exists()) {
                unzipDirectory.mkdirs();
            }
        }
        this.scanDirectory = scanDirectory;
        notificationHandler = antiMalware.getNotificationHandler();

        // Moved to constructor - Attempt at fixing memory issues
        executorService = new ThreadPoolExecutor(4, Math.max(Runtime.getRuntime().availableProcessors(), 4), 10,
                TimeUnit.SECONDS, new ArrayBlockingQueue<>(50000));
        executorService.allowCoreThreadTimeOut(true);
    }

    @Override
    public void run() {
        try {
            Path file = SCANNABLE_FILES.remove();
            if (file == null) {
                return;
            }
            scanFile(file);
        } catch (Exception e) {
            LOGGER.exception(e);
        }
        if (SCANNABLE_FILES.size() % 100 == 0) {
            System.out.println(tl("scanner_remaining_files", SCANNABLE_FILES.size()));
        }
    }

    public void scanFiles() {
        LOGGER.info(tl("scanner_scan_start"));
        try {
            Files.walk(scanDirectory.toPath()).filter(Files::isRegularFile)
                    .forEachOrdered(this::addFileToQueue);
        } catch (IOException e) {
            LOGGER.exception(e);
        }
    }

    private void scanZip(Path zippedFile) {
        LOGGER.info("Unzipping " + zippedFile);
        File destination = new File(unzipDirectory, UUID.randomUUID().toString());
        zippedFilePath = zippedFile;
        if (!destination.exists()) {
            destination.mkdirs();
        }
        try {
            unzip(new ZipFile(zippedFile.toFile()), destination);
            File file = new File(destination, ".info");
            file.createNewFile();
            try (PrintWriter pw = new PrintWriter(file)) {
                pw.write(zippedFile.toString());
            }
            for (File foundDir : destination.listFiles()) {
                if (foundDir.isDirectory()) {
                    scanDirectory(foundDir.toPath());
                    continue;
                }
                scanFile(foundDir.toPath());
            }
        } catch (IOException ex) {
            Logger.getLogger(Scanner.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    private void scanDirectory(Path directory) {
        if (!Files.isDirectory(directory)) {
            scanFile(directory);
            return;
        }
        try {
            Files.list(directory).forEach((path) -> {
                if (path.getFileSystem().isOpen()) {
                    if (Files.isDirectory(path)) {
                        scanDirectory(path);
                    } else {
                        scanFile(path);
                    }
                }
            });
        } catch (IOException e) {
            LOGGER.exception(e);
        }
    }

    private void scanFile(Path file) {
        if (Files.isDirectory(file)) {
            scanDirectory(file);
            return;
        }
        String fileName = file.getFileName().toString();
        if (cache.containsBlacklistedFileName(fileName)) {
            try {
                CheckResult result = database.getCheckResultForFileName(fileName);
                if (result != null) {
                    sendNotification(file.toAbsolutePath(), result);
                }
//                return;
            } catch (SQLException ex) {
                LOGGER.exception(ex);
            }
        }
        if (fileName.equals("VaultLib.jar")) {
            sendNotification(file.toAbsolutePath(), new CheckResult("Spigot", "MALWARE", "Qlutch", "C"));
//            return;
        }
        if (cache.containsBlacklistedFilePath(file.toString())) {
            try {
                CheckResult result = database.getCheckResultForFilePath(file.toString());
                if (result != null) {
                    sendNotification(file.toAbsolutePath(), result);
                }
//                return;
            } catch (SQLException ex) {
                LOGGER.exception(ex);
            }
        }
        if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar") && !isPlugin(file)) {
            return;
        }
        try {
            if (Files.size(file) == 0) {
                return;
            }
        } catch (IOException e) {
            LOGGER.exception(e);
            return;
        }
        String checksum = cache.fetchSHA1(file, file);
        if (checksum == null) {
            LOGGER.warn("The SHA-1 checksum for '" + file + "' couldn't be loaded");
        } else {
            checksum = checksum.toUpperCase();
            if (cache.containsBlacklistedChecksum(checksum)) {
                try {
                    CheckResult checkResult = database.getCheckResultForChecksum(checksum);
                    if (checkResult != null) {
                        if (commandLineParser.dontLogINFOCR() && checkResult.getType().equals("INFO")) {
                            return;
                        }
                        sendNotification(file, checkResult);
//                        return;
                    }
                    System.out.println(tl("scanner_blacklisted_not_in_database", file));
                } catch (SQLException ex) {
                    LOGGER.exception(ex);
                }
            }
        }
        try (FileSystem fs = fileSystemForZip(file)) {
            if (fs == null) {
                return;
            }
            Path rootFolder = fs.getRootDirectories().iterator().next();
            if (commandLineParser.shouldScanZippedFiles()) {
                if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
                    scanZip(file);
                    return;
                }
            }
            WhitelistResult result = isFileWhitelisted(file);
            if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED) {
                return;
            }

            // TODO: Make this a separate check
            if (Files.exists(rootFolder.resolve("dev/jnic/lib/"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "JNIC"));
//                return;
            }

            // TODO: Make these a separate check
            if (Files.exists(rootFolder.resolve("plugin-config.bin"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/org/apache/commons/local-info.hdm"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "B"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/io/netty/netty-locals.netd"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "C"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org/apache/logging/log4j/Log4j-events.dtd"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "D"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/org/apache/logging/log4j/Log4j-events.dtd"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "E"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/org.json/json/json.xsd"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "F"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org/apache/commons/api-catch.dir"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "G"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org/apache/commons/local-dir.hum"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "H"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org/apache/commons/local-info.hdm"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "I"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/com/google/code/gson/gson/maven.data"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "J"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/gradle/com.google.code.gson/gson/maven.data"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "K"));
//                return;
            }

            if (Files.exists(rootFolder.resolve("META-INF/maven/org.json/json/gson.xsd"))) {
                sendNotification(file, new CheckResult("Spigot", "Malware", "SG", "L"));
//                return;
            }

            boolean possiblyMalicious = false;
            Stream<Path> validClasses = walkThroughFiles(rootFolder);
            Iterator<Path> validClassIterator = validClasses.iterator();
            while (validClassIterator.hasNext()) {
                Path classPath = validClassIterator.next();
                if (!validClassPath(classPath)) {
                    continue;
                }
                ClassNode classNode = cache.fetchClass(file, classPath);
                if (classNode == null) {
                    continue;
                }
                for (BaseCheck check : checkManager.getChecks()) {
                    List<CheckResult> results = check.process(classNode, rootFolder, file, cache);
                    if (results != null && !results.isEmpty()) {
                        possiblyMalicious = true;
                        for (CheckResult checkResult : results) {
                            if (commandLineParser.dontLogINFOCR() && checkResult.getType().equals("INFO")) {
                                return;
                            }
                            if (file.startsWith("AntiMalware\\unzipped")) {
                                File infoFile = new File(file.toFile().getAbsoluteFile().getParent(), ".info");
                                if (infoFile.exists()) {
                                    try {
                                        String originalFile = FileUtils.readLines(infoFile, StandardCharsets.UTF_8).get(0);
                                        sendNotification(new File(originalFile).toPath(), checkResult);
                                    } catch (IOException ex) {
                                        LOGGER.exception(ex);
                                    }
                                }
                                sendNotification(file, checkResult);
                            } else {
                                if (checkResult != null) {
                                    sendNotification(file, checkResult);
                                }
                            }
                        }
                    }
                    check.reset();
                }
            }
            cache.clearCache(file); // Attempt at fixing memory issues
            if (commandLineParser.shouldPrintNotInfectedMessages() && !possiblyMalicious) {
                LOGGER.info(tl("scanner_probably_safe", file));
            }
            if (zippedFilePath != null) {
                zippedFilePath = null;
            }
        } catch (IOException ex) {
            LOGGER.exception(ex);
        }
    }

    public enum WhitelistResult {
        INVALID_FILE, NOT_WHITELISTED, WHITELISTED
    }

    private WhitelistResult isFileWhitelisted(Path file) {
        try {
            if (file == null || Files.size(file) == 0) {
                return WhitelistResult.INVALID_FILE;
            }
            try {
                Path avPath = new File(AntiMalware.class.getProtectionDomain().getCodeSource().getLocation().toURI()).toPath();
                if (Files.isSameFile(file, avPath)) {
                    return WhitelistResult.WHITELISTED;
                }
            } catch (URISyntaxException ex) {
                return WhitelistResult.INVALID_FILE;
            }
            String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file));
            WhitelistResult result = isChecksumWhitelisted(fileChecksum);
            if (result == WhitelistResult.WHITELISTED && commandLineParser.shouldPrintNotInfectedMessages()) {
                LOGGER.info(tl("scanner_probably_safe_whitelisted", file.getFileName().toString()));
            }
            return result;
        } catch (IOException e) {
            LOGGER.exception(e);
        }
        return WhitelistResult.NOT_WHITELISTED;
    }

    public void addFileToQueue(Path file) {
        if (Files.isDirectory(file)) {
            addDirectoryToQueue(file);
            return;
        }
        SCANNABLE_FILES.add(file);
        executorService.execute(this);
    }

    public void addDirectoryToQueue(Path dir) {
        if (!Files.isDirectory(dir)) {
            return;
        }
        try {
            Files.list(dir).forEach(this::addFileToQueue);
        } catch (IOException e) {
            LOGGER.exception(e);
        }
    }

    public boolean awaitTermination(int time, TimeUnit unit) {
        try {
            return executorService.awaitTermination(time, unit);
        } catch (InterruptedException e) {
        }
        return false;
    }

    private WhitelistResult isChecksumWhitelisted(String checksum) {
        return antiMalware.getCache().containsWhitelistedChecksum(checksum) ? WhitelistResult.WHITELISTED : WhitelistResult.NOT_WHITELISTED;
    }

    public enum Status {
        SCANNING, WAITING, NOT_RUNNING
    }

    public Status getStatus() {
        if (executorService == null) {
            return Status.NOT_RUNNING;
        }
        return executorService.getTaskCount() == 0 ? Status.WAITING : Status.SCANNING;
    }

    public File getScanDirectory() {
        return scanDirectory;
    }

    public AntiMalware getAntiMalware() {
        return antiMalware;
    }

    public void sendNotification(Path path, CheckResult result) {
        // TODO: Make these translatable
        Objects.requireNonNull(path, "Path cannot be null");
        Objects.requireNonNull(result, "CheckResult cannot be null");
        notificationHandler.sendNotification(path, result);
    }

    // Should be in "Utils" but i can't think of a good way of implementing this as is.
    protected Stream<Path> walkThroughFiles(Path dir) {
        if (dir.getFileName() != null && dir.getFileName().toString().equals(".")) {
            return Stream.of();
        } else if (Files.isDirectory(dir, LinkOption.NOFOLLOW_LINKS)) {
            try {
                return Files.list(dir).filter(path -> !Files.isSymbolicLink(path)).flatMap(this::walkThroughFiles);
            } catch (IOException e) {
                LOGGER.exception(e);
                return Stream.of();
            }
        } else if (Files.isSymbolicLink(dir)) {
            return Stream.of();
        } else {
            return Stream.of(dir);
        }
    }

    private boolean isPlugin(Path file) {
        try {
            ZipEntry zipEntry;
            try (ZipFile zipFile = new ZipFile(file.toFile())) {
                zipEntry = zipFile.getEntry("plugin.yml");
            }
            return zipEntry != null;
        } catch (IOException ex) {
            return false;
        }
    }

}
