/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.scanner;

import optic_fusion1.antimalware.AntiMalware;
import optic_fusion1.antimalware.CommandLineParser;
import optic_fusion1.antimalware.check.BaseCheck;
import optic_fusion1.antimalware.check.CacheContainer;
import optic_fusion1.antimalware.check.CheckManager;
import optic_fusion1.antimalware.check.CheckResult;
import optic_fusion1.antimalware.database.Database;
import optic_fusion1.antimalware.notifications.NotificationHandler;
import optic_fusion1.antimalware.scanner.file.FileScanner;
import org.apache.commons.io.FileUtils;
import org.objectweb.asm.tree.ClassNode;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import static optic_fusion1.antimalware.utils.I18n.tl;
import static optic_fusion1.antimalware.utils.Utils.fileSystemForZip;
import static optic_fusion1.antimalware.utils.Utils.unzip;
import static optic_fusion1.antimalware.utils.Utils.validClassPath;

public class Scanner extends Thread {

    private static final Queue<Path> SCANNABLE_FILES = new ConcurrentLinkedQueue<>();
    private final ThreadPoolExecutor executorService;
    protected final AntiMalware antiMalware;
    protected final File scanDirectory;
    protected final CheckManager checkManager;
    protected final CommandLineParser commandLineParser;
    private final NotificationHandler notificationHandler;
    protected File unzipDirectory;
    private final FileScanner fileScanner;

    public Scanner(AntiMalware antiMalware, File scanDirectory) {
        setName("AntiMalware/Scanner");
        this.antiMalware = antiMalware;

        checkManager = antiMalware.getCheckManager();
        commandLineParser = antiMalware.getCommandLineParser();

        this.fileScanner = new FileScanner(
                antiMalware.getCache(),
                antiMalware.getDatabase(),
                this.commandLineParser,
                this.checkManager,
                this::sendNotification
        );

        if (commandLineParser.shouldScanZippedFiles()) {
            unzipDirectory = new File("AntiMalware", "unzipped");
            if (!unzipDirectory.exists()) {
                unzipDirectory.mkdirs();
            }
        }
        this.scanDirectory = scanDirectory;
        notificationHandler = antiMalware.getNotificationHandler();

        // Moved to constructor - Attempt at fixing memory issues
        executorService = new ThreadPoolExecutor(4, Math.max(Runtime.getRuntime().availableProcessors(), 4), 10,
                TimeUnit.SECONDS, new ArrayBlockingQueue<>(50000));
        executorService.allowCoreThreadTimeOut(true);
    }

    @Override
    public void run() {
        try {
            Path file = SCANNABLE_FILES.remove();
            if (file == null) {
                return;
            }

            this.fileScanner.scanFile(file);
        } catch (Exception e) {
            LOGGER.exception(e);
        }
        if (SCANNABLE_FILES.size() % 100 == 0) {
            System.out.println(tl("scanner_remaining_files", SCANNABLE_FILES.size()));
        }
    }

    public void scanFiles() {
        LOGGER.info(tl("scanner_scan_start"));
        try {
            Files.walk(scanDirectory.toPath()).filter(Files::isRegularFile)
                    .forEachOrdered(this::addFileToQueue);
        } catch (IOException e) {
            LOGGER.exception(e);
        }
    }

    public enum WhitelistResult {
        INVALID_FILE, NOT_WHITELISTED, WHITELISTED
    }

    public void addFileToQueue(Path file) {
        if (Files.isDirectory(file)) {
            addDirectoryToQueue(file);
            return;
        }
        SCANNABLE_FILES.add(file);
        executorService.execute(this);
    }

    public void addDirectoryToQueue(Path dir) {
        if (!Files.isDirectory(dir)) {
            return;
        }
        try {
            Files.list(dir).forEach(this::addFileToQueue);
        } catch (IOException e) {
            LOGGER.exception(e);
        }
    }

    public boolean awaitTermination(int time, TimeUnit unit) {
        try {
            return executorService.awaitTermination(time, unit);
        } catch (InterruptedException e) {
        }
        return false;
    }

    public enum Status {
        SCANNING, WAITING, NOT_RUNNING
    }

    public Status getStatus() {
        if (executorService == null) {
            return Status.NOT_RUNNING;
        }
        return executorService.getTaskCount() == 0 ? Status.WAITING : Status.SCANNING;
    }

    public File getScanDirectory() {
        return scanDirectory;
    }

    public AntiMalware getAntiMalware() {
        return antiMalware;
    }

    public void sendNotification(Path path, CheckResult result) {
        // TODO: Make these translatable
        Objects.requireNonNull(path, "Path cannot be null");
        Objects.requireNonNull(result, "CheckResult cannot be null");
        notificationHandler.sendNotification(path, result);
    }


}
