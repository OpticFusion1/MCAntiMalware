/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.scanner.realtime;

import optic_fusion1.antimalware.AntiMalware;
import optic_fusion1.antimalware.utils.I18n;
import optic_fusion1.antimalware.utils.Service;

import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardWatchEventKinds;
import java.nio.file.WatchEvent;
import java.nio.file.WatchKey;
import java.nio.file.WatchService;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import static java.nio.file.StandardWatchEventKinds.ENTRY_CREATE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_DELETE;
import static java.nio.file.StandardWatchEventKinds.ENTRY_MODIFY;
import static java.nio.file.StandardWatchEventKinds.OVERFLOW;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;

//TODO: Correct class messages
public class DirectoryWatcher implements Runnable, Service {

    public enum Event {
        ENTRY_CREATE,
        ENTRY_MODIFY,
        ENTRY_DELETE
    }

    private static final Map<WatchEvent.Kind<Path>, Event> EVENT_MAP = Map.of(StandardWatchEventKinds.ENTRY_CREATE, Event.ENTRY_CREATE,
                                                                              StandardWatchEventKinds.ENTRY_MODIFY, Event.ENTRY_MODIFY,
                                                                              StandardWatchEventKinds.ENTRY_DELETE, Event.ENTRY_DELETE);

    private ExecutorService mExecutor;
    private Future<?> mWatcherTask;
    private final Set<Path> mWatched;
    private final boolean mPreExistingAsCreated;
    private final Listener mListener;
    private final Filter<Path> mFilter;

    public DirectoryWatcher(AntiMalware antiMalware, Builder builder) {
        mWatched = builder.mWatched;
        mPreExistingAsCreated = builder.mPreExistingAsCreated;
        mListener = builder.mListener;
        mFilter = builder.mFilter;
    }

    @SuppressWarnings("unchecked")
    private static <T> WatchEvent<T> cast(WatchEvent<?> event) {
        return (WatchEvent<T>) event;
    }

    @Override
    public void startService() throws Exception {
        mExecutor = Executors.newSingleThreadExecutor();
        mWatcherTask = mExecutor.submit(this);
    }

    @Override
    public void stopService() {
        mWatcherTask.cancel(true);
        mWatcherTask = null;
        mExecutor.shutdown();
        mExecutor = null;
    }

    @Override
    public void run() {
        try(final WatchService watchService = FileSystems.getDefault().newWatchService())
        {
            Map<WatchKey, Path> watchKeyToDirectory = new HashMap<>();
            mWatched.forEach((dir) -> {
                try {
                    if (mPreExistingAsCreated) {
                        try ( DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
                            for (Path path : stream) {
                                if (mFilter.accept(path)) {
                                    mListener.onEvent(Event.ENTRY_CREATE, path);
                                }
                            }
                        }
                    }

                    WatchKey key = dir.register(watchService, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);
                    watchKeyToDirectory.put(key, dir);
                } catch (IOException ioe) {
                    LOGGER.error(I18n.tl("not_watching", dir), ioe);
                }
            });

            while (true) {
                if (Thread.interrupted()) {
                    LOGGER.info(I18n.tl("interrupted_thread"));
                    break;
                }

                WatchKey key;
                try {
                    key = watchService.take();
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    continue;
                }

                Path dir = watchKeyToDirectory.get(key);
                if (dir == null) {
                    LOGGER.warn(I18n.tl("not_recognized"));
                    continue;
                }

                for (WatchEvent<?> event : key.pollEvents()) {
                    if (event.kind().equals(OVERFLOW)) {
                        break;
                    }

                    WatchEvent<Path> pathEvent = cast(event);
                    WatchEvent.Kind<Path> kind = pathEvent.kind();
                    Path path = dir.resolve(pathEvent.context());
                    if (mFilter.accept(path) && EVENT_MAP.containsKey(kind)) {
                        mListener.onEvent(EVENT_MAP.get(kind), path);
                    }
                }

                boolean valid = key.reset();
                if (!valid) {
                    watchKeyToDirectory.remove(key);
                    LOGGER.warn(I18n.tl("dir_inaccessible", dir));
                    if (watchKeyToDirectory.isEmpty()) {
                        break;
                    }
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(I18n.tl("watch_service_exception"), e);
        }
    }

    public interface Listener {

        void onEvent(Event event, Path path);
    }

    public static class Builder {

        private static final Filter<Path> NO_FILTER = path -> true;

        private final Set<Path> mWatched = new HashSet<>();
        private boolean mPreExistingAsCreated = false;
        private Filter<Path> mFilter = NO_FILTER;
        private Listener mListener;

        public Builder addDirectories(String dirPath) {
            return addDirectories(Paths.get(dirPath));
        }

        public Builder addDirectories(Path dirPath) {
            mWatched.add(dirPath);
            return this;
        }

        public Builder addDirectories(Path... dirPaths) {
            Collections.addAll(mWatched, dirPaths);
            return this;
        }

        public Builder addDirectories(Iterable<? extends Path> dirPaths) {
            for (Path dirPath : dirPaths) {
                mWatched.add(dirPath);
            }
            return this;
        }

        public Builder setPreExistingAsCreated(boolean value) {
            mPreExistingAsCreated = value;
            return this;
        }

        public Builder setFilter(Filter<Path> filter) {
            mFilter = filter;
            return this;
        }

        public DirectoryWatcher build(AntiMalware antiMalware, Listener listener) {
            mListener = listener;
            return new DirectoryWatcher(antiMalware, this);
        }
    }
}
