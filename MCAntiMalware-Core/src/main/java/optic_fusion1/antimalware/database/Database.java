/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.database;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import optic_fusion1.antimalware.check.CheckResult;

public class Database {

  private static final String DATABASE_URL = "https://raw.githubusercontent.com/OpticFusion1/MCAntiMalwareDatabase/master/database.db";
  private Connection connection;

  public Database() {
    downloadAndConnect();
  }

  public void downloadAndConnect() {
    try {
      File tempFile = File.createTempFile("antiMalware", "db");
      try {
        Files.copy(new URL(DATABASE_URL).openStream(), tempFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
      } catch (IOException e) {
        Files.copy(Database.class.getResource("/database.db").openStream(), tempFile.toPath(),
                StandardCopyOption.REPLACE_EXISTING);
      }
      connection = DriverManager.getConnection("jdbc:sqlite:" + tempFile.toURI());
    } catch (SQLException | IOException e) {
      LOGGER.exception(e);
    }
  }

  public HashSet<String> getBlacklistedWebsites() throws SQLException {
    return get("SELECT URL FROM BlacklistedWebsites;", "URL");
  }

  public HashSet<String> getBlacklistedStrings() throws SQLException {
    return get("SELECT String FROM BlacklistedStrings;", "String");
  }

  public HashSet<String> getBlacklistedAuthors() throws SQLException {
    return get("SELECT Name FROM BlacklistedAuthors;", "Name");
  }

  public HashSet<String> getBlacklistedClasspaths() throws SQLException {
    return get("SELECT Classpath FROM BlacklistedClasspaths;", "Classpath");
  }

  public HashSet<String> getBlacklistedChecksums() throws SQLException {
    return get("SELECT Checksum FROM BlacklistedChecksums;", "Checksum");
  }

  public boolean isChecksumBlacklisted(String checksum) {
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedChecksums WHERE Checksum = ?", checksum);
  }

  public boolean isChecksumWhitelisted(String checksum) {
    return queryResultGreaterThanZero("SELECT count(*) FROM WhitelistedChecksums WHERE Checksum = ?", checksum);
  }

  public List<String[]> getMaliciousDevelopers() throws SQLException {
    PreparedStatement pSt = connection.prepareStatement("SELECT Name, UUID FROM BannedAuthors INNER JOIN BannedAuthorsUUIDs ON BannedAuthors._rowid_ = BannedAuthorsUUIDs.AuthorID UNION SELECT Name, UUID FROM BannedAuthors INNER JOIN BannedAuthorsUUIDs ON BannedAuthors._rowid_ = BannedAuthorsUUIDs.AuthorID");
    try ( ResultSet results = pSt.executeQuery()) {
      List<String[]> malDev = new ArrayList<>();
      while (results.next()) {
        malDev.add(new String[]{results.getString("Name"), results.getString("UUID")});
      }
      results.close();
      return malDev;
    }
  }

  public boolean isExecBlacklisted(String exec) {
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedExec WHERE Command LIKE ?", exec);
  }

  public boolean isWriteBlacklisted(String file) {
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedWriteFiles WHERE File LIKE ?", file);
  }

  public boolean isURLBlacklisted(String url) {
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedURLS WHERE Url LIKE ?", url);
  }

  public boolean isStringBlacklisted(String string) {
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedStrings WHERE String LIKE ?", string);
  }

  public boolean isWebsiteBlacklisted(String website) {
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedWebsites WHERE URL LIKE ?", website);
  }

  public boolean isFileNameBlacklisted(String fileName) {
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedFileNames WHERE Name LIKE ?", fileName);
  }

//  public boolean isPackageBlacklisted(String pkg) {
//    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedPackages WHERE Package Like ?", pkg);
//  }

  public boolean isFilePathBlacklisted(String filePath) {
    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedFilePaths WHERE Path LIKE ?", filePath);
  }

  public CheckResult getCheckResultForWebsite(String website) throws SQLException {
    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedWebsites INNER JOIN MalwareChecks ON BlacklistedWebsites.MalwareID = MalwareChecks._rowid_ WHERE URL = ?",
            website);
  }

  public CheckResult getCheckResultForChecksum(String checksum) throws SQLException {
    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedChecksums INNER JOIN MalwareChecks ON BlacklistedChecksums.MalwareID = MalwareChecks._rowid_ WHERE Checksum = ?", checksum);
  }

  public CheckResult getCheckResultForAuthor(String author) throws SQLException {
    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedAuthors INNER JOIN MalwareChecks ON BlacklistedAuthors.MalwareID = MalwareChecks._rowid_ WHERE Name = ?", author);
  }

  public CheckResult getCheckResultForClassPath(String classPath) throws SQLException {
    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedClasspaths INNER JOIN MalwareChecks ON BlacklistedClasspaths.MalwareID = MalwareChecks._rowid_ WHERE Classpath = ?", classPath);
  }

  public CheckResult getCheckResultForString(String string) throws SQLException {
    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedStrings INNER JOIN MalwareChecks ON BlacklistedStrings.MalwareID = MalwareChecks._rowid_ WHERE String = ?", string);
  }

  public CheckResult getCheckResultForFileName(String fileName) throws SQLException {
    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedFileNames INNER JOIN MalwareChecks ON BlacklistedFileNames.MalwareID = MalwareChecks._rowid_ WHERE Name = ?", fileName);
  }

  public CheckResult getCheckResultForFilePath(String filePath) throws SQLException {
    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedFilePaths INNER JOIN MalwareChecks ON BlacklistedFilePaths.MalwareID = MalwareChecks._rowid_ WHERE Path = ?", filePath);
  }

  public CheckResult getCheckResultForPackage(String pkg) throws SQLException {
    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedPackages INNER JOIN MalwareChecks ON BlacklistedPackages.MalwareID = MalwareChecks._rowid_ WHERE Package = ?", pkg);
  }

  private HashSet<String> get(String statement, String a) throws SQLException {
    PreparedStatement query = connection.prepareStatement(statement);
    return toHashSet(query, a);
  }

  private <T> HashSet<T> toHashSet(PreparedStatement pSt, String column) throws SQLException {
    HashSet<T> set;
    try ( ResultSet result = pSt.executeQuery()) {
      set = new HashSet<>();
      while (result.next()) {
        set.add((T) result.getObject(column));
      }
    }
    return set;
  }

  private boolean queryResultGreaterThanZero(String query, String a) {
    try {
      PreparedStatement pSt = connection.prepareStatement(query);
      pSt.setString(1, a);
      try ( ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          if (rs.getInt("count(*)") > 0) {
            return true;
          }
        }
      }
    } catch (SQLException ex) {
      LOGGER.exception(ex);
    }
    return false;
  }

  public CheckResult getCheckResult(String query, String arg) throws SQLException {
    return getCheckResult(query, arg, "plugin.yml", "plugin.yml", -1);
  }

  public CheckResult getCheckResult(String query, String arg, String sourceFilePath,
          String classNodePath, int line) throws SQLException {
    PreparedStatement statement = connection.prepareStatement(query);
    statement.setString(1, arg);
    try ( ResultSet results = statement.executeQuery()) {
      if (results.next()) {
        return new CheckResult(results.getString("platform"), results.getString("type"), results.getString("family"),
                results.getString("variant"), sourceFilePath, classNodePath, line);
      }
    }
    return null;
  }

}
