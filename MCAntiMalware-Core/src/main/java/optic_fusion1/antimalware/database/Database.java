/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.database;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.UUID;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import optic_fusion1.antimalware.check.CheckResult;

@Deprecated()
public class Database {

    private static final String DATABASE_URL = "https://github.com/OpticFusion1/MCAntiMalwareDatabase/blob/master/database.db?raw=true";
    private Connection connection;

    public Database() {
        downloadAndConnect();
    }

    public void downloadAndConnect() {
        try {
            File tempFile = File.createTempFile("antiMalware" + UUID.randomUUID().toString(), ".db");
//            try {
//                Files.copy(new URL(DATABASE_URL).openStream(), tempFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
//                System.out.println("COPYING FROM DATABASE_URL");
//            } catch (IOException e) {
//                LOGGER.exception(e);
                Files.copy(Database.class.getResource("/database.db").openStream(), tempFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
//            }
            connection = DriverManager.getConnection("jdbc:sqlite:" + tempFile.toURI());
        } catch (SQLException | IOException e) {
            LOGGER.info("Unable to load Database");
            LOGGER.exception(e);
            System.exit(0);
        }
    }

    public HashSet<String> getBlacklistedWebsites() throws SQLException {
        return get("SELECT URL FROM BlacklistedWebsites;", "URL");
    }

    public HashSet<String> getBlacklistedStrings() throws SQLException {
        return get("SELECT String FROM BlacklistedStrings;", "String");
    }

    public HashSet<String> getBlacklistedAuthors() throws SQLException {
        return get("SELECT Name FROM BlacklistedAuthors;", "Name");
    }

    public HashSet<String> getBlacklistedClasspaths() throws SQLException {
        return get("SELECT Classpath FROM BlacklistedClasspaths;", "Classpath");
    }

    public HashSet<String> getBlacklistedChecksums() throws SQLException {
        return get("SELECT Checksum FROM BlacklistedChecksums;", "Checksum");
    }

    public HashSet<String> getBlacklistedUrls() throws SQLException {
        return get("SELECT Url FROM BlacklistedURLS;", "Url");
    }

    public HashSet<String> getWhitelistedChecksums() throws SQLException {
        return get("SELECT Checksum FROM WhitelistedChecksums", "Checksum");
    }

    public HashSet<String> getBlacklistedCommands() throws SQLException {
        return new HashSet<>();
//    return get("SELECT Command FROM BlacklistedCommands;", "Command");
    }

    public HashSet<String> getBlacklistedFileNames() throws SQLException {
        return get("SELECT Name FROM BlacklistedFileNames;", "Name");
    }

    public HashSet<String> getBlacklistedExec() throws SQLException {
        return get("SELECT Command FROM BlacklistedExec", "Command");
    }

    public HashSet<String> getBlacklistedWrite() throws SQLException {
        return get("SELECT File FROM BlacklistedWriteFiles", "File");
    }

    public HashSet<String> getBlacklistedPackages() throws SQLException {
        return get("SELECT Package FROM BlacklistedPackages", "Package");
    }

    public HashSet<String> getBlacklistedFilePaths() throws SQLException {
        return get("SELECT Path FROM BlacklistedFilePaths", "Path");
    }

    public boolean isChecksumBlacklisted(String checksum) {
        return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedChecksums WHERE Checksum = ?", checksum);
    }

    public boolean isChecksumWhitelisted(String checksum) {
        return queryResultGreaterThanZero("SELECT count(*) FROM WhitelistedChecksums WHERE Checksum = ?", checksum);
    }

    public List<String[]> getMaliciousDevelopers() throws SQLException {
        PreparedStatement pSt = connection.prepareStatement("SELECT Name, UUID FROM BannedAuthors INNER JOIN BannedAuthorsUUIDs ON BannedAuthors._rowid_ = BannedAuthorsUUIDs.AuthorID UNION SELECT Name, UUID FROM BannedAuthors INNER JOIN BannedAuthorsUUIDs ON BannedAuthors._rowid_ = BannedAuthorsUUIDs.AuthorID");
        try (ResultSet results = pSt.executeQuery()) {
            List<String[]> malDev = new ArrayList<>();
            while (results.next()) {
                malDev.add(new String[]{results.getString("Name"), results.getString("UUID")});
            }
            results.close();
            return malDev;
        }
    }

    public boolean isExecBlacklisted(String exec) {
        return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedExec WHERE Command LIKE ?", exec);
    }

    public boolean isWriteBlacklisted(String file) {
        return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedWriteFiles WHERE File LIKE ?", file);
    }

    public boolean isURLBlacklisted(String url) {
        return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedURLS WHERE Url LIKE ?", url);
    }

    public boolean isStringBlacklisted(String string) {
        return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedStrings WHERE String LIKE ?", string);
    }

    public boolean isWebsiteBlacklisted(String website) {
        return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedWebsites WHERE URL LIKE ?", website);
    }

    public boolean isFileNameBlacklisted(String fileName) {
        return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedFileNames WHERE Name LIKE ?", fileName);
    }

//  public boolean isPackageBlacklisted(String pkg) {
//    return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedPackages WHERE Package Like ?", pkg);
//  }
    public boolean isFilePathBlacklisted(String filePath) {
        return queryResultGreaterThanZero("SELECT count(*) FROM BlacklistedFilePaths WHERE Path LIKE ?", filePath);
    }

    public CheckResult getCheckResultForWebsite(String website) throws SQLException {
        return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedWebsites INNER JOIN MalwareChecks ON BlacklistedWebsites.MalwareID = MalwareChecks._rowid_ WHERE URL = ?",
                website);
    }

    public CheckResult getCheckResultForChecksum(String checksum) throws SQLException {
        return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedChecksums INNER JOIN MalwareChecks ON BlacklistedChecksums.MalwareID = MalwareChecks._rowid_ WHERE Checksum = ?", checksum);
    }

    public CheckResult getCheckResultForAuthor(String author) throws SQLException {
        return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedAuthors INNER JOIN MalwareChecks ON BlacklistedAuthors.MalwareID = MalwareChecks._rowid_ WHERE Name = ?", author);
    }

    public CheckResult getCheckResultForClassPath(String classPath) throws SQLException {
        return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedClasspaths INNER JOIN MalwareChecks ON BlacklistedClasspaths.MalwareID = MalwareChecks._rowid_ WHERE Classpath = ?", classPath);
    }

    public CheckResult getCheckResultForString(String string) throws SQLException {
        return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedStrings INNER JOIN MalwareChecks ON BlacklistedStrings.MalwareID = MalwareChecks._rowid_ WHERE String = ?", string);
    }

    public CheckResult getCheckResultForFileName(String fileName) throws SQLException {
        return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedFileNames INNER JOIN MalwareChecks ON BlacklistedFileNames.MalwareID = MalwareChecks._rowid_ WHERE Name = ?", fileName);
    }

    public CheckResult getCheckResultForFilePath(String filePath) throws SQLException {
        return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedFilePaths INNER JOIN MalwareChecks ON BlacklistedFilePaths.MalwareID = MalwareChecks._rowid_ WHERE Path = ?", filePath);
    }

    public CheckResult getCheckResultForCommand(String command) throws SQLException {
        return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedCommands INNER JOIN MalwareChecks ON BlacklistedCommands.MalwareID = MalwareChecks._rowid_ WHERE Path = ?", command);
    }

//  public CheckResult getCheckResultForPackage(String pkg) throws SQLException {
//    return getCheckResult("SELECT type, platform, family, variant FROM BlacklistedPackages INNER JOIN MalwareChecks ON BlacklistedPackages.MalwareID = MalwareChecks._rowid_ WHERE Package = ?", pkg);
//  }
    private HashSet<String> get(String statement, String a) throws SQLException {
        PreparedStatement query = connection.prepareStatement(statement);
        return toHashSet(query, a);
    }

    private <T> HashSet<T> toHashSet(PreparedStatement pSt, String column) throws SQLException {
        HashSet<T> set;
        try (ResultSet result = pSt.executeQuery()) {
            set = new HashSet<>();
            while (result.next()) {
                set.add((T) result.getObject(column));
            }
        }
        return set;
    }

    private boolean queryResultGreaterThanZero(String query, String a) {
        try {
            PreparedStatement pSt = connection.prepareStatement(query);
            pSt.setString(1, a);
            try (ResultSet rs = pSt.executeQuery()) {
                if (rs.next()) {
                    if (rs.getInt("count(*)") > 0) {
                        return true;
                    }
                }
            }
        } catch (SQLException ex) {
            LOGGER.exception(ex);
        }
        return false;
    }

    public CheckResult getCheckResult(String query, String arg) throws SQLException {
        return getCheckResult(query, arg, "plugin.yml", "plugin.yml", -1);
    }

    public CheckResult getCheckResult(String query, String arg, String sourceFilePath,
            String classNodePath, int line) throws SQLException {
        try (PreparedStatement statement = connection.prepareStatement(query)) {
            statement.setString(1, arg);
            try (ResultSet results = statement.executeQuery()) {
                if (results.next()) {
                    return new CheckResult(results.getString("platform"), results.getString("type"), results.getString("family"),
                            results.getString("variant"), sourceFilePath, classNodePath, line);
                }
            }
        }
        return null;
    }

}
