/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.utils;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.URI;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collections;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import optic_fusion1.antimalware.AntiMalware;
import static optic_fusion1.antimalware.AntiMalware.LOGGER;
import optic_fusion1.antimalware.configuration.file.FileConfiguration;

public final class Utils {

    private Utils() {
    }

    public static void copy(String resource, String destination) {
        InputStream ddlStream = AntiMalware.class.getClassLoader().getResourceAsStream(resource);
        if (ddlStream == null) {
            LOGGER.warn(I18n.tl("resource_not_found", resource));
            return;
        }
        try (FileOutputStream fos = new FileOutputStream(destination)) {
            byte[] buf = new byte[2048];
            int r;
            while (-1 != (r = ddlStream.read(buf))) {
                fos.write(buf, 0, r);
            }
        } catch (FileNotFoundException ex) {
            LOGGER.exception(ex);
        } catch (IOException ex) {
            LOGGER.exception(ex);
        }
    }

    public static void saveResource(File dataFolder, String resourcePath, boolean replace) {
        if (resourcePath == null || resourcePath.isEmpty()) {
            throw new IllegalArgumentException(I18n.tl("null_or_empty", "resourcePath"));
        }
        if (dataFolder == null || resourcePath.isEmpty()) {
            throw new IllegalArgumentException(I18n.tl("null_or_empty", "DataFolder"));
        }

        resourcePath = resourcePath.replace('\\', '/');
        InputStream in = getResource(resourcePath);
        if (in == null) {
            LOGGER.warn(I18n.tl("embedded_resource_not_found", resourcePath));
            return;
        }
        File outFile = new File(dataFolder, resourcePath);
        int lastIndex = resourcePath.lastIndexOf('/');
        File outDir = new File(dataFolder, resourcePath.substring(0, lastIndex >= 0 ? lastIndex : 0));

        if (!outDir.exists()) {
            outDir.mkdirs();
        }

        try {
            if (!outFile.exists() || replace) {
                try (OutputStream out = new FileOutputStream(outFile)) {
                    byte[] buf = new byte[1024];
                    int len;
                    while ((len = in.read(buf)) > 0) {
                        out.write(buf, 0, len);
                    }
                }
                in.close();
            } else {
                LOGGER.warn(I18n.tl("could_not_save_already_exists", outFile.getName(), outFile, outFile.getName()));
            }
        } catch (IOException ex) {
            LOGGER.severe(I18n.tl("could_not_save", outFile.getName(), outFile));
        }
    }

    public static InputStream getResource(String filename) {
        if (filename == null || filename.isEmpty()) {
            throw new IllegalArgumentException(I18n.tl("null_or_empty", "fileName"));
        }
        InputStream input = AntiMalware.class.getClassLoader().getResourceAsStream(filename);
        if (input == null) {
            LOGGER.warn(I18n.tl("resource_not_found", filename));
            return null;
        }
        return input;
    }

    public static void notNull(Object o, String message) {
        if (o == null) {
            throw new NullPointerException(message);
        }
    }

    public static void notEmpty(String s, String errorMessage) {
        if (s.isEmpty()) {
            throw new IllegalArgumentException(errorMessage);
        }
    }

    public static void isTrue(boolean expression, String errorMessage) {
        if (!expression) {
            throw new IllegalArgumentException(errorMessage);
        }
    }

    public static boolean moveFile(String sourcePath, String targetPath) {
        boolean fileMoved = true;
        try {
            Files.move(Paths.get(sourcePath), Paths.get(targetPath), StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            fileMoved = false;
        }
        return fileMoved;
    }

    public static String formatTodaysDate() {
        Calendar cal = new GregorianCalendar();
        SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
        dateFormat.setTimeZone(cal.getTimeZone());
        return dateFormat.format(cal.getTime());
    }

    public static int getJavaVersion() {
        String version = System.getProperty("java.version");
        if (version.startsWith("1.")) {
            version = version.substring(2);
        }
        int dotPos = version.indexOf('.');
        int dashPos = version.indexOf('-');
        return Integer.parseInt(version.substring(0, dotPos > -1 ? dotPos : dashPos > -1 ? dashPos : 1));
    }

    public static List<String> getAuthors(FileConfiguration config) {
        if (config.isSet("authors")) {
            return getAuthors(config, "authors");
        }
        if (config.isSet("author")) {
            return getAuthors(config, "author");
        }
        return new ArrayList<>();
    }

    private static List<String> getAuthors(FileConfiguration config, String field) {
        List<String> authors = new ArrayList<>();
        if (config.isList(field)) {
            authors.addAll(config.getStringList(field));
        } else {
            authors.add(config.getString(field));
        }
        return authors;
    }

    public static FileSystem fileSystemForZip(final Path pathToZip) throws IOException {
        try {
            return FileSystems.newFileSystem(pathToZip, new HashMap<>());
        } catch (IOException ignored) {
            ignored.printStackTrace();
            // Ignore this exception, we can try again
        }

        try {
            return FileSystems.getFileSystem(URI.create("jar:" + pathToZip.toUri() + "!/"));
        } catch (Exception ignored) {
            ignored.printStackTrace();
            // Ignore this exception, we can try again
        }

        try {
            return FileSystems.newFileSystem(URI.create("jar:" + pathToZip.toUri() + "!/"), new HashMap<>());
        } catch (IOException ignored) {
            ignored.printStackTrace();
            // Ignore this exception, we can try again
        }

        LOGGER.warn("Couldn't get FileSystem for " + pathToZip);
        return null;
    }

    public static void unzip(ZipFile source, File destination) throws IOException {
        for (ZipEntry entry : Collections.list(source.entries())) {
            unzip(source, entry, destination);
        }
    }

    private static void unzip(ZipFile source, ZipEntry entry, File destination) throws IOException {
        if (!entry.isDirectory()) {
            File resource = new File(destination, entry.getName());
            if (!resource.getCanonicalPath().startsWith(destination.getCanonicalPath() + File.separator)) {
                throw new IOException("Entry is outside of the target dir: " + entry);
            }
            File folder = resource.getParentFile();
            if (!folder.exists()) {
                if (!folder.mkdirs()) {
                    throw new IOException();
                }
            }
            try (BufferedInputStream input = new BufferedInputStream(source.getInputStream(entry));
                    BufferedOutputStream output = new BufferedOutputStream(new FileOutputStream(resource))) {
                output.write(input.readAllBytes());
                output.flush();
            }
        }
    }

    public static boolean validClassPath(Path path) {
        return path.toString().endsWith(".class") && !path.toString().contains("__MACOSX");
    }

}
