/*
* Copyright (C) 2021 Optic_Fusion1
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package optic_fusion1.antimalware.utils;

import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

//TODO: Look into optimizing this class if possible (Performance tuned for 2.0 (JDK1.4) should get tuned for JDK 17)
public final class StringUtils {

    public static final int INDEX_NOT_FOUND = -1;
    public static final String[] EMPTY_STRING_ARRAY = new String[0];
    public static final Pattern FORMAT_PATTERN = Pattern.compile("\\$\\{[\\w_-]+}");

    private StringUtils() {
    }

    public static String format(String message, Object param) {
        return format(message, new Object[]{param});
    }

    public static String format(String message, Object[] params) {
        return MessageFormat.format(message, params);
    }

    public static boolean isBlank(String input) {
        return input == null || input.length() == 0 || input.chars().allMatch(Character::isWhitespace);
    }

    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {
        // Performance tuned for 2.0 (JDK1.4)
        // Direct code is quicker than StringTokenizer.
        // Also, StringTokenizer uses isSpace() not isWhitespace()

        if (str == null) {
            return null;
        }
        int len = str.length();
        if (len == 0) {
            return EMPTY_STRING_ARRAY;
        }
        List list = new ArrayList();
        int sizePlus1 = 1;
        int i = 0, start = 0;
        boolean match = false;
        boolean lastMatch = false;
        if (separatorChars == null) {
            // Null separator means use whitespace
            while (i < len) {
                if (Character.isWhitespace(str.charAt(i))) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        } else if (separatorChars.length() == 1) {
            // Optimise 1 character case
            char sep = separatorChars.charAt(0);
            while (i < len) {
                if (str.charAt(i) == sep) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        } else {
            // standard case
            while (i < len) {
                if (separatorChars.indexOf(str.charAt(i)) >= 0) {
                    if (match || preserveAllTokens) {
                        lastMatch = true;
                        if (sizePlus1++ == max) {
                            i = len;
                            lastMatch = false;
                        }
                        list.add(str.substring(start, i));
                        match = false;
                    }
                    start = ++i;
                    continue;
                }
                lastMatch = false;
                match = true;
                i++;
            }
        }
        if (match || (preserveAllTokens && lastMatch)) {
            list.add(str.substring(start, i));
        }
        return (String[]) list.toArray(new String[list.size()]);
    }

    public static String[] split(String str, String separatorChars) {
        return splitWorker(str, separatorChars, -1, false);
    }

    public static boolean isEmpty(String str) {
        return str == null || str.length() == 0;
    }

    public static int countMatches(String str, String sub) {
        if (isEmpty(str) || isEmpty(sub)) {
            return 0;
        }
        int count = 0;
        int idx = 0;
        while ((idx = str.indexOf(sub, idx)) != INDEX_NOT_FOUND) {
            count++;
            idx += sub.length();
        }
        return count;
    }

    public static CompiledFormat compile(String template) {
        CompiledFormat c = new CompiledFormat();
        c.slices = new ArrayList<>();
        c.params = new ArrayList<>();
        Matcher matcher = FORMAT_PATTERN.matcher(template);
        int lastI = 0;
        while (matcher.find()) {
            int start = matcher.start(0);
            int end = matcher.end(0);
            c.params.add(template.substring(start+2,end-1));
            c.slices.add(template.substring(lastI, start));
            lastI = end;
        }
        c.slices.add(template.substring(lastI));
        return c;
    }

    static public class CompiledFormat {
        private List<String> slices;
        private List<String> params;
        private CompiledFormat() {}
        public String format(Map<String, String> values) {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < this.params.size(); i++) {
                String slice = this.slices.get(i);
                String param = this.params.get(i);
                String value = values.get(param);
                result.append(slice).append(value);
            }
            result.append(this.slices.get(this.params.size()));
            return result.toString();
        }
    }
}
