package optic_fusion1.mcantimalware.scanner;

import java.awt.AWTException;
import java.awt.Image;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.zip.ZipFile;
import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CheckManagerImpl;
import optic_fusion1.mcantimalware.configuration.file.FileConfiguration;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.ZipUtils;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.IOUtils;

//TODO: Re-Implement Auto-Updater and RealTimeScanner
public class Scanner extends Thread {

  private Main main;
  private CustomLogger logger;
  private File scanDirectory;
  private File serverJar;
  private String fileInfo = null;
  private boolean shouldLogExceptions;
  private boolean shouldLogDebugMessages;
  private boolean shouldPrintNotInfectedMessages;
  private boolean showPopup;
  private boolean firstScan = true;
  private CheckManagerImpl checkManager;
  private FileConfiguration checksumDatabase;
  private Status status = Status.WAITING;
  private List<File> queue = new ArrayList<>();

  public enum Status {
    SCANNING,
    WAITING;
  }

  public Scanner(Main main, File scanDirectory) {
    this.main = main;
    this.logger = main.getLogger();
    checkManager = main.getCheckManager();
    CommandLineParser commandLineParser = main.getCommandLineParser();
    shouldLogExceptions = commandLineParser.shouldExceptionsBeLogged();
    shouldLogDebugMessages = commandLineParser.shouldDebugMessagesBeLogged();
    shouldPrintNotInfectedMessages = commandLineParser.shouldPrintNotInfectedMessages();
    showPopup = commandLineParser.shouldNotifyWhenMalicious();
    checksumDatabase = main.getChecksumDatabase();
    this.scanDirectory = scanDirectory;
  }

  @Override
  public void run() {
    //TODO: Re-look into this loop
    while (true) {
      if (firstScan && status == Status.WAITING) {
        status = Status.SCANNING;
        scanFiles();
        status = Status.WAITING;
        firstScan = false;
      }
      if (status == Status.WAITING && !queue.isEmpty()) {
        status = Status.SCANNING;
        Iterator<File> iterator = queue.iterator();
        while (iterator.hasNext()) {
          scanFile(iterator.next());
          iterator.remove();
        }
        status = Status.WAITING;
      }
      if (status == Status.WAITING && main.getCommandLineParser().singleScan()) {
        try {
          join();
          main.join();
          System.exit(0);
        } catch (InterruptedException ex) {
          if (shouldLogExceptions) {
            logger.exception(ex);
          }
        }
      }
    }
  }

  public void scanFiles() {
    logger.info(I18n.tl("scan_start"));
    for (File file : scanDirectory.listFiles()) {
      if (file.isDirectory()) {
        scanDirectory(file);
        continue;
      }
      scanFile(file);
    }
    logger.info(I18n.tl("scan_end"));
  }

  public void scanDirectory(File directory) {
    if (!directory.isDirectory()) {
      scanFile(directory);
      return;
    }
    for (File file : directory.listFiles()) {
      if (file.isDirectory()) {
        scanDirectory(file);
        continue;
      }
      scanFile(file);
    }
  }

  public void scanFile(File file) {
    if (file.isDirectory()) {
      scanDirectory(file);
      return;
    }
    if (file.length() == 0) {
      return;
    }
    String fileName = file.getName();
    if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar") || fileName.equals("MCAntiMalware.jar")) {
      return;
    }
    String filePath = file.toString();
    if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
      try {
        File tempDir = ZipUtils.unzipFileToTempDir(filePath);
        fileInfo = IOUtils.toString(new FileInputStream(new File(tempDir.getPath(), "file.info")), "UTF-8");
        scanDirectory(tempDir);
        return;
      } catch (FileNotFoundException ex) {
        if (shouldLogExceptions) {
          logger.exception(ex);
        }
      } catch (IOException ex) {
        if (shouldLogExceptions) {
          logger.exception(ex);
        }
      }
    }
    WhitelistResult result = isFileWhitelisted(file);
    if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED) {
      return;
    }
    if (shouldLogDebugMessages) {
      logger.debug(I18n.tl("not_in_checksum_database"), new Object[]{filePath});
    }
    try {
      ZipFile zipFile = new ZipFile(file);
      for (BaseCheck check : checkManager.getChecks()) {
        try {
          check.process(filePath, zipFile);
        } catch (Exception e) {
          if (shouldLogExceptions) {
            logger.exception(e);
          }
          continue;
        }
        if (shouldLogDebugMessages) {
          logger.debug("Chance: " + check.getScore() + " Threshold: " + check.getThreshold());
        }
        if (!(check.getScore() >= check.getThreshold())) {
          if (shouldPrintNotInfectedMessages) {
            logger.info(I18n.tl("might_not_be_infected",
             (fileInfo != null && fileInfo.isEmpty() ? "" : fileInfo + "#") + fileName,
             check.getLogName(),
             check.getType()));
          }
        } else {
          logger.detected(I18n.tl("might_be_infected",
           (fileInfo != null && fileInfo.isEmpty() ? "" : fileInfo + "#") + fileName,
           check.getLogName(),
           check.getType(),
           check.getClassNodePath(),
           (check.getLine() > -1 ? check.getLine() : "none"),
           (!check.getSourceFilePath().isEmpty() ? check.getSourceFilePath() : "none")));
          if (showPopup) {
            showTrayPopup(filePath, check);
          }
        }
        check.reset();
        fileInfo = "";
      }
    } catch (IOException ex) {
      if (shouldLogExceptions) {
        logger.exception(ex);
      }
    }
  }

  public enum WhitelistResult {
    INVALID_FILE,
    NO_PLUGIN_YML,
    INVALID_PLUGIN_YML,
    NOT_WHITELISTED,
    WHITELISTED;
  }

  private WhitelistResult isFileWhitelisted(File file) {
    if (file == null || file.length() == 0) {
      return WhitelistResult.INVALID_FILE;
    }
    if (checksumDatabase == null) {
      return WhitelistResult.NOT_WHITELISTED;
    }
    String fileName = file.getName();
    if (serverJar != null && fileName.equals(serverJar.getName())) {
      return WhitelistResult.NOT_WHITELISTED;
    }
    try {
      JarFile jarFile = new JarFile(file);
      JarEntry entry = jarFile.getJarEntry("plugin.yml");
      if (entry == null) {
        logger.info(I18n.tl("has_no_plugin_yml", fileName));
        return WhitelistResult.NO_PLUGIN_YML;
      }
      InputStream inputStream = jarFile.getInputStream(entry);
      if (inputStream == null) {
        jarFile.close();
        return WhitelistResult.NO_PLUGIN_YML;
      }
      FileConfiguration config = null;
      try {
        config = YamlConfiguration.loadConfiguration(inputStream);
      } catch (Exception e) {
        inputStream.close();
        jarFile.close();
        return WhitelistResult.NOT_WHITELISTED;
      }
      if (!config.isSet("author") && !config.isSet("name")) {
        if (shouldLogDebugMessages) {
          logger.info(I18n.tl("no_author_and_name"));
        }
        inputStream.close();
        jarFile.close();
        return WhitelistResult.INVALID_PLUGIN_YML;
      }
      //TODO: Properly support author lists
      String author = config.isSet("author") ? config.getString("author").replaceAll(" ", "-").replaceAll("\\.", "-") : null;
      String name = config.isSet("name") ? config.getString("name").replaceAll(" ", "-").replaceAll("\\.", "-") : null;
      if (name == null) {
        inputStream.close();
        jarFile.close();
        return WhitelistResult.INVALID_PLUGIN_YML;
      }
      if (shouldLogDebugMessages) {
        logger.debug("Author: " + author + " Name: " + name);
      }
      String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file.toPath()));
      //TODO: Clean this up, certain chunks of code are duplicated, they can be moved to a separate method
      if (author != null && !author.isEmpty()) {
        if (!checksumDatabase.isSet(author + "." + name)) {
          if (shouldLogDebugMessages) {
            logger.debug(author + "." + name + " is not set (File: " + file.toString() + ")");
          }
          inputStream.close();
          jarFile.close();
          return WhitelistResult.NOT_WHITELISTED;
        }
        List<String> checksums = checksumDatabase.getStringList(author + "." + name);
        for (String checksum : checksums) {
          if (shouldLogDebugMessages) {
            logger.debug("File Checksum: " + fileChecksum + " Database Checksum: " + checksum);
          }
          if (fileChecksum.equalsIgnoreCase(checksum)) {
            inputStream.close();
            jarFile.close();
            logger.info(I18n.tl("probably_safe", fileName));
            return WhitelistResult.WHITELISTED;
          }
          inputStream.close();
          jarFile.close();
          return WhitelistResult.NOT_WHITELISTED;
        }
        return WhitelistResult.NOT_WHITELISTED;
      }
      if (!checksumDatabase.isSet(name)) {
        if (shouldLogDebugMessages) {
          logger.debug(name + " is not set (File: " + file.toString() + ")");
        }
        inputStream.close();
        jarFile.close();
        return WhitelistResult.NOT_WHITELISTED;
      }
      List<String> checksums = checksumDatabase.getStringList(name);
      for (String checksum : checksums) {
        if (shouldLogDebugMessages) {
          logger.debug("File Checksum: " + fileChecksum + " Database Checksum: " + checksum);
        }
        if (fileChecksum.equalsIgnoreCase(checksum)) {
          logger.info(I18n.tl("probably_safe", file.getName()));
          inputStream.close();
          jarFile.close();
          return WhitelistResult.WHITELISTED;
        }
        inputStream.close();
        jarFile.close();
      }
    } catch (IOException ex) {
      if (shouldLogExceptions) {
        logger.exception(ex);
      }
    }
    return WhitelistResult.NOT_WHITELISTED;
  }

  private void showTrayPopup(String fullFileName, BaseCheck check) {
    String os = System.getProperty("os.name").toLowerCase();
    if (SystemTray.isSupported() && os.contains("win")) {
      SystemTray tray = SystemTray.getSystemTray();
      Image image = Toolkit.getDefaultToolkit().createImage(Main.class.getResource("/index.jpg"));
      TrayIcon trayIcon = new TrayIcon(image, "Malware Detected");
      trayIcon.setImageAutoSize(true);
      trayIcon.setToolTip(I18n.tl("might_be_infected_tool_tip", fullFileName));
      try {
        tray.add(trayIcon);
        trayIcon.displayMessage(
         I18n.tl("malware_detected_tool_tip_title"),
         I18n.tl("might_be_infected_tool_tip_text",
          fullFileName,
          check.getName(),
          check.getType(),
          check.getClassNodePath()),
         TrayIcon.MessageType.WARNING);
      } catch (AWTException ex) {
        if (shouldLogExceptions) {
          logger.exception(ex);
        }
      }
      ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
      executor.schedule(() -> tray.remove(trayIcon), 4, TimeUnit.MINUTES);
    }
  }

  public void addFileToQueue(File file) {
    queue.add(file);
  }

  public void reloadChecksumDatabase() {
    logger.info(I18n.tl("updating_local_checksum_database"));
    checksumDatabase = main.getChecksumDatabase();
    logger.info(I18n.tl("updated_local_checksum_database"));
  }

  public File getScanDirectory() {
    return scanDirectory;
  }

  public Status getStatus() {
    return status;
  }

}
