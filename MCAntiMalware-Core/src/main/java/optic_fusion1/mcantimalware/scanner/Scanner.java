package optic_fusion1.mcantimalware.scanner;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.zip.ZipError;
import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CacheContainer;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.check.CheckResult;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.notification.NotificationHandler;
import optic_fusion1.mcantimalware.utils.FileSizeComparator;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.Utils;
import org.apache.commons.codec.digest.DigestUtils;

public abstract class Scanner implements Runnable {

	private static final Queue<Path> SCANNABLE_FILES = new ConcurrentLinkedQueue<>();
	private ThreadPoolExecutor executorService;
	protected final Main main;
	protected final CustomLogger logger;
	protected final File scanDirectory;
	protected final CheckManager checkManager;
	protected final CommandLineParser commandLineParser;
	private NotificationHandler notificationHandler;

	public Scanner(Main main, File scanDirectory) {
		this.main = main;
		this.logger = main.getLogger();
		checkManager = main.getCheckManager();
		commandLineParser = main.getCommandLineParser();
		this.scanDirectory = scanDirectory;
		notificationHandler = main.getNotificationHandler();
	}

	@Override
	public void run() {
		try {
			Path file = SCANNABLE_FILES.remove();
			if (file == null) {
				return;
			}
			scanFile(file);
		} catch (Exception e) {
			logger.exception(e);
		}
		if (SCANNABLE_FILES.size() % 100 == 0) {
			System.out.println(I18n.tl("remaining_files", SCANNABLE_FILES.size()));
		}
	}

	public void scanFiles() {
		FileSizeComparator comparator = new FileSizeComparator();
		logger.info(I18n.tl("scan_start"));
		try {
			Files.walk(scanDirectory.toPath()).filter(Files::isRegularFile).sorted(comparator)
					.forEachOrdered(this::addFileToQueue);
		} catch (IOException e) {
			logger.exception(e);
		}
	}

	private void scanDirectory(Path directory) {
		if (!Files.isDirectory(directory)) {
			scanFile(directory);
			return;
		}
		try {
			Files.list(directory).forEach((path) -> {
				if (path.getFileSystem().isOpen()) {
					if (Files.isDirectory(path)) {
						scanDirectory(path);
					} else {
						scanFile(path);
					}
				}
			});
		} catch (IOException e) {
			logger.exception(e);
		}
	}

	private void scanFile(Path file) {
		if (Files.isDirectory(file)) {
			scanDirectory(file);
			return;
		}
		String fileName = file.getFileName().toString();
		if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar")) {
			return;
		}
		try {
			if (Files.size(file) == 0) {
				return;
			}
		} catch (IOException e) {
			logger.exception(e);
			return;
		}
		try (FileSystem fs = Utils.fileSystemForZip(file)) {
			if (fs == null) {
				return;
			}
			Path rootFolder = fs.getRootDirectories().iterator().next();

			if (commandLineParser.shouldScanZippedFiles()) {
				if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
					scanDirectory(rootFolder);
					return;
				}
			}
			WhitelistResult result = isFileWhitelisted(file);
			if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED) {
				return;
			}
			CacheContainer ccc = new CacheContainer();
			for (BaseCheck check : checkManager.getChecks()) {
				List<CheckResult> results;
				try {
					results = check.process(rootFolder, file, ccc);
					if (results != null && !results.isEmpty()) {
						results.stream().forEachOrdered(checkResult -> {
							sendNotification(file, checkResult);
						});
					}
				} catch (Exception e) {
					logger.exception(e);
					continue;
				}
				check.reset();
			}
		} catch (IOException ex) {
			logger.exception(ex);
		} catch (ZipError zip) {
			logger.warn("[ERR] Zip File " + file.toString() + " can't be read!");
		}
	}

	public enum WhitelistResult {
		INVALID_FILE, NOT_WHITELISTED, WHITELISTED;
	}

	private WhitelistResult isFileWhitelisted(Path file) {
		try {
			if (file == null || Files.size(file) == 0) {
				return WhitelistResult.INVALID_FILE;
			}
			String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file));
			WhitelistResult result = isChecksumWhitelisted(fileChecksum);
			if (result == WhitelistResult.WHITELISTED && commandLineParser.shouldPrintNotInfectedMessages()) {
				logger.info(I18n.tl("probably_safe_whitelist", file.getFileName().toString()));
			}
			return result;
		} catch (IOException e) {
			logger.exception(e);
		}
		return WhitelistResult.NOT_WHITELISTED;
	}

	public void addFileToQueue(Path file) {
		if (Files.isDirectory(file)) {
			addDirectoryToQueue(file);
			return;
		}
		SCANNABLE_FILES.add(file);
		if (executorService == null) {
			executorService = new ThreadPoolExecutor(4, Math.max(Runtime.getRuntime().availableProcessors(), 4), 10,
					TimeUnit.SECONDS, new ArrayBlockingQueue<>(50000));
			executorService.allowCoreThreadTimeOut(true);
		}
		executorService.execute(this);
	}

	public void addDirectoryToQueue(Path dir) {
		if (!Files.isDirectory(dir)) {
			return;
		}
		try {
			Files.list(dir).forEach(this::addFileToQueue);
		} catch (IOException e) {
			logger.exception(e);
		}
	}

	public boolean awaitTermination(int time, TimeUnit unit) {
		try {
			return executorService.awaitTermination(time, unit);
		} catch (InterruptedException e) {
		}
		return false;
	}

	private WhitelistResult isChecksumWhitelisted(String checksum) {
		return main.getDatabase().isChecksumWhitelisted(checksum) ? WhitelistResult.WHITELISTED
				: WhitelistResult.NOT_WHITELISTED;
	}

	public enum Status {
		SCANNING, WAITING, NOT_RUNNING;
	}

	public Status getStatus() {
		if (executorService == null) {
			return Status.NOT_RUNNING;
		} else if (executorService.getTaskCount() == 0) {
			return Status.WAITING;
		} else {
			return Status.SCANNING;
		}
	}

	public File getScanDirectory() {
		return scanDirectory;
	}

	public Main getMain() {
		return main;
	}

	public void sendNotification(Path path, CheckResult result) {
		// TODO: Make these translatable
		Objects.requireNonNull(path, "Path cannot be null");
		Objects.requireNonNull(result, "CheckResult cannot be null");
		notificationHandler.sendNotification(path, result);
	}

}
