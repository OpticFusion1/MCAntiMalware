package optic_fusion1.mcantimalware.scanner;

import java.awt.AWTException;
import java.awt.Image;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CacheContainer;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.check.CheckResult;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.utils.FileSizeComparator;
import optic_fusion1.mcantimalware.utils.I18n;
import org.apache.commons.codec.digest.DigestUtils;

//TODO: Re-Implement Auto-Updater and RealTimeScanner
public class Scanner implements Runnable {

  private static final Queue<Path> SCANNABLE_FILES = new ConcurrentLinkedQueue<>();
  private ThreadPoolExecutor executorService;
  private final Main main;
  private final CustomLogger logger;
  private final File scanDirectory;
  private final CheckManager checkManager;
  private final CommandLineParser commandLineParser;

  public Scanner(Main main, File scanDirectory) {
    this.main = main;
    this.logger = main.getLogger();
    checkManager = main.getCheckManager();
    commandLineParser = main.getCommandLineParser();
    this.scanDirectory = scanDirectory;
  }

  @Override
  public void run() {
    try {
      Path file = SCANNABLE_FILES.remove();
      if (file == null) {
        return;
      }
      scanFile(file);
    } catch (Exception e) {
      logger.exception(e);
    }
    if (SCANNABLE_FILES.size() % 100 == 0) {
      System.out.println(I18n.tl("remaining_files", SCANNABLE_FILES.size()));
    }
  }

  public void scanFiles() {
    FileSizeComparator comparator = new FileSizeComparator();
    logger.info(I18n.tl("scan_start"));
    try {
      Files.walk(scanDirectory.toPath()).filter(Files::isRegularFile).sorted(comparator)
              .forEachOrdered(this::addFileToQueue);
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  private void scanDirectory(Path directory) {
    if (!Files.isDirectory(directory)) {
      scanFile(directory);
      return;
    }
    try {
      Files.list(directory).forEach((path) -> {
        if (Files.isDirectory(path)) {
          scanDirectory(path);
        } else {
          scanFile(path);
        }
      });
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  private void scanFile(Path file) {
    if (Files.isDirectory(file)) {
      scanDirectory(file);
      return;
    }
    try {
      if (Files.size(file) == 0) {
        return;
      }
    } catch (IOException e) {
      logger.exception(e);
      return;
    }
    String fileName = file.getFileName().toString();
    if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar")) {
      return;
    }
    String filePath = file.toString();

    try (FileSystem fs = FileSystems.newFileSystem(file, null)) {

      Path rootFolder = fs.getRootDirectories().iterator().next();

      if (commandLineParser.shouldScanZippedFiles()) {
        if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
          scanDirectory(rootFolder);
          return;
        }
      }
      WhitelistResult result = isFileWhitelisted(file);
      if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED) {
        return;
      }
      CacheContainer ccc = new CacheContainer();
      for (BaseCheck check : checkManager.getChecks()) {
        List<CheckResult> results;
        try {
          results = check.process(rootFolder, file, ccc);
        } catch (Exception e) {
          logger.exception(e);
          continue;
        }
        if (results != null && !results.isEmpty()) {
          for (CheckResult cr : results) {
            logger.detected(
                    I18n.tl("might_be_infected", file.toUri().toString(), cr.getPlatform(), cr.getType(), cr.getFamily(),
                            cr.getVariant(), (!check.getClassNodePath().isEmpty() ? check.getClassNodePath() : "none"), (check.getLine() > -1 ? check.getLine() : "none"),
                            (!check.getSourceFilePath().isEmpty() ? check.getSourceFilePath() : "none")));
            if (commandLineParser.shouldNotifyWhenMalicious()) {
              showTrayPopup(filePath, cr);
            }
          }
        }
        check.reset();
      }
    } catch (IOException ex) {
      logger.exception(ex);
    }
  }

  public enum WhitelistResult {
    INVALID_FILE, NOT_WHITELISTED, WHITELISTED;
  }

  private WhitelistResult isFileWhitelisted(Path file) {
    try {
      if (file == null || Files.size(file) == 0) {
        return WhitelistResult.INVALID_FILE;
      }
      String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file));
      WhitelistResult result = isChecksumWhitelisted(fileChecksum);
      if (result == WhitelistResult.WHITELISTED) {
        logger.info(I18n.tl("probably_safe", file.getFileName().toString()));
      }
      return result;
    } catch (IOException e) {
      logger.exception(e);
    }
    return WhitelistResult.NOT_WHITELISTED;
  }

  public void addFileToQueue(Path file) {
    if (Files.isDirectory(file)) {
      addDirectoryToQueue(file);
      return;
    }
    SCANNABLE_FILES.add(file);
    if (executorService == null) {
      executorService = new ThreadPoolExecutor(4, Runtime.getRuntime().availableProcessors(), 10, TimeUnit.SECONDS,
              new ArrayBlockingQueue<>(50000));
      executorService.allowCoreThreadTimeOut(true);
    }
    executorService.execute(this);
  }

  public void addDirectoryToQueue(Path dir) {
    if (!Files.isDirectory(dir)) {
      return;
    }
    try {
      Files.list(dir).forEach(this::addFileToQueue);
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  public boolean awaitTermination(int time, TimeUnit unit) {
    try {
      return executorService.awaitTermination(time, unit);
    } catch (InterruptedException e) {
    }
    return false;
  }

  private WhitelistResult isChecksumWhitelisted(String checksum) {
    return main.getDatabase().isChecksumWhitelisted(checksum) ? WhitelistResult.WHITELISTED : WhitelistResult.NOT_WHITELISTED;
  }

  // TODO: Add linux support for pop-ups, most likely will have to move to native code to achieve that
  //That's what this method will do once implemented
//  private native void showTrapPopup(String fullFileName, CheckResult result);
  private void showTrayPopup(String fullFileName, CheckResult result) {
    String os = System.getProperty("os.name").toLowerCase();
    if (SystemTray.isSupported() && os.contains("win")) {
      SystemTray tray = SystemTray.getSystemTray();
      Image image = Toolkit.getDefaultToolkit().createImage(Main.class.getResource("/index.jpg"));
      TrayIcon trayIcon = new TrayIcon(image, "Malware Detected");
      trayIcon.setImageAutoSize(true);
      trayIcon.setToolTip(I18n.tl("might_be_infected_tool_tip", fullFileName));
      try {
        tray.add(trayIcon);
        trayIcon.displayMessage(I18n.tl("malware_detected_tool_tip_title"), I18n.tl("might_be_infected_tool_tip_text",
                fullFileName, result.getPlatform(), result.getType(), result.getFamily(), result.getVariant(), result.getClassNodePath()), TrayIcon.MessageType.WARNING);
      } catch (AWTException ex) {
        logger.exception(ex);
      }
      ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
      executor.schedule(() -> tray.remove(trayIcon), 4, TimeUnit.MINUTES);
    }
  }

  public enum Status {
    SCANNING, WAITING, NOT_RUNNING;
  }

  public Status getStatus() {
    if (executorService == null) {
      return Status.NOT_RUNNING;
    } else if (executorService.getTaskCount() == 0) {
      return Status.WAITING;
    } else {
      return Status.SCANNING;
    }
  }

  public File getScanDirectory() {
    return scanDirectory;
  }

}
