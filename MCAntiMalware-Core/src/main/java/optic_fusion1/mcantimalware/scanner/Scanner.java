package optic_fusion1.mcantimalware.scanner;

import java.awt.AWTException;
import java.awt.Image;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Iterator;
import java.util.List;
import java.util.PriorityQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.zip.ZipFile;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.IOUtils;

import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.configuration.file.FileConfiguration;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.utils.FileSizeComparator;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.Utils;
import optic_fusion1.mcantimalware.utils.ZipUtils;

//TODO: Re-Implement Auto-Updater and RealTimeScanner
public class Scanner extends Thread {

  private final Main main;
  private final CustomLogger logger;
  private final File scanDirectory;
  private File serverJar;
  private String fileInfo = "";
  private boolean firstScan = true;
  private final CheckManager checkManager;
  private FileConfiguration checksumDatabase;
  private Status status = Status.WAITING;
  //TODO: Fully implement the queueing system
  private PriorityQueue queue = new PriorityQueue();
  private CommandLineParser commandLineParser;

  public enum Status {
    SCANNING,
    WAITING;
  }

  public Scanner(Main main, File scanDirectory) {
    this.main = main;
    this.logger = main.getLogger();
    checkManager = main.getCheckManager();
    commandLineParser = main.getCommandLineParser();
    checksumDatabase = main.getChecksumDatabase();
    this.scanDirectory = scanDirectory;
  }

  @Override
  public void run() {
    //TODO: Re-look into this loop
    while (true) {
      if (firstScan && status == Status.WAITING) {
        status = Status.SCANNING;
        scanFiles();
        status = Status.WAITING;
        firstScan = false;
      }
      if (status == Status.WAITING && !queue.isEmpty()) {
        status = Status.SCANNING;
        //TODO: Could possibly be optimized or done better
        Iterator<File> iterator = queue.iterator();
        while (iterator.hasNext()) {
          scanFile(iterator.next().toPath());
          iterator.remove();
        }
        status = Status.WAITING;
      }
      if (status == Status.WAITING && main.getCommandLineParser().singleScan()) {
        try {
          join();
          main.join();
          System.exit(0);
        } catch (InterruptedException ex) {
          logger.exception(ex);
        }
      }
    }
  }

  public void scanFiles() {
	FileSizeComparator comparator = new FileSizeComparator();
	logger.info(I18n.tl("scan_start"));
	try {
		Files.walk(scanDirectory.toPath()).filter(Files::isRegularFile).sorted(comparator)
				.forEachOrdered(this::scanFile);
	} catch (IOException e) {
		logger.exception(e);
	}
	logger.info(I18n.tl("scan_end"));
  }

  public void scanDirectory(Path directory) {
	if (!Files.isDirectory(directory)) {
		scanFile(directory);
		return;
	}
	try {
		Files.list(directory).forEach((path) -> {
			if (Files.isDirectory(path)) {
				scanDirectory(directory);
			} else {
				scanFile(path);
			}
		});
	} catch (IOException e) {
		logger.exception(e);
	}
  }

  public void scanFile(Path file) {
		if (Files.isDirectory(file)) {
			scanDirectory(file);
			return;
		}
		try {
			if (Files.size(file) == 0) {
				return;
			}
		} catch (IOException e) {
			logger.exception(e);
			return;
		}
		String fileName = file.getFileName().toString();
		if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar")
				|| fileName.equals("MCAntiMalware.jar")) {
			return;
		}
		String filePath = file.toString();

		try (FileSystem fs = FileSystems.newFileSystem(file, null)) {

			Path rootFolder = fs.getRootDirectories().iterator().next();

			if (commandLineParser.shouldScanZippedFiles()) {
				if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
					scanDirectory(rootFolder);
					return;
				}
			}
			WhitelistResult result = isFileWhitelisted(file, rootFolder);
			if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED
					|| result == WhitelistResult.BLACKLISTED_AUTHOR) {
				return;
			}
			for (BaseCheck check : checkManager.getChecks()) {
				try {
					check.process(rootFolder, file);
				} catch (Exception e) {
					logger.exception(e);
					continue;
				}
				if (!(check.getScore() >= check.getThreshold())) {
					if (commandLineParser.shouldPrintNotInfectedMessages()) {
						logger.info(I18n.tl("might_not_be_infected",
								(fileInfo != null && fileInfo.isEmpty() ? "" : fileInfo + "#") + fileName,
								check.getLogName(), check.getType()));
					}
				} else {
					logger.detected(I18n.tl("might_be_infected",
							(fileInfo != null && fileInfo.isEmpty() ? "" : fileInfo + "#") + fileName,
							check.getLogName(), check.getType(), check.getClassNodePath(),
							(check.getLine() > -1 ? check.getLine() : "none"),
							(!check.getSourceFilePath().isEmpty() ? check.getSourceFilePath() : "none")));
					if (commandLineParser.shouldNotifyWhenMalicious()) {
						showTrayPopup(filePath, check);
					}
				}
				check.reset();
				fileInfo = "";
			}
		} catch (IOException ex) {
			logger.exception(ex);
		}
  }

  public enum WhitelistResult {
    INVALID_FILE,
    NO_PLUGIN_YML,
    INVALID_PLUGIN_YML,
    NOT_WHITELISTED,
    WHITELISTED,
    BLACKLISTED_AUTHOR,
    NOT_SET;
  }

  private WhitelistResult isFileWhitelisted(Path file, Path rootFolder) {
	try {
		if (file == null || Files.size(file) == 0) {
			return WhitelistResult.INVALID_FILE;
		}
		if (checksumDatabase == null) {
			return WhitelistResult.NOT_WHITELISTED;
		}
		String fileName = file.getFileName().toString();
		if (serverJar != null && fileName.equals(serverJar.getName())) {
			return WhitelistResult.NOT_WHITELISTED;
		}
		Path pluginYML = rootFolder.resolve("plugin.yml");
		if (!Files.exists(pluginYML)) {
			logger.info(I18n.tl("has_no_plugin_yml", fileName));
			return WhitelistResult.NO_PLUGIN_YML;
		}
		try (InputStream is = Files.newInputStream(pluginYML)) {
			FileConfiguration config = null;
			try {
				config = YamlConfiguration.loadConfiguration(is);
			} catch (Exception e) {
				return WhitelistResult.NOT_WHITELISTED;
			}
			if (!config.isSet("author") && !config.isSet("name")) {
				return WhitelistResult.INVALID_PLUGIN_YML;
			}
			List<String> authors = Utils.getAuthors(config);
		    for (BaseCheck check : checkManager.getChecks()) {
		    	for (String blacklistedAuthor : check.getBlacklistedAuthors()) {
		    		if (authors.contains(blacklistedAuthor)) {
		    			logger.detected(I18n.tl("might_be_infected",
		                    (fileInfo != null && fileInfo.isEmpty() ? "" : fileInfo + "#") + fileName,
		                    check.getLogName(),
		                    check.getType(),
		                    check.getClassNodePath(),
		                    (check.getLine() > -1 ? check.getLine() : "none"),
		                    (!check.getSourceFilePath().isEmpty() ? check.getSourceFilePath() : "none")));
		    			if (commandLineParser.shouldNotifyWhenMalicious()) {
		    				showTrayPopup(file.toString(), check);
		    			}
		    			return WhitelistResult.BLACKLISTED_AUTHOR;
		            }
		        }
		    }
		    String name = config.isSet("name") ? config.getString("name").replaceAll(" ", "-").replaceAll("\\.", "-") : null;
		    if (name == null) {
		    	return WhitelistResult.INVALID_PLUGIN_YML;
		    }
		    String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file));
		    WhitelistResult result = isChecksumWhitelisted(fileChecksum, authors.get(0) + "." + name);
		    if (result == WhitelistResult.NOT_SET) {
		    	result = isChecksumWhitelisted(fileChecksum, name);
		    }
		    if (result == WhitelistResult.WHITELISTED) {
		    	logger.info(I18n.tl("probably_safe", file.getFileName().toString()));
		    }
		    return result;
		}
	} catch (IOException ex) {
		logger.exception(ex);
	}
	return WhitelistResult.NOT_WHITELISTED;
  }

  private WhitelistResult isChecksumWhitelisted(String checksum, String path) {
    if (!checksumDatabase.isSet(path)) {
      return WhitelistResult.NOT_SET;
    }
    List<String> checksums = checksumDatabase.getStringList(path);
    if (checksums.contains(checksum)) {
      return WhitelistResult.WHITELISTED;
    }
    return WhitelistResult.NOT_WHITELISTED;
  }

  //TODO: Add linux support for pop-ups, most likely will have to move to native code to achieve that
  private void showTrayPopup(String fullFileName, BaseCheck check) {
    String os = System.getProperty("os.name").toLowerCase();
    if (SystemTray.isSupported() && os.contains("win")) {
      SystemTray tray = SystemTray.getSystemTray();
      Image image = Toolkit.getDefaultToolkit().createImage(Main.class.getResource("/index.jpg"));
      TrayIcon trayIcon = new TrayIcon(image, "Malware Detected");
      trayIcon.setImageAutoSize(true);
      trayIcon.setToolTip(I18n.tl("might_be_infected_tool_tip", fullFileName));
      try {
        tray.add(trayIcon);
        trayIcon.displayMessage(
                I18n.tl("malware_detected_tool_tip_title"),
                I18n.tl("might_be_infected_tool_tip_text",
                        fullFileName,
                        check.getName(),
                        check.getType(),
                        check.getClassNodePath()),
                TrayIcon.MessageType.WARNING);
      } catch (AWTException ex) {
        logger.exception(ex);
      }
      ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
      executor.schedule(() -> tray.remove(trayIcon), 4, TimeUnit.MINUTES);
    }
  }

  public void addFileToQueue(File file) {
    queue.add(file);
  }

  public void reloadChecksumDatabase() {
    logger.info(I18n.tl("updating_local_checksum_database"));
    checksumDatabase = main.getChecksumDatabase();
    logger.info(I18n.tl("updated_local_checksum_database"));
  }

  public File getScanDirectory() {
    return scanDirectory;
  }

  public Status getStatus() {
    return status;
  }

}
