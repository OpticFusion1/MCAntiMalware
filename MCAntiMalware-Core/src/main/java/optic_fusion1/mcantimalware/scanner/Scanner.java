package optic_fusion1.mcantimalware.scanner;

import java.awt.AWTException;
import java.awt.Image;
import java.awt.SystemTray;
import java.awt.Toolkit;
import java.awt.TrayIcon;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.List;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.lang.StringUtils;

import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.configuration.file.FileConfiguration;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.utils.FileSizeComparator;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.Utils;

//TODO: Re-Implement Auto-Updater and RealTimeScanner
public class Scanner implements Runnable {

  private Queue<Path> scannableFiles = new ConcurrentLinkedQueue<Path>();

  private ThreadPoolExecutor executorService;

  private final Main main;
  private final CustomLogger logger;
  private final File scanDirectory;
  private final CheckManager checkManager;
  private HashMap<String, String[]> checksumDatabase = new HashMap<>();
  private CommandLineParser commandLineParser;

  public Scanner(Main main, File scanDirectory) {
	this.main = main;
	this.logger = main.getLogger();
	checkManager = main.getCheckManager();
	commandLineParser = main.getCommandLineParser();
	reloadChecksumDatabase();
	this.scanDirectory = scanDirectory;
  }

  public void run() {
	try {
	  Path file = scannableFiles.remove();
	  if (file == null)
		return;
	  scanFile(file);
	} catch (Exception e) {
	  logger.exception(e);
	}
  }

  public void scanFiles() {
	FileSizeComparator comparator = new FileSizeComparator();
	logger.info(I18n.tl("scan_start"));
	try {
	  Files.walk(scanDirectory.toPath()).filter(Files::isRegularFile).sorted(comparator)
		  .forEachOrdered(this::addFileToQueue);
	} catch (IOException e) {
	  logger.exception(e);
	}
  }

  private void scanDirectory(Path directory) {
	if (!Files.isDirectory(directory)) {
	  scanFile(directory);
	  return;
	}
	try {
	  Files.list(directory).forEach((path) -> {
		if (Files.isDirectory(path)) {
		  scanDirectory(directory);
		} else {
		  scanFile(path);
		}
	  });
	} catch (IOException e) {
	  logger.exception(e);
	}
  }

  private void scanFile(Path file) {
	if (Files.isDirectory(file)) {
	  scanDirectory(file);
	  return;
	}
	try {
	  if (Files.size(file) == 0) {
		return;
	  }
	} catch (IOException e) {
	  logger.exception(e);
	  return;
	}
	String fileName = file.getFileName().toString();
	if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar")) {
	  return;
	}
	String filePath = file.toString();

	try (FileSystem fs = FileSystems.newFileSystem(file, null)) {

	  Path rootFolder = fs.getRootDirectories().iterator().next();

	  if (commandLineParser.shouldScanZippedFiles()) {
		if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
		  scanDirectory(rootFolder);
		  return;
		}
	  }
	  WhitelistResult result = isFileWhitelisted(file);
	  if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED) {
		return;
	  }
	  for (BaseCheck check : checkManager.getChecks()) {
		try {
		  check.process(rootFolder, file);
		} catch (Exception e) {
		  logger.exception(e);
		  continue;
		}
		if (check.getScore() < check.getThreshold()) {
		  if (commandLineParser.shouldPrintNotInfectedMessages()) {
			logger.info(I18n.tl("might_not_be_infected", fileName, check.getLogName(), check.getType()));
		  }
		} else {
		  logger.detected(I18n.tl("might_be_infected", fileName, check.getLogName(), check.getType(),
			  check.getClassNodePath(), (check.getLine() > -1 ? check.getLine() : "none"),
			  (!check.getSourceFilePath().isEmpty() ? check.getSourceFilePath() : "none")));
		  if (commandLineParser.shouldNotifyWhenMalicious()) {
			showTrayPopup(filePath, check);
		  }
		}
		check.reset();
	  }
	} catch (IOException ex) {
	  logger.exception(ex);
	}
  }

  public enum WhitelistResult {
	INVALID_FILE, NOT_WHITELISTED, WHITELISTED;
  }

  private WhitelistResult isFileWhitelisted(Path file) {
	try {
	  if (file == null || Files.size(file) == 0) {
		return WhitelistResult.INVALID_FILE;
	  }
	  if (checksumDatabase == null) {
		return WhitelistResult.NOT_WHITELISTED;
	  }
	  String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file));
	  WhitelistResult result = isChecksumWhitelisted(fileChecksum);
	  if (result == WhitelistResult.WHITELISTED) {
		logger.info(I18n.tl("probably_safe", file.getFileName().toString()));
	  }
	  return result;
	} catch (IOException e) {
	  logger.exception(e);
	}
	return WhitelistResult.NOT_WHITELISTED;
  }

  public void addFileToQueue(Path file) {
	if (Files.isDirectory(file)) {
	  addDirectoryToQueue(file);
	  return;
	}
	scannableFiles.add(file);
	if (executorService == null) {
	  executorService = new ThreadPoolExecutor(4, Runtime.getRuntime().availableProcessors(), 10, TimeUnit.SECONDS,
		  new LinkedBlockingQueue<>(), (runnable) -> {
			Thread thread = new Thread(runnable);
			thread.setDaemon(true);
			return thread;
		  });
	}
	executorService.submit(this);
  }

  public void addDirectoryToQueue(Path dir) {
	if (!Files.isDirectory(dir))
	  return;
	try {
	  Files.list(dir).forEach(this::addFileToQueue);
	} catch (IOException e) {
	  logger.exception(e);
	}
  }

  public boolean awaitTermination(int time, TimeUnit unit) {
	try {
	  return executorService.awaitTermination(time, unit);
	} catch (InterruptedException e) {
	}
	return false;
  }

  private WhitelistResult isChecksumWhitelisted(String checksum) {
	synchronized (checksumDatabase) {
	  if (checksumDatabase.containsKey(checksum)) {
		return WhitelistResult.WHITELISTED;
	  }
	}
	return WhitelistResult.NOT_WHITELISTED;
  }

  public void reloadChecksumDatabase() {
	synchronized (checksumDatabase) {
	  logger.info(I18n.tl("updating_local_checksum_database"));
	  checksumDatabase = new HashMap<>();
	  FileConfiguration database = main.getChecksumDatabase();
	  database.getKeys(true).stream().filter((path) -> StringUtils.countMatches(path, ".") == 2).forEach((path) -> {
		List<String> checksumList = database.getStringList(path);
		for (String checksum : checksumList) {
		  checksumDatabase.put(checksum, new String[] { path.split(".")[0], path.split(".")[1] });
		}
	  });
	  logger.info(I18n.tl("updated_local_checksum_database"));
	}
  }

  // TODO: Add linux support for pop-ups, most likely will have to move to native
  // code to achieve that
  private void showTrayPopup(String fullFileName, BaseCheck check) {
	String os = System.getProperty("os.name").toLowerCase();
	if (SystemTray.isSupported() && os.contains("win")) {
	  SystemTray tray = SystemTray.getSystemTray();
	  Image image = Toolkit.getDefaultToolkit().createImage(Main.class.getResource("/index.jpg"));
	  TrayIcon trayIcon = new TrayIcon(image, "Malware Detected");
	  trayIcon.setImageAutoSize(true);
	  trayIcon.setToolTip(I18n.tl("might_be_infected_tool_tip", fullFileName));
	  try {
		tray.add(trayIcon);
		trayIcon.displayMessage(I18n.tl("malware_detected_tool_tip_title"), I18n.tl("might_be_infected_tool_tip_text",
			fullFileName, check.getName(), check.getType(), check.getClassNodePath()), TrayIcon.MessageType.WARNING);
	  } catch (AWTException ex) {
		logger.exception(ex);
	  }
	  ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
	  executor.schedule(() -> tray.remove(trayIcon), 4, TimeUnit.MINUTES);
	}
  }

  public enum Status {
	SCANNING, WAITING, NOT_RUNNING;
  }

  public Status getStatus() {
	if (executorService == null) {
	  return Status.NOT_RUNNING;
	} else if (executorService.getTaskCount() == 0) {
	  return Status.WAITING;
	} else {
	  return Status.SCANNING;
	}
  }

  public File getScanDirectory() {
	return scanDirectory;
  }

}
