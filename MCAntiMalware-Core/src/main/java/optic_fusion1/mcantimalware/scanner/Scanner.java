package optic_fusion1.mcantimalware.scanner;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import net.lingala.zip4j.ZipFile;
import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import static optic_fusion1.mcantimalware.Main.LOGGER;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CacheContainer;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.check.CheckResult;
import optic_fusion1.mcantimalware.database.AntiMalwareDatabase;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.notification.NotificationHandler;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.Utils;
import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.FileUtils;

//TODO: Correct class messages and add translations for untranslated messages
//TODO: Look into Optimizing this class
public abstract class Scanner implements Runnable {

  private static final Queue<Path> SCANNABLE_FILES = new ConcurrentLinkedQueue<>();
  private ThreadPoolExecutor executorService;
  protected final Main main;
  protected final CustomLogger logger;
  protected final File scanDirectory;
  protected final CheckManager checkManager;
  protected final CommandLineParser commandLineParser;
  private NotificationHandler notificationHandler;
  private AntiMalwareDatabase database;
  protected File unzipDirectory;
  private Path zippedFilePath;

  public Scanner(Main main, File scanDirectory) {
    this.main = main;
    database = main.getDatabase();
    this.logger = main.getLogger();
    checkManager = main.getCheckManager();
    commandLineParser = main.getCommandLineParser();
    if (commandLineParser.shouldScanZippedFiles()) {
      unzipDirectory = new File(main.getDataFolder(), "unzipped");
      if (!unzipDirectory.exists()) {
        unzipDirectory.mkdirs();
      }
    }
    this.scanDirectory = scanDirectory;
    notificationHandler = main.getNotificationHandler();
  }

  @Override
  public void run() {
    try {
      Path file = SCANNABLE_FILES.remove();
      if (file == null) {
        return;
      }
      scanFile(file);
    } catch (Exception e) {
      logger.exception(e);
    }
    if (SCANNABLE_FILES.size() % 100 == 0) {
      System.out.println(I18n.tl("scanner_remaining_files", SCANNABLE_FILES.size()));
    }
  }

  public void scanFiles() {
    logger.info(I18n.tl("scanner_scan_start"));
    try {
      Files.walk(scanDirectory.toPath()).filter(Files::isRegularFile)
              .forEachOrdered(this::addFileToQueue);
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  // TODO: Come up with a better way of handling zipped files
  private void scanZip(Path zippedFile) {
    LOGGER.info("Unzipping " + zippedFile);
    File destination = new File(unzipDirectory, UUID.randomUUID().toString());
    zippedFilePath = zippedFile;
    if (!destination.exists()) {
      destination.mkdirs();
    }
    try {
      ZipFile zipFile = new ZipFile(zippedFile.toString());
      zipFile.extractAll(destination.toString());
      File file = new File(destination, ".info");
      file.createNewFile();
      try (PrintWriter pw = new PrintWriter(file)) {
        pw.write(zippedFile.toString());
      }
      for (File foundDir : destination.listFiles()) {
        if (foundDir.isDirectory()) {
          scanDirectory(foundDir.toPath());
          continue;
        }
        scanFile(foundDir.toPath());
      }
    } catch (IOException ex) {
      LOGGER.exception(ex);
    }
  }

  private void scanDirectory(Path directory) {
    if (!Files.isDirectory(directory)) {
      scanFile(directory);
      return;
    }
    try {
      Files.list(directory).forEach((path) -> {
        if (path.getFileSystem().isOpen()) {
          if (Files.isDirectory(path)) {
            scanDirectory(path);
          } else {
            scanFile(path);
          }
        }
      });
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  private void scanFile(Path file) {
    if (Files.isDirectory(file)) {
      scanDirectory(file);
      return;
    }
    String fileName = file.getFileName().toString();
    if (database.isFileNameBlacklisted(fileName)) {
      CheckResult result = database.blacklistedFileNameToCheckResult(fileName);
      if (result != null) {
        sendNotification(file.toAbsolutePath(), result);
      }
      return;
    }
    if (database.isFilePathBlacklisted(file.toString())) {
      CheckResult result = database.blacklistedFilePathToCheckResult(file.toString());
      if (result != null) {
        sendNotification(file.toAbsolutePath(), result);
      }
      return;
    }
    if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar")) {
      return;
    }
    try {
      if (Files.size(file) == 0) {
        return;
      }
    } catch (IOException e) {
      logger.exception(e);
      return;
    }
    try (FileSystem fs = Utils.fileSystemForZip(file)) {
      if (fs == null) {
        return;
      }
      Path rootFolder = fs.getRootDirectories().iterator().next();
      if (commandLineParser.shouldScanZippedFiles()) {
        if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
          scanZip(file);
          return;
        }
      }
      WhitelistResult result = isFileWhitelisted(file);
      if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED) {
        return;
      }
      CacheContainer ccc = new CacheContainer(); // TODO: Check to see if this can be handled better
      for (BaseCheck check : checkManager.getChecks()) {
        List<CheckResult> results;
        try {
          results = check.process(rootFolder, file, ccc);
          //TODO: Add a Metric (and measurements) showing how many of each malware type was found
          if (results != null && !results.isEmpty()) {
            results.stream().forEachOrdered(checkResult -> {
              if (file.startsWith("AntiMalware\\unzipped")) {
                File info = new File(file.toFile().getAbsoluteFile().getParent(), ".info");
                if (info.exists()) {
                  try {
                    String originalFile = FileUtils.readLines(info, StandardCharsets.UTF_8).get(0);
                    sendNotification(file, checkResult);
                    sendNotification(new File(originalFile).toPath(), checkResult);
                  } catch (IOException ex) {
                    LOGGER.exception(ex);
                  }
                }
              } else {
                sendNotification(file, checkResult);
              }
            });
          }
        } catch (Exception e) {
          logger.exception(e);
          continue;
        }
        check.reset();
      }
      if (zippedFilePath != null) {
        zippedFilePath = null;
      }
    } catch (IOException ex) {
      logger.exception(ex);
    }
  }

  public enum WhitelistResult {
    INVALID_FILE, NOT_WHITELISTED, WHITELISTED;
  }

  private WhitelistResult isFileWhitelisted(Path file) {
    try {
      if (file == null || Files.size(file) == 0) {
        return WhitelistResult.INVALID_FILE;
      }
      try {
        Path avPath = new File(Main.class.getProtectionDomain().getCodeSource().getLocation().toURI()).toPath();
        if (file == avPath) {
          return WhitelistResult.WHITELISTED;
        }
      } catch (Exception ex) {
        return WhitelistResult.INVALID_FILE;
      }
      String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file));
      WhitelistResult result = isChecksumWhitelisted(fileChecksum);
      if (result == WhitelistResult.WHITELISTED && commandLineParser.shouldPrintNotInfectedMessages()) {
        logger.info(I18n.tl("scanner_probably_safe_whitelisted", file.getFileName().toString()));
      }
      return result;
    } catch (IOException e) {
      logger.exception(e);
    }
    return WhitelistResult.NOT_WHITELISTED;
  }

  public void addFileToQueue(Path file) {
    if (Files.isDirectory(file)) {
      addDirectoryToQueue(file);
      return;
    }
    SCANNABLE_FILES.add(file);
    if (executorService == null) {
      executorService = new ThreadPoolExecutor(4, Math.max(Runtime.getRuntime().availableProcessors(), 4), 10,
              TimeUnit.SECONDS, new ArrayBlockingQueue<>(50000));
      executorService.allowCoreThreadTimeOut(true);
    }
    executorService.execute(this);
  }

  public void addDirectoryToQueue(Path dir) {
    if (!Files.isDirectory(dir)) {
      return;
    }
    try {
      Files.list(dir).forEach(this::addFileToQueue);
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  public boolean awaitTermination(int time, TimeUnit unit) {
    try {
      return executorService.awaitTermination(time, unit);
    } catch (InterruptedException e) {
    }
    return false;
  }

  private WhitelistResult isChecksumWhitelisted(String checksum) {
    return main.getDatabase().isChecksumWhitelisted(checksum) ? WhitelistResult.WHITELISTED
            : WhitelistResult.NOT_WHITELISTED;
  }

  public enum Status {
    SCANNING, WAITING, NOT_RUNNING;
  }

  public Status getStatus() {
    if (executorService == null) {
      return Status.NOT_RUNNING;
    } else if (executorService.getTaskCount() == 0) {
      return Status.WAITING;
    } else {
      return Status.SCANNING;
    }
  }

  public File getScanDirectory() {
    return scanDirectory;
  }

  public Main getMain() {
    return main;
  }

  public void sendNotification(Path path, CheckResult result) {
    // TODO: Make these translatable
    Objects.requireNonNull(path, "Path cannot be null");
    Objects.requireNonNull(result, "CheckResult cannot be null");
    notificationHandler.sendNotification(path, result);
  }

}
