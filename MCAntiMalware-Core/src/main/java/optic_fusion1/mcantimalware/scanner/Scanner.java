package optic_fusion1.mcantimalware.scanner;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Objects;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.zip.ZipError;
import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CacheContainer;
import optic_fusion1.mcantimalware.check.CheckManager;
import optic_fusion1.mcantimalware.check.CheckResult;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.notification.NotificationHandler;
import optic_fusion1.mcantimalware.utils.FileSizeComparator;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.Utils;
import org.apache.commons.codec.digest.DigestUtils;

//TODO: Re-Implement Auto-Updater and RealTimeScanner
public abstract class Scanner implements Runnable {

  private static final Queue<Path> SCANNABLE_FILES = new ConcurrentLinkedQueue<>();
  private ThreadPoolExecutor executorService;
  protected final Main main;
  protected final CustomLogger logger;
  protected final File scanDirectory;
  protected final CheckManager checkManager;
  protected final CommandLineParser commandLineParser;
  private NotificationHandler notificationHandler;

  public Scanner(Main main, File scanDirectory) {
    this.main = main;
    this.logger = main.getLogger();
    checkManager = main.getCheckManager();
    commandLineParser = main.getCommandLineParser();
    this.scanDirectory = scanDirectory;
    notificationHandler = main.getNotificationHandler();
  }

  @Override
  public void run() {
    try {
      Path file = SCANNABLE_FILES.remove();
      if (file == null) {
        return;
      }
      scanFile(file);
    } catch (Exception e) {
      logger.exception(e);
    }
    if (SCANNABLE_FILES.size() % 100 == 0) {
      System.out.println(I18n.tl("remaining_files", SCANNABLE_FILES.size()));
    }
  }

  public void scanFiles() {
    FileSizeComparator comparator = new FileSizeComparator();
    logger.info(I18n.tl("scan_start"));
    try {
      Files.walk(scanDirectory.toPath()).filter(Files::isRegularFile).sorted(comparator)
              .forEachOrdered(this::addFileToQueue);
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  private void scanDirectory(Path directory) {
    if (!Files.isDirectory(directory)) {
      scanFile(directory);
      return;
    }
    try {
      Files.list(directory).forEach((path) -> {
        //temp fix for the following exception
        //java.nio.file.ClosedFileSystemException
        if (path.getFileSystem().isOpen()) {
          if (Files.isDirectory(path)) {
            scanDirectory(path);
          } else {
            scanFile(path);
          }
        }
      });
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  private void scanFile(Path file) {
    if (Files.isDirectory(file)) {
      scanDirectory(file);
      return;
    }
    try {
      if (Files.size(file) == 0) {
        return;
      }
    } catch (IOException e) {
      logger.exception(e);
      return;
    }
    String fileName = file.getFileName().toString();
    if (!fileName.endsWith(".jar") && !fileName.endsWith(".zip") && !fileName.endsWith(".rar")) {
      return;
    }
    try (FileSystem fs = Utils.fileSystemForZip(file)) {

      Path rootFolder = fs.getRootDirectories().iterator().next();

      if (commandLineParser.shouldScanZippedFiles()) {
        if (fileName.endsWith(".zip") || fileName.endsWith(".rar")) {
          scanDirectory(rootFolder);
          return;
        }
      }
      WhitelistResult result = isFileWhitelisted(file);
      if (result == WhitelistResult.INVALID_FILE || result == WhitelistResult.WHITELISTED) {
        return;
      }
      CacheContainer ccc = new CacheContainer();
      for (BaseCheck check : checkManager.getChecks()) {
        List<CheckResult> results;
        try {
          results = check.process(rootFolder, file, ccc);
        } catch (Exception e) {
          logger.exception(e);
          continue;
        }
        if (results != null && !results.isEmpty()) {
          for (CheckResult checkResult : results) {
            logger.detected(I18n.tl("might_be_infected", file.toUri().toString(), checkResult.getPlatform(), checkResult.getType(), checkResult.getFamily(), checkResult.getVariant(), (!check.getClassNodePath().isEmpty() ? check.getClassNodePath() : "none"), (check.getLine() > -1 ? check.getLine() : "none"), (!check.getSourceFilePath().isEmpty() ? check.getSourceFilePath() : "none")));
            if (commandLineParser.shouldNotifyWhenMalicious()) {
              sendNotification(file, checkResult);
            }
          }
        }
        check.reset();
      }
    } catch (IOException ex) {
      logger.exception(ex);
    } catch(ZipError zip) {
    	logger.warn("[ERR] Zip File " + file.toString() + " can't be read!");
    }
  }

  public enum WhitelistResult {
    INVALID_FILE, NOT_WHITELISTED, WHITELISTED;
  }

  private WhitelistResult isFileWhitelisted(Path file) {
    try {
      if (file == null || Files.size(file) == 0) {
        return WhitelistResult.INVALID_FILE;
      }
      String fileChecksum = DigestUtils.sha1Hex(Files.newInputStream(file));
      WhitelistResult result = isChecksumWhitelisted(fileChecksum);
      if (result == WhitelistResult.WHITELISTED) {
        logger.info(I18n.tl("probably_safe", file.getFileName().toString()));
      }
      return result;
    } catch (IOException e) {
      logger.exception(e);
    }
    return WhitelistResult.NOT_WHITELISTED;
  }

  public void addFileToQueue(Path file) {
    if (Files.isDirectory(file)) {
      addDirectoryToQueue(file);
      return;
    }
    SCANNABLE_FILES.add(file);
    if (executorService == null) {
      executorService = new ThreadPoolExecutor(4, Runtime.getRuntime().availableProcessors(), 10, TimeUnit.SECONDS,
              new ArrayBlockingQueue<>(50000));
      executorService.allowCoreThreadTimeOut(true);
    }
    executorService.execute(this);
  }

  public void addDirectoryToQueue(Path dir) {
    if (!Files.isDirectory(dir)) {
      return;
    }
    try {
      Files.list(dir).forEach(this::addFileToQueue);
    } catch (IOException e) {
      logger.exception(e);
    }
  }

  public boolean awaitTermination(int time, TimeUnit unit) {
    try {
      return executorService.awaitTermination(time, unit);
    } catch (InterruptedException e) {
    }
    return false;
  }

  private WhitelistResult isChecksumWhitelisted(String checksum) {
    return main.getDatabase().isChecksumWhitelisted(checksum) ? WhitelistResult.WHITELISTED : WhitelistResult.NOT_WHITELISTED;
  }

  public enum Status {
    SCANNING, WAITING, NOT_RUNNING;
  }

  public Status getStatus() {
    if (executorService == null) {
      return Status.NOT_RUNNING;
    } else if (executorService.getTaskCount() == 0) {
      return Status.WAITING;
    } else {
      return Status.SCANNING;
    }
  }

  public File getScanDirectory() {
    return scanDirectory;
  }

  public Main getMain() {
    return main;
  }

  public void sendNotification(Path path, CheckResult result) {
    Objects.requireNonNull(path, "Path cannot be null");
    Objects.requireNonNull(result, "CheckResult cannot be null");
    notificationHandler.sendNotification(path, result);
  }

}
