package optic_fusion1.mcantimalware.utils.javaagent;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.MalformedURLException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.Arrays;
import java.util.Locale;

/**
 * Class path and class loader utilities to help java agent developers.
 *
 * @author Daniel Sperry
 */
public class ClassPathUtils {

  /**
   * Returns the path for the jar or directory that contains a given java class.
   *
   * @param clazz the class whose classpath entry needs to be located.
   * @return an url with the jar or directory that contains that class
   */
  public static URL getClassPathFor(final Class<?> clazz) {
    if (clazz == null) {
      throw new IllegalArgumentException("Null class");
    }
    try {
      final URL url = getClassFile(clazz);
      String urlString = url.toString();
      final int endIndex = urlString.indexOf("!");
      if (endIndex > 0) {
        // assuming it's something inside a jar
        int beginIndex = urlString.toLowerCase(Locale.ENGLISH).lastIndexOf("file:/");
        if (beginIndex >= 0) {
          return new URL(urlString.substring(beginIndex, endIndex));
        }
        beginIndex = urlString.lastIndexOf("[a-zA-Z]+://");
        if (beginIndex > 0) {
          return new URL(urlString.substring(beginIndex, endIndex));
        }
      } else {
        // assuming it's a file
        File dir = new File(url.toURI()).getParentFile();
        if (clazz.getPackage() != null) {
          String pn = clazz.getPackage().getName();
          for (int i = pn.indexOf('.'); i >= 0; i = pn.indexOf('.', i + 1)) {
            dir = dir.getParentFile();
          }
          dir = dir.getParentFile();
        }
        return dir.toURI().toURL();
      }
      throw new RuntimeException(
       "Error locating classpath entry for: " + clazz.getName() + " url: " + url);
    } catch (RuntimeException | MalformedURLException | URISyntaxException e) {
      throw new RuntimeException("Error locating classpath entry for: " + clazz.getName(), e);
    }
  }

  /**
   * Get the actual classpath resource location for a class
   *
   * @param clazz the class whose .class file must be located.
   * @return a resource url or null if the class is runtime generated.
   */
  public static URL getClassFile(final Class<?> clazz) {
    int idx = clazz.getName().lastIndexOf('.');
    final String fileName = (idx >= 0 ? clazz.getName().substring(idx + 1) : clazz.getName()) + ".class";
    return clazz.getResource(fileName);
  }

  /**
   * Appends a directory or jar to the system class loader.
   *
   * <p>
   * Do this only if you understand the consequences:
   *
   * <ul>
   * <li>classes loaded by different class loaders are different classes
   * <li>if the application uses the same classes the load order might create inconsistencies
   * </ul>
   *
   * @param path the url to append to the system class loader
   */
  public static void appendToSystemPath(URL path) {
    if (path == null) {
      throw new IllegalArgumentException("Null path");
    }
    try {
      ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
      final Method method = URLClassLoader.class.getDeclaredMethod("addURL", new Class[]{URL.class});
      method.setAccessible(true);
      method.invoke(systemClassLoader, path);
    } catch (IllegalAccessException
     | IllegalArgumentException
     | NoSuchMethodException
     | SecurityException
     | InvocationTargetException ex) {
      throw new RuntimeException("Add URL failed: " + path, ex);
    }
  }

  static byte[] toByteArray(InputStream input) throws IOException {
    byte[] buffer = new byte[Math.max(1024, input.available())];
    int offset = 0;
    for (int bytesRead; -1 != (bytesRead = input.read(buffer, offset, buffer.length - offset));) {
      offset += bytesRead;
      if (offset == buffer.length) {
        buffer = Arrays.copyOf(buffer, buffer.length + Math.max(input.available(), buffer.length >> 1));
      }
    }
    return (offset == buffer.length) ? buffer : Arrays.copyOf(buffer, offset);
  }

  public static Class<?> defineClass(ClassLoader loader, InputStream inputStream) {
    try {
      final byte[] bytes = toByteArray(inputStream);
      final Method defineClassMethod = ClassLoader.class.getDeclaredMethod("defineClass", String.class, byte[].class,
       int.class, int.class);
      defineClassMethod.setAccessible(true);
      return (Class<?>) defineClassMethod.invoke(loader, null, bytes, 0, bytes.length);
    } catch (IOException | IllegalAccessException | IllegalArgumentException
     | NoSuchMethodException | SecurityException | InvocationTargetException e) {
      throw new RuntimeException(e);
    }
  }
}
