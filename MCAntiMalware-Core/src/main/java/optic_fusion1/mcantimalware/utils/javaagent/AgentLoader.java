package optic_fusion1.mcantimalware.utils.javaagent;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.management.ManagementFactory;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.jar.Attributes;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import optic_fusion1.mcantimalware.AntiMalware;
import optic_fusion1.mcantimalware.AntiMalwareAPI;
import optic_fusion1.mcantimalware.logging.CustomLogger;

/**
 * Utilities to load java agents dynamically. Deals with the problem of finding the proper jvm classes.
 *
 * @author Daniel Sperry
 * @see java.lang.instrument.Instrumentation
 */
public class AgentLoader {

  private static volatile AgentLoaderInterface agentLoader;
  private static final CustomLogger LOGGER = AntiMalwareAPI.getInstance().getLogger();

  /**
   * Internal class.
   */
  // used internally, has to be public to be accessible from the shadeClassLoaders
  interface AgentLoaderInterface {

    void loadAgent(String agentJar, String options);
  }

  /**
   * Dynamically loads a java agent. Deals with the problem of finding the proper jvm classes.
   *
   * @param agentJar the agent jar
   * @param options options that will be passed back to the agent, can be null
   * @see java.lang.instrument.Instrumentation
   */
  public static void loadAgent(String agentJar, String options) {
    AgentLoaderInterface agentLoader = getAgentLoader(agentJar);
    agentLoader.loadAgent(agentJar, options);
  }

  /**
   * Creates a temporary jar and loads the agent class directly.The agent class must be visible from the system class loader.<p>
   * This method creates a temporary jar with the proper manifest and loads the agent using the jvm attach facilities.
   *
   * <p>
   * This will not work if the agent class can't be loaded by the system class loader. <br>
   * This can be worked around like by adding the specific class and any other dependencies to the system class loader:
   *
   * <pre><code>
   *     if(MyAgent.class.getClassLoader() != ClassLoader.getSystemClassLoader()) {
   *         ClassPathUtils.appendToSystemPath(ClassPathUtils.getClassPathFor(MyAgent.class));
   *         ClassPathUtils.appendToSystemPath(ClassPathUtils.getClassPathFor(OtherDepenencies.class));
   *     }
   *     loadAgent(MyAgent.class.getName(), null, null, true, true, false);
   * </code></pre>
   *
   * @param agentClassName the agent class name
   */
  public static void loadAgentClass(String agentClassName) {
    loadAgentClass(agentClassName, null, null, true, true, false);
  }

  /**
   * Creates a temporary jar and loads the agent class directly.
   *
   * <p>
   * This method creates a temporary jar with the proper manifest and loads the agent using the jvm attach facilities.
   *
   * <p>
   * This will not work if the agent class can't be loaded by the system class loader. <br>
   * This can be worked around like by adding the specific class and any other dependencies to the system class loader:
   *
   * <pre><code>
   *     if(MyAgent.class.getClassLoader() != ClassLoader.getSystemClassLoader()) {
   *         ClassPathUtils.appendToSystemPath(ClassPathUtils.getClassPathFor(MyAgent.class));
   *         ClassPathUtils.appendToSystemPath(ClassPathUtils.getClassPathFor(OtherDepenencies.class));
   *     }
   *     loadAgent(MyAgent.class.getName(), null, null, true, true, false);
   * </code></pre>
   *
   * @param agentClass the agent class
   * @param options options that will be passed back to the agent, can be null
   * @param bootClassPath list of jars to be loaded with the agent, can be null
   * @param canRedefineClasses if the ability to redefine classes is need by the agent, suggested default: false
   * @param canRetransformClasses if the ability to retransform classes is need by the agent, suggested default: false
   * @param canSetNativeMethodPrefix if the ability to set native method prefix is need by the agent, suggested default: false
   * @see ClassPathUtils
   * @see java.lang.instrument.Instrumentation
   */
  public static void loadAgentClass(
   final String agentClass,
   final String options,
   final String bootClassPath,
   final boolean canRedefineClasses,
   final boolean canRetransformClasses,
   final boolean canSetNativeMethodPrefix) {
    final File jarFile;
    try {
      jarFile = createTemporaryAgentJar(agentClass, bootClassPath, canRedefineClasses,
       canRetransformClasses, canSetNativeMethodPrefix);
    } catch (IOException ex) {
      throw new RuntimeException("Can't write jar file for agent:" + agentClass, ex);
    }
    loadAgent(jarFile.getPath(), options);
  }

  @SuppressWarnings("unchecked")
  private static synchronized AgentLoaderInterface getAgentLoader(final String agentJar) {
    if (agentLoader != null) {
      return agentLoader;
    }
    Class<AgentLoaderInterface> agentLoaderClass = null;
    try {
      Class.forName("com.sun.tools.attach.VirtualMachine");
      agentLoaderClass
       = (Class<AgentLoaderInterface>) Class.forName("optic_fusion1.mcantimalware.utils.javaagent.AgentLoaderHotSpot");
    } catch (ClassNotFoundException ex) {
      LOGGER.exception(ex);
    }
    try {
      Object agentLoaderObject = agentLoaderClass.newInstance();

      // the agent loader might be instantiated in another class loader
      // so no interface it implements is guaranteed to be visible here.
      // this reflection based implementation of this interface solves this problem.
      agentLoader = (final String agentJar1, final String options) -> {
        try {
          final Method loadAgentMethod
           = agentLoaderObject.getClass().getMethod("loadAgent", String.class, String.class);
          loadAgentMethod.invoke(agentLoaderObject, agentJar1, options);
        } catch (IllegalAccessException | IllegalArgumentException | NoSuchMethodException
         | SecurityException | InvocationTargetException e) {
          throw new RuntimeException(e);
        }
      };
    } catch (IllegalAccessException | InstantiationException e) {
      throw new RuntimeException(
       "Error getting agent loader implementation to load: " + agentJar, e);
    }
    return agentLoader;
  }

  /**
   * Gets the current jvm's pid.
   *
   * @return the pid as String
   */
  public static String getPid() {
    String nameOfRunningVM = ManagementFactory.getRuntimeMXBean().getName();
    int p = nameOfRunningVM.indexOf('@');
    return nameOfRunningVM.substring(0, p);
  }

  /**
   * Creates a jar in runtime with the proper manifest file to start the javaagent. 
   * This method is convenient to java agent developers since they can test their agents without creating a jar first.
   *
   * @param agentClass the agent class
   * @param bootClassPath list of jars to be loaded with the agent, can be null
   * @param canRedefineClasses if the ability to redefine classes is need by the agent, suggested default: false
   * @param canRetransformClasses if the ability to retransform classes is need by the agent, suggested default: false
   * @param canSetNativeMethodPrefix if the ability to set native method prefix is need by the agent, suggested default: false
   * @throws java.io.IOException
   */
  public static File createTemporaryAgentJar(final String agentClass, final String bootClassPath,
   final boolean canRedefineClasses, final boolean canRetransformClasses, final boolean canSetNativeMethodPrefix)
   throws IOException {
    final File jarFile = File.createTempFile("javaagent." + agentClass, ".jar");
    jarFile.deleteOnExit();
    createAgentJar(new FileOutputStream(jarFile), agentClass, bootClassPath, canRedefineClasses,
     canRetransformClasses, canSetNativeMethodPrefix);
    return jarFile;
  }

  /**
   * Creates an agent jar with the proper manifest file to start a javaagent.
   *
   * @param agentClass the agent class
   * @param bootClassPath list of jars to be loaded with the agent, can be null
   * @param canRedefineClasses if the ability to redefine classes is need by the agent, suggested default: false
   * @param canRetransformClasses if the ability to retransform classes is need by the agent, suggested default: false
   * @param canSetNativeMethodPrefix if the ability to set native method prefix is need by the agent, suggested default: false
   */
  public static void createAgentJar(final OutputStream out, final String agentClass, final String bootClassPath,
   final boolean canRedefineClasses, final boolean canRetransformClasses, final boolean canSetNativeMethodPrefix)
   throws IOException {
    final Manifest man = new Manifest();
    man.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
    man.getMainAttributes().putValue("Agent-Class", agentClass);
    if (bootClassPath != null) {
      man.getMainAttributes().putValue("Boot-Class-Path", bootClassPath);
    }
    man.getMainAttributes().putValue("Can-Redefine-Classes", Boolean.toString(canRedefineClasses));
    man.getMainAttributes().putValue("Can-Retransform-Classes", Boolean.toString(canRetransformClasses));
    man.getMainAttributes().putValue("Can-Set-Native-Method-Prefix", Boolean.toString(canSetNativeMethodPrefix));
    final JarOutputStream jarOut = new JarOutputStream(out, man);
    jarOut.flush();
    jarOut.close();
  }
}
