//package optic_fusion1.mcantimalware.utils.javaagent;
//
//import java.io.File;
//import java.io.FileOutputStream;
//import java.io.IOException;
//import java.io.OutputStream;
//import java.lang.management.ManagementFactory;
//import java.lang.reflect.InvocationTargetException;
//import java.lang.reflect.Method;
//import java.util.jar.Attributes;
//import java.util.jar.JarOutputStream;
//import java.util.jar.Manifest;
//import static optic_fusion1.mcantimalware.Main.LOGGER;
//import optic_fusion1.mcantimalware.utils.I18n;
//
///**
// * Utilities to load java agents dynamically. Deals with the problem of finding the proper jvm classes.
// *
// * @author Daniel Sperry
// * @see java.lang.instrument.Instrumentation
// */
//public final class AgentLoader {
//
//  private static volatile AgentLoaderInterface agentLoader;
//
//  private AgentLoader(){
//  
//  }
//  
//  /**
//   * Internal class.
//   */
//  // used internally, has to be public to be accessible from the shadeClassLoaders
//  interface AgentLoaderInterface {
//
//    void loadAgent(String agentJar, String options);
//  }
//
//  /**
//   * Dynamically loads a java agent. Deals with the problem of finding the proper jvm classes.
//   *
//   * @param agentJar the agent jar
//   * @param options options that will be passed back to the agent, can be null
//   * @see java.lang.instrument.Instrumentation
//   */
//  public static void loadAgent(String agentJar, String options) {
//    AgentLoaderInterface agentLoaderInterface = getAgentLoader(agentJar);
//    agentLoaderInterface.loadAgent(agentJar, options);
//  }
//
//  /**
//   * Creates a temporary jar and loads the agent class directly.The agent class must be visible from the system class loader.<p>
//   * This method creates a temporary jar with the proper manifest and loads the agent using the jvm attach facilities.
//   *
//   * <p>
//   * This will not work if the agent class can't be loaded by the system class loader. <br>
//   * This can be worked around like by adding the specific class and any other dependencies to the system class loader:
//   *
//   * <pre><code>
//   *     if(MyAgent.class.getClassLoader() != ClassLoader.getSystemClassLoader()) {
//   *         ClassPathUtils.appendToSystemPath(ClassPathUtils.getClassPathFor(MyAgent.class));
//   *         ClassPathUtils.appendToSystemPath(ClassPathUtils.getClassPathFor(OtherDepenencies.class));
//   *     }
//   *     loadAgent(MyAgent.class.getName(), null, null, true, true, false);
//   * </code></pre>
//   *
//   * @param agentClassName the agent class name
//   */
//  public static void loadAgentClass(String agentClassName) {
//    loadAgentClass(agentClassName, null, null, true, true, false);
//  }
//
//  /**
//   * Creates a temporary jar and loads the agent class directly.
//   *
//   * <p>
//   * This method creates a temporary jar with the proper manifest and loads the agent using the jvm attach facilities.
//   *
//   * <p>
//   * This will not work if the agent class can't be loaded by the system class loader. <br>
//   * This can be worked around like by adding the specific class and any other dependencies to the system class loader:
//   *
//   * <pre><code>
//   *     if(MyAgent.class.getClassLoader() != ClassLoader.getSystemClassLoader()) {
//   *         ClassPathUtils.appendToSystemPath(ClassPathUtils.getClassPathFor(MyAgent.class));
//   *         ClassPathUtils.appendToSystemPath(ClassPathUtils.getClassPathFor(OtherDepenencies.class));
//   *     }
//   *     loadAgent(MyAgent.class.getName(), null, null, true, true, false);
//   * </code></pre>
//   *
//   * @param agentClass the agent class
//   * @param options options that will be passed back to the agent, can be null
//   * @param bootClassPath list of jars to be loaded with the agent, can be null
//   * @param canRedefineClasses if the ability to redefine classes is need by the agent, suggested default: false
//   * @param canRetransformClasses if the ability to retransform classes is need by the agent, suggested default: false
//   * @param canSetNativeMethodPrefix if the ability to set native method prefix is need by the agent, suggested default: false
//   * @see ClassPathUtils
//   * @see java.lang.instrument.Instrumentation
//   */
//  public static void loadAgentClass(
//   final String agentClass,
//   final String options,
//   final String bootClassPath,
//   final boolean canRedefineClasses,
//   final boolean canRetransformClasses,
//   final boolean canSetNativeMethodPrefix) {
//    final File jarFile;
//    try {
//      jarFile = createTemporaryAgentJar(agentClass, bootClassPath, canRedefineClasses,
//       canRetransformClasses, canSetNativeMethodPrefix);
//    } catch (IOException ex) {
//      throw new RuntimeException(I18n.tl("cant_write_new_jar_file", agentClass), ex);
//    }
//    loadAgent(jarFile.getPath(), options);
//  }
//
//  @SuppressWarnings("unchecked")
//  private static synchronized AgentLoaderInterface getAgentLoader(final String agentJar) {
//    if (agentLoader != null) {
//      return agentLoader;
//    }
//    Class<AgentLoaderInterface> agentLoaderClass = null;
//    try {
//      Class.forName("com.sun.tools.attach.VirtualMachine");
//      agentLoaderClass
//       = (Class<AgentLoaderInterface>) Class.forName("optic_fusion1.mcantimalware.utils.javaagent.AgentLoaderHotSpot");
//    } catch (ClassNotFoundException ex) {
//      LOGGER.exception(ex);
//    }
//    try {
//      Object agentLoaderObject = agentLoaderClass.newInstance();
//
//      // the agent loader might be instantiated in another class loader
//      // so no interface it implements is guaranteed to be visible here.
//      // this reflection based implementation of this interface solves this problem.
//      agentLoader = (final String agentJar1, final String options) -> {
//        try {
//          final Method loadAgentMethod
//           = agentLoaderObject.getClass().getMethod("loadAgent", String.class, String.class);
//          loadAgentMethod.invoke(agentLoaderObject, agentJar1, options);
//        } catch (IllegalAccessException | IllegalArgumentException | NoSuchMethodException
//         | SecurityException | InvocationTargetException e) {
//          throw new RuntimeException(e);
//        }
//      };
//    } catch (IllegalAccessException | InstantiationException e) {
//      throw new RuntimeException(I18n.tl("implementation_load_error", agentJar), e);
//    }
//    return agentLoader;
//  }
//
//  /**
//   * Gets the current jvm's pid.
//   *
//   * @return the pid as String
//   */
//  public static String getPid() {
//    String nameOfRunningVM = ManagementFactory.getRuntimeMXBean().getName();
//    int p = nameOfRunningVM.indexOf('@');
//    return nameOfRunningVM.substring(0, p);
//  }
//
//  /**
//   * Creates a jar in runtime with the proper manifest file to start the javaagent.This method is convenient to java agent developers since they can test their agents without creating a jar first.
//   *
//   * @param agentClass the agent class
//   * @param bootClassPath list of jars to be loaded with the agent, can be null
//   * @param canRedefineClasses if the ability to redefine classes is need by the agent, suggested default: false
//   * @param canRetransformClasses if the ability to retransform classes is need by the agent, suggested default: false
//   * @param canSetNativeMethodPrefix if the ability to set native method prefix is need by the agent, suggested default: false
//   * @return 
//   * @throws java.io.IOException
//   */
//  public static File createTemporaryAgentJar(final String agentClass, final String bootClassPath,
//   final boolean canRedefineClasses, final boolean canRetransformClasses, final boolean canSetNativeMethodPrefix)
//   throws IOException {
//    final File jarFile = File.createTempFile("javaagent." + agentClass, ".jar");
//    jarFile.deleteOnExit();
//    createAgentJar(new FileOutputStream(jarFile), agentClass, bootClassPath, canRedefineClasses,
//     canRetransformClasses, canSetNativeMethodPrefix);
//    return jarFile;
//  }
//
//  /**
//   * Creates an agent jar with the proper manifest file to start a javaagent.
//   *
//   * @param out
//   * @param agentClass the agent class
//   * @param bootClassPath list of jars to be loaded with the agent, can be null
//   * @param canRedefineClasses if the ability to redefine classes is need by the agent, suggested default: false
//   * @param canRetransformClasses if the ability to retransform classes is need by the agent, suggested default: false
//   * @param canSetNativeMethodPrefix if the ability to set native method prefix is need by the agent, suggested default: false
//   * @throws java.io.IOException
//   */
//  public static void createAgentJar(final OutputStream out, final String agentClass, final String bootClassPath,
//   final boolean canRedefineClasses, final boolean canRetransformClasses, final boolean canSetNativeMethodPrefix)
//   throws IOException {
//    final Manifest man = new Manifest();
//    man.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
//    man.getMainAttributes().putValue("Agent-Class", agentClass);
//    if (bootClassPath != null) {
//      man.getMainAttributes().putValue("Boot-Class-Path", bootClassPath);
//    }
//    man.getMainAttributes().putValue("Can-Redefine-Classes", Boolean.toString(canRedefineClasses));
//    man.getMainAttributes().putValue("Can-Retransform-Classes", Boolean.toString(canRetransformClasses));
//    man.getMainAttributes().putValue("Can-Set-Native-Method-Prefix", Boolean.toString(canSetNativeMethodPrefix));
//    try (JarOutputStream jarOut = new JarOutputStream(out, man)) {
//      jarOut.flush();
//    }
//  }
//}
