package optic_fusion1.mcantimalware.check.impl;

import static optic_fusion1.mcantimalware.Main.LOGGER;

import java.nio.file.Path;
import java.util.Iterator;
import java.util.List;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CacheContainer;
import optic_fusion1.mcantimalware.check.CheckResult;
import optic_fusion1.mcantimalware.deobfuscator.StringDeobfuscator;

public class DirectLeaksCheck extends BaseCheck {

	public DirectLeaksCheck(Main main) {
		super(main);
	}

	@Override
	public List<CheckResult> process(Path rootFolder, Path zipFile, CacheContainer cache) {
		boolean found = walkThroughFiles(rootFolder).anyMatch((path) -> {
			if (path == null || path.getFileName() == null)
				return false;
			String name = path.getFileName().toString();
			if (name.equals("directleaks")) {
				return true;
			}
			if (validClassPath(path)) {
				ClassNode classNode = cache.fetchClass(path);
				if (classNode == null) {
					return false;
				}

				if (classNode.name.startsWith("directleaks")) {
					setClassNodePath(classNode.name);
					setSourceFilePath(classNode.sourceFile);
					return true;
				}
				List<MethodNode> nodes = classNode.methods;
				for (MethodNode methodNode : nodes) {
					for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
						if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
							String string = ((LdcInsnNode) insnNode).cst.toString();
							boolean xorv1 = containsBlacklistedWord(StringDeobfuscator.XORV1(string));
							boolean xorv2 = containsBlacklistedWord(StringDeobfuscator.XORV2(string));
							boolean xorv3 = containsBlacklistedWord(StringDeobfuscator.XORV3(string));
							boolean xorv4 = containsBlacklistedWord(StringDeobfuscator.decryptionArray(string));
							boolean sig = checkForDLSignature(classNode);
							boolean bootstrap1 = bootstrap1(classNode);
							boolean bootstrap2 = bootstrap2(classNode);
							boolean host = false;
							try {
								host = doesDLHostCheckExist(classNode);
							} catch (Throwable ex) {
								LOGGER.exception(ex);
							}
							if (xorv1 || xorv2 || xorv3 || xorv4 || host || sig || bootstrap1 || bootstrap2) {
								setClassNodePath(classNode.name);
								setSourceFilePath(classNode.sourceFile);
								return true;
							}
						} else if (insnNode instanceof LineNumberNode) {
							setLine(((LineNumberNode) insnNode).line);
						}
					}
				}
			}
			return false;
		});
		if (found) {
			return List.of(
					new CheckResult("Spigot", "MALWARE", "DirectLeaks", "A", getSourceFilePath(), getClassNodePath(), getLine()));
		}
		return List.of();
	}

	String[] blacklistedWords = new String[] { "#directleaks", "Please contact DirectLeaks. 0x2",
			"http://api.directleaks.net/api/directleaks", "[DirectLeaks] Error Code: 0x1", "Anti-Releak", "DirectLeaks",
			"vmi209890.contaboserver.net", "167.86.75.51", "#DirectLeaks Anti-Releak", "DirectLeaks-API",
			"de.xbrowniecodez.dlapi.Main", "de.xbrowniecodez.dlapi.HostsCheck" };

	public boolean containsBlacklistedWord(String string) {
		for (String blacklistedWord : blacklistedWords) {
			if (string.contains(blacklistedWord)) {
				return true;
			}
		}
		return false;
	}

	public static boolean doesDLHostCheckExist(ClassNode classNode) throws Throwable {
		try {
			Iterator<MethodNode> iterator = classNode.methods.iterator();
			while (iterator.hasNext()) {
				MethodNode attributeIterator = iterator.next();
				if (attributeIterator.name.equalsIgnoreCase("onEnable")) {
					InsnList attribute = attributeIterator.instructions;
					AbstractInsnNode insnNode = attribute.get(0);

					if (insnNode.getType() == 5 && insnNode.getOpcode() == 184 && ((MethodInsnNode) insnNode).desc.equals("()V")
							&& !((MethodInsnNode) insnNode).name.equalsIgnoreCase("loadConfig0")) {
						return true;
					}
				} else if (attributeIterator.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")
						&& attributeIterator.access == 4170) {
					return true;
				}
			}
		} catch (Exception e) {
			LOGGER.warn("DLHostCheck Error on " + classNode.name);
		}
		return false;
	}

	public static boolean checkForDLSignature(ClassNode classNode) {
		if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
				|| classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
			if (classNode.signature == null) {
				return false;
			}
			return classNode.signature.contains("directleaks");
		}
		return false;
	}

	public static boolean bootstrap1(ClassNode classNode) {
		Iterator<MethodNode> iterator = classNode.methods.iterator();
		while (iterator.hasNext()) {
			MethodNode methodNode = iterator.next();
			if (methodNode.desc.equalsIgnoreCase(
					"(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;")) {
				return true;
			}
		}
		return false;
	}

	public static boolean bootstrap2(ClassNode classNode) {
		if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
				|| classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
			for (FieldNode fieldNode : classNode.fields) {
				if (fieldNode.access == 9 && fieldNode.desc.equalsIgnoreCase("I") && fieldNode.name.length() == 36) {
					return true;
				} else if (fieldNode.access == 9 && fieldNode.desc.equalsIgnoreCase("Ljava/lang/String;")
						&& fieldNode.name.length() == 36) {
					return true;
				}
			}
		}
		return false;
	}
}
