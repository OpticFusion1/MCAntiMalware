package optic_fusion1.mcantimalware.check.impl;

import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import optic_fusion1.mcantimalware.Main;
import static optic_fusion1.mcantimalware.Main.LOGGER;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CacheContainer;
import optic_fusion1.mcantimalware.check.CheckResult;
import optic_fusion1.mcantimalware.deobfuscator.StringDeobfuscator;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public class DirectLeaksCheck extends BaseCheck {

  public DirectLeaksCheck(Main main) {
    super(main);
  }

  @Override
  public List<CheckResult> process(Path rootFolder, Path zipFile, CacheContainer cache) {
    boolean found = walkThroughFiles(rootFolder).anyMatch((path) -> {
      if (path == null || path.getFileName() == null) {
        return false;
      }
      String name = path.getFileName().toString();
      if (name.equals("directleaks")) {
        return true;
      }
      if (validClassPath(path)) {
        ClassNode classNode = cache.fetchClass(path);
        if (classNode == null) {
          return false;
        }

        if (classNode.name.startsWith("directleaks")) {
          setClassNodePath(classNode.name);
          setSourceFilePath(classNode.sourceFile);
          return true;
        }
        List<MethodNode> nodes = classNode.methods;
        for (MethodNode methodNode : nodes) {
          for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
            if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
              String string = ((LdcInsnNode) insnNode).cst.toString();
              boolean xorv1 = containsBlacklistedWord(StringDeobfuscator.XORV1(string));
              boolean xorv2 = containsBlacklistedWord(StringDeobfuscator.XORV2(string));
              boolean xorv3 = containsBlacklistedWord(StringDeobfuscator.XORV3(string));
              boolean xorv4 = containsBlacklistedWord(StringDeobfuscator.decryptionArray(string));
              boolean sig = checkForDLSignature(classNode);
              boolean bootstrap1 = bootstrap1(classNode);
              boolean bootstrap2 = bootstrap2(classNode);
              boolean host = false;
              try {
                host = doesDLHostCheckExist(classNode);
              } catch (Throwable ex) {
                LOGGER.exception(ex);
              }
              if (xorv1 || xorv2 || xorv3 || xorv4 || host || sig || bootstrap1 || bootstrap2) {
                setClassNodePath(classNode.name);
                setSourceFilePath(classNode.sourceFile);
                return true;
              }
            } else if (insnNode instanceof LineNumberNode) {
              setLine(((LineNumberNode) insnNode).line);
            }
          }
        }
      }
      return false;
    });
    if (found) {
      List<CheckResult> result = new ArrayList<>();
      result.add(new CheckResult("Spigot", "MALWARE", "DirectLeaks", "A", getSourceFilePath(), getClassNodePath(), getLine()));
      return result;
    }
    return new ArrayList<>();
  }

  String[] blacklistedWords = new String[]{"#directleaks", "Please contact DirectLeaks. 0x2",
    "http://api.directleaks.net/api/directleaks", "[DirectLeaks] Error Code: 0x1", "Anti-Releak", "DirectLeaks",
    "vmi209890.contaboserver.net", "167.86.75.51", "#DirectLeaks Anti-Releak", "DirectLeaks-API",
    "de.xbrowniecodez.dlapi.Main", "de.xbrowniecodez.dlapi.HostsCheck"};

  public boolean containsBlacklistedWord(String string) {
    for (String blacklistedWord : blacklistedWords) {
      if (string.contains(blacklistedWord)) {
        return true;
      }
    }
    return false;
  }

  public static boolean doesDLHostCheckExist(ClassNode classNode) throws Throwable {
    try {
      Iterator<MethodNode> iterator = classNode.methods.iterator();
      while (iterator.hasNext()) {
        MethodNode attributeIterator = iterator.next();
        if (attributeIterator.name.equalsIgnoreCase("onEnable")) {
          InsnList attribute = attributeIterator.instructions;
          AbstractInsnNode insnNode = attribute.get(0);

          if (insnNode.getType() == 5 && insnNode.getOpcode() == 184 && ((MethodInsnNode) insnNode).desc.equals("()V")
                  && !((MethodInsnNode) insnNode).name.equalsIgnoreCase("loadConfig0")) {
            return true;
          }
        } else if (attributeIterator.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")
                && attributeIterator.access == 4170) {
          return true;
        }
      }
    } catch (Exception e) {
      LOGGER.warn("DLHostCheck Error on " + classNode.name);
    }
    return false;
  }

  public static boolean checkForDLSignature(ClassNode classNode) {
    if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
            || classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
      if (classNode.signature == null) {
        return false;
      }
      return classNode.signature.contains("directleaks");
    }
    return false;
  }

  public static boolean bootstrap1(ClassNode classNode) {
    Iterator<MethodNode> iterator = classNode.methods.iterator();
    while (iterator.hasNext()) {
      MethodNode methodNode = iterator.next();
      if (methodNode.desc.equalsIgnoreCase(
              "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;")) {
        return true;
      }
    }
    return false;
  }

  public static boolean bootstrap2(ClassNode classNode) {
    if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
            || classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
      for (FieldNode fieldNode : classNode.fields) {
        if (fieldNode.access == 9 && fieldNode.desc.equalsIgnoreCase("I") && fieldNode.name.length() == 36) {
          return true;
        } else if (fieldNode.access == 9 && fieldNode.desc.equalsIgnoreCase("Ljava/lang/String;")
                && fieldNode.name.length() == 36) {
          return true;
        }
      }
    }
    return false;
  }
}
