package optic_fusion1.mcantimalware.check.impl;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Iterator;
import java.util.List;
import optic_fusion1.mcantimalware.Main;
import static optic_fusion1.mcantimalware.Main.LOGGER;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.deobfuscator.StringDeobfuscator;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.FieldNode;
import org.objectweb.asm.tree.InsnList;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public class DirectLeaksCheck extends BaseCheck {

  public DirectLeaksCheck(Main main, String name) {
    super(main, name);
  }

  @Override
  public void process(Path rootFolder, Path zipFile) {
    try {
      Files.walk(rootFolder).forEach((path) -> {
        if (validClassPath(path)) {
          try (InputStream is = Files.newInputStream(path)) {
            ClassReader reader = new ClassReader(is);
            ClassNode classNode = new ClassNode();
            reader.accept(classNode, 0);

            if (classNode.name.startsWith("directleaks")) {
              setClassNodePath(classNode.name);
              setSourceFilePath(classNode.sourceFile);
              addToScore(1000);
              return;
            }
            List<MethodNode> nodes = classNode.methods;
            for (MethodNode methodNode : nodes) {
              for (AbstractInsnNode insnNode : methodNode.instructions.toArray()) {
                if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
                  String string = ((LdcInsnNode) insnNode).cst.toString();
                  boolean xorv1 = containsBlacklistedWord(StringDeobfuscator.XORV1(string));
                  boolean xorv2 = containsBlacklistedWord(StringDeobfuscator.XORV2(string));
                  boolean xorv3 = containsBlacklistedWord(StringDeobfuscator.XORV3(string));
                  boolean xorv4 = containsBlacklistedWord(StringDeobfuscator.decryptionArray(string));
                  boolean sig = checkForDLSignature(classNode);
                  boolean bootstrap1 = bootstrap1(classNode);
                  boolean bootstrap2 = bootstrap2(classNode);
                  boolean host = false;
                  try {
                    host = doesDLHostCheckExist(classNode);
                  } catch (Throwable ex) {
                    LOGGER.exception(ex);
                  }
                  if (xorv1 || xorv2 || xorv3 || xorv4 || host || sig || bootstrap1 || bootstrap2) {
                    setClassNodePath(classNode.name);
                    setSourceFilePath(classNode.sourceFile);
                    addToScore(1000);
                    return;
                  }
                } else if (insnNode instanceof LineNumberNode) {
                  setLine(((LineNumberNode) insnNode).line);
                }
              }
            }
          } catch (IOException e) {
            LOGGER.exception(e);
          }
        }
      });
    } catch (IOException e) {
      LOGGER.exception(e);
    }
  }

  public boolean containsBlacklistedWord(String string) {
    String[] blacklistedWords = new String[]{
      "#directleaks",
      "Please contact DirectLeaks. 0x2",
      "http://api.directleaks.net/api/directleaks",
      "[DirectLeaks] Error Code: 0x1",
      "Anti-Releak",
      "DirectLeaks",
      "vmi209890.contaboserver.net",
      "167.86.75.51",
      "#DirectLeaks Anti-Releak",
      "DirectLeaks-API",
      "de.xbrowniecodez.dlapi.Main",
      "de.xbrowniecodez.dlapi.HostsCheck"
    };
    for (String blacklistedWord : blacklistedWords) {
      if (string.contains(blacklistedWord)) {
        return true;
      }
    }
    return false;
  }

  public static boolean doesDLHostCheckExist(ClassNode classNode) throws Throwable {
    Iterator<MethodNode> iterator = classNode.methods.iterator();
    while (iterator.hasNext()) {
      MethodNode attributeIterator = iterator.next();
      if (attributeIterator.name.equalsIgnoreCase("onEnable")) {
        InsnList attribute = attributeIterator.instructions;
        AbstractInsnNode insnNode = attribute.get(0);

        if (insnNode.getType() == 5 && insnNode.getOpcode() == 184
                && ((MethodInsnNode) insnNode).desc.equals("()V")
                && !((MethodInsnNode) insnNode).name.equalsIgnoreCase("loadConfig0")) {
          return true;
        }
      } else if (attributeIterator.desc.equals("(Ljava/lang/String;)Ljava/lang/String;")
              && attributeIterator.access == 4170) {
        return true;
      }
    }
    return false;
  }

  public static boolean checkForDLSignature(ClassNode classNode) {
    if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
            || classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
      if (classNode.signature == null) {
        return false;
      }
      return classNode.signature.contains("directleaks");
    }
    return false;
  }

  public static boolean bootstrap1(ClassNode classNode) {
    Iterator<MethodNode> iterator = classNode.methods.iterator();
    while (iterator.hasNext()) {
      MethodNode methodNode = iterator.next();
      if (methodNode.desc.equalsIgnoreCase(
              "(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/Class;Ljava/lang/String;I)Ljava/lang/invoke/CallSite;")) {
        return true;
      }
    }
    return false;
  }

  public static boolean bootstrap2(ClassNode classNode) {
    if (classNode.superName.equals("org/bukkit/plugin/java/JavaPlugin")
            || classNode.superName.equals("net/md_5/bungee/api/plugin/Plugin")) {
      for (FieldNode fieldNode : classNode.fields) {
        if (fieldNode.access == 9
                && fieldNode.desc.equalsIgnoreCase("I")
                && fieldNode.name.length() == 36) {
          return true;
        } else if (fieldNode.access == 9
                && fieldNode.desc.equalsIgnoreCase("Ljava/lang/String;")
                && fieldNode.name.length() == 36) {
          return true;
        }
      }
    }
    return false;
  }
}
