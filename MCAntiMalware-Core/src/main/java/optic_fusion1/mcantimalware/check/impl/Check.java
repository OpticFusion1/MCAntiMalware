package optic_fusion1.mcantimalware.check.impl;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import optic_fusion1.mcantimalware.Main;
import static optic_fusion1.mcantimalware.Main.LOGGER;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.logging.CustomLevel;
import optic_fusion1.mcantimalware.utils.Utils;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;

public class Check extends BaseCheck {

  public Check(Main main, String name) {
    super(main, name);
  }

  @Override
  public void process(Path rootFolder, Path zipFile) {
    if (isPlugin(rootFolder)) {
      handlePlugin(rootFolder, zipFile);
    }
  }

  private void handlePlugin(Path rootFolder, Path zipFile) {
    try {
      if (isFileBlacklisted(zipFile)) {
        addToScore(1000);
        return;
      }
      Files.walk(rootFolder).forEach((path) -> {
    	if(path == null || path.getFileName() == null) {
          return;
        }
        String name = path.getFileName().toString();

        if (isPluginYmlFile(name) || isBungeeYmlFile(name)) {
          try (InputStream is = Files.newInputStream(path)) {
            List<String> authors = Utils.getAuthors(YamlConfiguration.loadConfiguration(is));
            List<String> blacklistedAuthors = getBlacklistedAuthors();
            for (String author : authors) {
              if (blacklistedAuthors.contains(author)) {
                setClassNodePath("plugin.yml");
                setLine(-1);
                setSourceFilePath("plugin.yml");
                addToScore(1000);
              }
            }
          } catch (IOException ex) {
            LOGGER.exception(ex);
          }
        }
        if (validClassPath(path)) {
          try (InputStream is = Files.newInputStream(path)) {
            ClassReader reader = new ClassReader(is);
            ClassNode classNode = new ClassNode();
            reader.accept(classNode, 0);
            String className = classNode.name;
            boolean blockedClasspath = getBlacklistedClassPaths().stream()
                    .anyMatch((blockedPath) -> className.contains(blockedPath));
            if (blockedClasspath) {
              setClassNodePath(className);
              setSourceFilePath(classNode.sourceFile);
              addToScore(1000);
            }

			if (classNodeContainsBlacklistedWord(classNode, getBlacklistedStrings())) {
			  setClassNodePath(classNode.name);
			  setSourceFilePath(classNode.sourceFile);
			  addToScore(1000);
			}
		  } catch (Exception ex) {
			LOGGER.log("Wasn't able to read File " + path.toAbsolutePath().toString() + " for DirectLeaksCheck",
				CustomLevel.WARNING, false);
		  }
		}
	  });
	} catch (IOException ex) {
	  LOGGER.exception(ex);
	}
  }

}
