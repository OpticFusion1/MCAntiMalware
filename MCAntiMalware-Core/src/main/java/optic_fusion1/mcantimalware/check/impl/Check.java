package optic_fusion1.mcantimalware.check.impl;

import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.check.BaseCheck;
import optic_fusion1.mcantimalware.check.CacheContainer;
import optic_fusion1.mcantimalware.check.CheckResult;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.database.AntiMalwareDatabase;
import optic_fusion1.mcantimalware.utils.Utils;

public class Check extends BaseCheck {

	public Check(Main main) {
		super(main);
	}

	@Override
	public List<CheckResult> process(Path rootFolder, Path zipFile, CacheContainer cache) {
		if (isPlugin(rootFolder)) {
			return handlePlugin(rootFolder, zipFile, cache);
		}
		return List.of();
	}

	private List<CheckResult> handlePlugin(Path rootFolder, Path zipFile, CacheContainer cache) {
		AntiMalwareDatabase malwareDatabase = Main.getInstance().getDatabase();

		CheckResult blacklistedChecksum = malwareDatabase.blacklistedChecksumToCheckResult(cache.fetchSHA1(zipFile));
		if (blacklistedChecksum != null) {
			return List.of(blacklistedChecksum);
		}

		HashSet<String> blacklistedClasspaths, blacklistedStrings, blacklistedAuthors;
		try {
			blacklistedClasspaths = malwareDatabase.getBlacklistedClasspaths();
			blacklistedStrings = malwareDatabase.getBlacklistedStrings();
			blacklistedAuthors = malwareDatabase.getBlacklistedAuthors();
		} catch (SQLException e) {
			Main.getInstance().getLogger().exception(e);
			return List.of();
		}

		Path pluginYML = rootFolder.resolve("plugin.yml");
		List<CheckResult> pluginYMLResults = new ArrayList<CheckResult>();
		if (Files.exists(pluginYML)) {
			YamlConfiguration config = cache.fetchConfiguration(pluginYML);
			if (config != null) {
				List<String> authors = Utils.getAuthors(config);
				for (String author : authors) {
					if (blacklistedAuthors.contains(author)) {
						pluginYMLResults.add(malwareDatabase.blacklistedAuthorToCheckResult(author));
					}
				}
			}
		}

		List<CheckResult> checkResults = walkThroughFiles(rootFolder)
				.filter((path) -> path != null && path.getFileName() != null).filter(this::validClassPath).flatMap((path) -> {
					ClassNode classNode = cache.fetchClass(path);
					if (classNode == null)
						return Stream.empty();
					String className = classNode.name;
					List<CheckResult> results = blacklistedClasspaths.stream().filter(className::contains)
							.map(malwareDatabase::blacklistedClassPathToCheckResult).collect(Collectors.toList());

					results.addAll(classNodeContainsBlacklistedWord(classNode, blacklistedStrings, malwareDatabase));
					return results.stream();
				}).collect(Collectors.toList());

		checkResults.addAll(pluginYMLResults);
		return checkResults;
	}

	public List<CheckResult> classNodeContainsBlacklistedWord(ClassNode classNode, HashSet<String> blacklistedStrings,
			AntiMalwareDatabase malwareDatabase) {
		List<CheckResult> results = new ArrayList<CheckResult>();
		List<MethodNode> nodes = classNode.methods;
		for (MethodNode node : nodes) {
			for (AbstractInsnNode insnNode : node.instructions.toArray()) {
				if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
					String string = ((LdcInsnNode) insnNode).cst.toString();
					for (String blacklistedString : blacklistedStrings) {
						if (string.equals(blacklistedString)) {
							AbstractInsnNode nextNode = insnNode.getNext();
							if (nextNode instanceof MethodInsnNode) {
								MethodInsnNode fieldNode = (MethodInsnNode) nextNode;
								if (fieldNode.desc.equals("(Ljava/lang/String;)Lorg/bukkit/command/PluginCommand;")
										&& fieldNode.name.equals("getCommand")) {
									continue;
								}
							}
							CheckResult result = malwareDatabase.blacklistedStringToCheckResult(blacklistedString);
							result.setSourceFilePath(classNode.sourceFile);
							result.setClassNodePath(classNode.name);
							result.setLine(getLine());
							results.add(result);
						}
					}
				} else if (insnNode instanceof LineNumberNode) {
					setLine(((LineNumberNode) insnNode).line);
				}
			}
		}
		return results;
	}

}
