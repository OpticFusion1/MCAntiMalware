package optic_fusion1.mcantimalware.check;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Enumeration;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import optic_fusion1.mcantimalware.AntiMalware;
import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.StringUtils;
import org.apache.commons.codec.digest.DigestUtils;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public abstract class BaseCheck {

  public static final CustomLogger LOGGER = AntiMalware.getInstance().getLogger();
  private String name = "";
  private String classNodePath = "";
  private String sourceFilePath = "";
  private String logName = "";
  private String checkType = "";
  private int line = -1;
  private int score = 0;
  private int threshold = 0;
  private List<String> blacklistedAuthors = new ArrayList<>();
  private List<String> blacklistedChecksums = new ArrayList<>();
  private List<String> blacklistedClassPaths = new ArrayList<>();
  private List<String> blacklistedStrings = new ArrayList<>();
  private List<String> blacklistedClassNames = new ArrayList<>();
  public boolean shouldDebugMessagesBeLogged;
  public boolean shouldExceptionsBeLogged;

  public BaseCheck(String name) {
    this.name = name;
    CommandLineParser commandLineHandler = AntiMalware.getInstance().getCommandLineParser();
    shouldDebugMessagesBeLogged = commandLineHandler.shouldDebugMessagesBeLogged();
    shouldExceptionsBeLogged = commandLineHandler.shouldExceptionsBeLogged();
  }

  //Probably doesn't need to return boolean
  public abstract boolean process(String filePath, ZipFile zipFile);

  public boolean checksumIsBlacklisted(String fileChecksum) {
    if (blacklistedChecksums.isEmpty()) {
      return false;
    }
    return blacklistedChecksums.stream().anyMatch((blacklistedChecksum) -> (fileChecksum.equals(blacklistedChecksum)));
  }

  public boolean isFileBlacklisted(String path) throws FileNotFoundException, IOException {
    if (checksumIsBlacklisted(DigestUtils.sha1Hex(new FileInputStream(new File(path))))) {
      LOGGER.detected(I18n.tl("checksum_blacklisted", path));
      return true;
    }
    return false;
  }

  public void setLogName(String logName) {
    this.logName = logName;
  }

  public String getLogName() {
    if (logName.isEmpty()) {
      return name;
    }
    return logName;
  }

  public void setBlacklistedStrings(List<String> blacklistedStrings) {
    this.blacklistedStrings = blacklistedStrings;
  }

  public void setBlacklistedClassPaths(List<String> blacklistedClassPaths) {
    this.blacklistedClassPaths = blacklistedClassPaths;
  }

  public void setBlacklistedChecksums(List<String> blacklistedChecksums) {
    this.blacklistedChecksums = blacklistedChecksums;
  }

  public void setBlacklistedAuthors(List<String> blacklistedAuthors) {
    this.blacklistedAuthors = blacklistedAuthors;
  }

  public void setType(String checkType) {
    this.checkType = checkType;
  }

  public String getType() {
    return checkType;
  }

  public String getName() {
    return name;
  }

  public boolean classNodeContainsBlacklistedWord(ClassNode classNode, List<String> blacklistedStrings) {
    boolean containsBlacklistedWord = false;
    List<MethodNode> nodes = classNode.methods;
    for (MethodNode node : nodes) {
      for (AbstractInsnNode insnNode : node.instructions.toArray()) {
        if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
          String string = ((LdcInsnNode) insnNode).cst.toString();
          for (String blacklistedString : blacklistedStrings) {
            if (string.equals(blacklistedString)) {
              AbstractInsnNode nextNode = insnNode.getNext();
              if (nextNode instanceof MethodInsnNode) {
                MethodInsnNode fieldNode = (MethodInsnNode) nextNode;
                if (fieldNode.desc.equals("(Ljava/lang/String;)Lorg/bukkit/command/PluginCommand;") && fieldNode.name.equals("getCommand")) {
                  continue;
                }
              }
              if (shouldDebugMessagesBeLogged && !string.isEmpty() && !blacklistedString.isEmpty()) {
                LOGGER.debug("String: " + string + " BlacklistedString: " + blacklistedString);
              }
              containsBlacklistedWord = true;
              addOneToScore();
            }
          }
        } else if (insnNode instanceof LineNumberNode) {
          setLine(((LineNumberNode) insnNode).line);
        }
      }
    }
    return containsBlacklistedWord;
  }

  public boolean isPlugin(ZipFile zipFile) {
    Enumeration<? extends ZipEntry> entries = zipFile.entries();
    while (entries.hasMoreElements()) {
      ZipEntry zipEntry = entries.nextElement();
      String currentName = zipEntry.getName();
      if (isBungeeYmlFile(currentName) || isPluginYmlFile(currentName)) {
        return true;
      }
    }
    return false;
  }

  public boolean isBungeeYmlFile(String fileName) {
    return fileName.equals("bungee.yml");
  }

  public boolean isPluginYmlFile(String fileName) {
    return fileName.equals("plugin.yml");
  }

  public boolean isTextFile(String fileName) {
    return fileName.endsWith(".yml") || fileName.endsWith(".txt");
  }

  public void setClassNodePath(String string) {
    this.classNodePath = string;
  }

  public void setSourceFilePath(String sourceFilePath) {
    if (!StringUtils.isBlank(sourceFilePath)) {
      this.sourceFilePath = sourceFilePath;
    }
  }

  public void setLine(int line) {
    this.line = line;
  }

  public String getClassNodePath() {
    return classNodePath;
  }

  public String getSourceFilePath() {
    return sourceFilePath;
  }

  public int getLine() {
    return line;
  }

  public boolean validClassPath(String classPath) {
    return classPath.endsWith(".class") && !classPath.contains("__MACOSX");
  }

  public void setBlacklistedClassNames(List<String> blacklistedClassNames) {
    this.blacklistedClassNames = blacklistedClassNames;
  }

  public void addOneToScore() {
    score++;
  }

  public void addToScore(int amount) {
    score += amount;
  }

  public int getScore() {
    return score;
  }

  public int getThreshold() {
    return threshold;
  }

  public void setThreshold(int threshold) {
    this.threshold = threshold;
  }

  public void reset() {
    classNodePath = "";
    sourceFilePath = "";
    line = -1;
    score = 0;
  }

  public List<String> getBlacklistedAuthors() {
    return Collections.unmodifiableList(blacklistedAuthors);
  }

  public List<String> getBlacklistedChecksums() {
    return Collections.unmodifiableList(blacklistedChecksums);
  }

  public List<String> getBlacklistedClassPaths() {
    return Collections.unmodifiableList(blacklistedClassPaths);
  }

  public List<String> getBlacklistedStrings() {
    return Collections.unmodifiableList(blacklistedStrings);
  }

  public List<String> getBlacklistedClassNames() {
    return Collections.unmodifiableList(blacklistedClassNames);
  }
}
