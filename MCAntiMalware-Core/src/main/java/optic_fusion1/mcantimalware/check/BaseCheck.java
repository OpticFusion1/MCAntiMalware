package optic_fusion1.mcantimalware.check;

import java.io.FileNotFoundException;
import java.io.IOException;
import java.nio.file.FileVisitOption;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import optic_fusion1.mcantimalware.CommandLineParser;
import optic_fusion1.mcantimalware.Main;
import static optic_fusion1.mcantimalware.Main.LOGGER;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.StringUtils;
import java.util.stream.Stream;
import org.apache.commons.codec.digest.DigestUtils;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.LdcInsnNode;
import org.objectweb.asm.tree.LineNumberNode;
import org.objectweb.asm.tree.MethodInsnNode;
import org.objectweb.asm.tree.MethodNode;

public abstract class BaseCheck {

  private String name = "";
  private String classNodePath = "";
  private String sourceFilePath = "";
  private String logName = "";
  private String checkType = "";
  private int line = -1;
  private int score = 0;
  private int threshold = 0;
  private List<String> blacklistedAuthors = new ArrayList<>();
  private List<String> blacklistedChecksums = new ArrayList<>();
  private List<String> blacklistedClassPaths = new ArrayList<>();
  private List<String> blacklistedStrings = new ArrayList<>();
  private List<String> blacklistedClassNames = new ArrayList<>();
  private CommandLineParser commandLineParser;

  public BaseCheck(Main main, String name) {
    this.name = name;
    commandLineParser = main.getCommandLineParser();
  }

  public abstract void process(Path rootFolder, Path zipFile, CacheContainer cache);

  public boolean checksumIsBlacklisted(String fileChecksum) {
    if (blacklistedChecksums.isEmpty()) {
      return false;
    }
    return blacklistedChecksums.stream().anyMatch((blacklistedChecksum) -> (fileChecksum.equals(blacklistedChecksum)));
  }

  public boolean isFileBlacklisted(Path path) throws FileNotFoundException, IOException {
    if (checksumIsBlacklisted(DigestUtils.sha1Hex(Files.newInputStream(path)))) {
      LOGGER.detected(I18n.tl("checksum_blacklisted", path));
      return true;
    }
    return false;
  }

  public void setLogName(String logName) {
    this.logName = logName;
  }

  public String getLogName() {
    if (logName.isEmpty()) {
      return name;
    }
    return logName;
  }

  public void setBlacklistedStrings(List<String> blacklistedStrings) {
    this.blacklistedStrings = blacklistedStrings;
  }

  public void setBlacklistedClassPaths(List<String> blacklistedClassPaths) {
    this.blacklistedClassPaths = blacklistedClassPaths;
  }

  public void setBlacklistedChecksums(List<String> blacklistedChecksums) {
    this.blacklistedChecksums = blacklistedChecksums;
  }

  public void setBlacklistedAuthors(List<String> blacklistedAuthors) {
    this.blacklistedAuthors = blacklistedAuthors;
  }

  public void setType(String checkType) {
    this.checkType = checkType;
  }

  public String getType() {
    return checkType;
  }

  public String getName() {
    return name;
  }

	protected Stream<Path> walkThroughFiles(Path dir) {
		if (dir.getFileName() != null && dir.getFileName().toString().equals(".")) {
			return Stream.of();
		} else if (Files.isDirectory(dir, LinkOption.NOFOLLOW_LINKS)) {
			try {
				return Files.list(dir).filter(path -> !Files.isSymbolicLink(path)).flatMap(this::walkThroughFiles);
			} catch (IOException e) {
				LOGGER.exception(e);
				return Stream.of();
			}
		} else if (Files.isSymbolicLink(dir)) {
			return Stream.of();
		} else {
			return Stream.of(dir);
		}
	}

	public boolean classNodeContainsBlacklistedWord(ClassNode classNode, List<String> blacklistedStrings) {
		boolean containsBlacklistedWord = false;
		List<MethodNode> nodes = classNode.methods;
		for (MethodNode node : nodes) {
			for (AbstractInsnNode insnNode : node.instructions.toArray()) {
				if (insnNode instanceof LdcInsnNode && ((LdcInsnNode) insnNode).cst instanceof String) {
					String string = ((LdcInsnNode) insnNode).cst.toString();
					for (String blacklistedString : blacklistedStrings) {
						if (string.equals(blacklistedString)) {
							AbstractInsnNode nextNode = insnNode.getNext();
							if (nextNode instanceof MethodInsnNode) {
								MethodInsnNode fieldNode = (MethodInsnNode) nextNode;
								if (fieldNode.desc.equals("(Ljava/lang/String;)Lorg/bukkit/command/PluginCommand;")
										&& fieldNode.name.equals("getCommand")) {
									continue;
								}
							}
							containsBlacklistedWord = true;
							addOneToScore();
						}
					}
				} else if (insnNode instanceof LineNumberNode) {
					setLine(((LineNumberNode) insnNode).line);
				}
			}
		}
		return containsBlacklistedWord;
	}

	public boolean isPlugin(Path rootDir) {
		return Files.exists(rootDir.resolve("plugin.yml")) || Files.exists(rootDir.resolve("bungee.yml"));
	}

	public boolean isBungeeYmlFile(String fileName) {
		return fileName.equals("bungee.yml");
	}

	public boolean isPluginYmlFile(String fileName) {
		return fileName.equals("plugin.yml");
	}

	public boolean isTextFile(String fileName) {
		return fileName.endsWith(".yml") || fileName.endsWith(".txt");
	}

	public void setClassNodePath(String string) {
		this.classNodePath = string;
	}

	public void setSourceFilePath(String sourceFilePath) {
		if (!StringUtils.isBlank(sourceFilePath)) {
			this.sourceFilePath = sourceFilePath;
		}
	}

	public void setLine(int line) {
		this.line = line;
	}

	public String getClassNodePath() {
		return classNodePath;
	}

	public String getSourceFilePath() {
		return sourceFilePath;
	}

	public int getLine() {
		return line;
	}

	public boolean validClassPath(Path classPath) {
		return classPath.toString().endsWith(".class") && !classPath.toString().contains("__MACOSX");
	}

	public void setBlacklistedClassNames(List<String> blacklistedClassNames) {
		this.blacklistedClassNames = blacklistedClassNames;
	}

	public void addOneToScore() {
		score++;
	}

	public void addToScore(int amount) {
		score += amount;
	}

	public int getScore() {
		return score;
	}

	public int getThreshold() {
		return threshold;
	}

	public void setThreshold(int threshold) {
		this.threshold = threshold;
	}

	public void reset() {
		classNodePath = "";
		sourceFilePath = "";
		line = -1;
		score = 0;
	}

	public List<String> getBlacklistedAuthors() {
		return Collections.unmodifiableList(blacklistedAuthors);
	}

	public List<String> getBlacklistedChecksums() {
		return Collections.unmodifiableList(blacklistedChecksums);
	}

	public List<String> getBlacklistedClassPaths() {
		return Collections.unmodifiableList(blacklistedClassPaths);
	}

	public List<String> getBlacklistedStrings() {
		return Collections.unmodifiableList(blacklistedStrings);
	}

	public List<String> getBlacklistedClassNames() {
		return Collections.unmodifiableList(blacklistedClassNames);
	}

	public CommandLineParser getCommandLineParser() {
		return commandLineParser;
	}
}
