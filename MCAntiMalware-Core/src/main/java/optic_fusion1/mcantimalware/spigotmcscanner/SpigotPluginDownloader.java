package optic_fusion1.mcantimalware.spigotmcscanner;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.function.Consumer;

import org.apache.commons.io.IOUtils;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonSyntaxException;

public class SpigotPluginDownloader {

	private File pluginDatabaseDirectory;

	private final String LIST_FREE_RESOURCES = "https://api.spiget.org/v2/resources/free?sort=-updateDate&fields=file,name,version&page={PAGE}";

	private final String DOWNLOAD_RESOURCE = "https://api.spiget.org/v2/resources/{RESOURCE}/download";

	private final String FOLDER_PATH = "{NAME}.{RESOURCE}/{VERSION}/";

	private final String FILE_PATH = "{NAME}-{VERSION-NAME}{TYPE}";

	public SpigotPluginDownloader(File pluginDatabaseDirectory) {
		this.pluginDatabaseDirectory = pluginDatabaseDirectory;
	}

	private boolean downloadPage(int currentPage, Consumer<Path> downloadedPluginConsumer) {
		String urlString = LIST_FREE_RESOURCES.replace("{PAGE}", String.valueOf(currentPage));
		System.out.println("Downloading the current page: " + urlString);
		try {
			boolean downloadedPlugin = false;
			boolean onlyExternal = true;
			JsonArray array = parseJson(new URL(urlString), JsonArray.class);
			if (array.size() == 0) {
				return false;
			}
			for (JsonElement element : array) {
				JsonObject pluginInformation = element.getAsJsonObject();
				if (pluginInformation == null) {
					System.out.println("PLUGIN NULL");
					continue;
				}
				int id = pluginInformation.get("id").getAsInt();
				String name = pluginInformation.get("name").getAsString();
				String fileType;
				JsonElement fileJsonObject = pluginInformation.get("file");
				if (fileJsonObject == null) {
					fileType = ".jar";
				} else {
					fileType = fileJsonObject.getAsJsonObject().get("type").getAsString();
				}
				if (!fileType.equals("external")) {
					onlyExternal = false;
					JsonElement versionInformation = pluginInformation.get("version");
					int version;
					if (versionInformation != null) {
						version = versionInformation.getAsJsonObject().get("id").getAsInt();
					} else {
						continue;
					}
					PluginVersionInfo pvi = new PluginVersionInfo(name, id, version, fileType);

					File pluginFolder = createFolderPath(pvi);

					if (!pluginFolder.exists()) {
						try {
							pluginFolder.mkdirs();
							Path filePath = download(pvi);
							if (filePath != null) {
								downloadedPlugin = true;
								downloadedPluginConsumer.accept(filePath);
							}
						} catch (Exception e) {
							e.printStackTrace();
						}
					}
				}
			}
			return downloadedPlugin || onlyExternal;
		} catch (IOException e) {
			e.printStackTrace();
		}
		return false;
	}

	private File createFolderPath(PluginVersionInfo pvi) {
		String replacedPath = FOLDER_PATH.replace("{NAME}", pvi.getName())
				.replace("{RESOURCE}", String.valueOf(pvi.getResource()))
				.replace("{VERSION}", String.valueOf(pvi.getVersion()));
		return new File(pluginDatabaseDirectory, replacedPath);
	}

	private File createFilePath(PluginVersionInfo pvi) {
		String replacedPath = FILE_PATH.replace("{NAME}", pvi.getName()).replace("{VERSION-NAME}", pvi.getVersionName())
				.replace("{TYPE}", pvi.getFileType());
		return new File(createFolderPath(pvi), replacedPath);
	}

	private Path download(PluginVersionInfo pvi) throws IOException {
		URL url = new URL(DOWNLOAD_RESOURCE.replace("{RESOURCE}", String.valueOf(pvi.getResource())));
		Path pluginPath = createFilePath(pvi).toPath();
		if (Files.copy(url.openStream(), pluginPath) == 0) {
			return null;
		}
		return pluginPath;
	}

	public void downloadNewPlugins(Consumer<Path> downloadedPluginConsumer) {
		if (!pluginDatabaseDirectory.exists()) {
			pluginDatabaseDirectory.mkdirs();
		}
		int page = 1;
		while (downloadPage(page++, downloadedPluginConsumer)) {
		}
	}

	private static Gson gson = new Gson();

	protected static <Element extends JsonElement> Element parseJson(URL url, Class<Element> type)
			throws JsonSyntaxException, IOException {
		return gson.fromJson(IOUtils.toString(url.openStream(), "UTF-8"), type);
	}

}

class PluginVersionInfo {

	private final String GET_VERSION_NAME = "https://api.spiget.org/v2/resources/{RESOURCE}/versions/{VERSION}?fields=name";

	private String name;
	private int resource;
	private int version;
	private String versionName;
	private String fileType;

	public PluginVersionInfo(String name, int resource, int version, String fileType) {
		this.name = cleanTextContent(name);
		this.resource = resource;
		this.version = version;
		this.fileType = fileType;
	}

	public String getName() {
		return name;
	}

	public int getResource() {
		return resource;
	}

	public int getVersion() {
		return version;
	}

	public String getFileType() {
		return fileType;
	}

	public String getVersionName() {
		if (versionName == null) {
			try {
				fetchVersionName();
			} catch (JsonSyntaxException | IOException e) {
				e.printStackTrace();
				return "";
			}
		}
		return versionName;
	}

	private void fetchVersionName() throws JsonSyntaxException, MalformedURLException, IOException {
		URL fetchURL = new URL(
				GET_VERSION_NAME.replace("{RESOURCE}", String.valueOf(resource)).replace("{VERSION}", String.valueOf(version)));
		JsonObject jo = SpigotPluginDownloader.parseJson(fetchURL, JsonObject.class);
		versionName = cleanTextContent(jo.get("name").getAsString());
	}

	private static String cleanTextContent(String text) {
		// strips off all non-ASCII characters
		text = text.replaceAll("[^\\x00-\\x7F]", "");
		// erases all the ASCII control characters
		text = text.replaceAll("[\\p{Cntrl}&&[^\r\n\t]]", "");
		// removes non-printable characters from Unicode
		text = text.replaceAll("\\p{C}", "");
		// remove whitespaces
		text = text.replace(" ", "");
		text = text.replace("/", "");
		text = text.replace(".", "");
		text = text.replace("-", "");
		return text.trim();
	}

}
