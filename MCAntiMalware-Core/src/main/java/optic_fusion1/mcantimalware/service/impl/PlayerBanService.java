package optic_fusion1.mcantimalware.service.impl;

import static optic_fusion1.mcantimalware.Main.URL_PREFIX;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.HashMap;
import optic_fusion1.mcantimalware.Main;
import optic_fusion1.mcantimalware.configuration.ConfigurationSection;
import optic_fusion1.mcantimalware.configuration.file.FileConfiguration;
import optic_fusion1.mcantimalware.configuration.file.YamlConfiguration;
import optic_fusion1.mcantimalware.logging.CustomLogger;
import optic_fusion1.mcantimalware.service.Service;
import optic_fusion1.mcantimalware.utils.I18n;
import optic_fusion1.mcantimalware.utils.Utils;
import org.apache.commons.io.IOUtils;

public class PlayerBanService implements Service {

  private static final String BANNED_PLAYERS_URL = URL_PREFIX + "banned-players.yml";
  private static final HashMap<String, BanEntry> BAN_ENTRIES = new HashMap<>();
  private boolean shouldExceptionsBeLogged;
  private CustomLogger logger;
  private FileConfiguration config;

  public PlayerBanService(Main main) {
    shouldExceptionsBeLogged = main.getCommandLineParser().shouldExceptionsBeLogged();
    logger = main.getLogger();
  }

  @Override
  public void startService() throws Exception {
    logger.info("Banning possible malicious devs");
    loadBans();
    banMaliciousDevs();
    saveBans();
    logger.info("Finished banning possible malicious devs");
  }

  private void loadBans() {
    try {
      String jsonString = IOUtils.toString(new FileInputStream(new File("banned-players.json")), "UTF-8");
      if (jsonString.isEmpty()) {
        logger.info("Couldn't load player banned (Are there any players banned?)");
        return;
      }
      JsonArray banEntryArray = new JsonParser().parse(jsonString).getAsJsonArray();
      if (banEntryArray.size() == 0) {
        logger.info("Couldn't load player banned (Are there any players banned?)");
        return;
      }
      for (JsonElement banEntry : banEntryArray) {
        parseBan(banEntry.getAsJsonObject());
      }
      logger.info("Loaded " + banEntryArray.size() + " player bans");
    } catch (FileNotFoundException ex) {
      if (shouldExceptionsBeLogged) {
        logger.exception(ex);
      }
    } catch (IOException ex) {
      if (shouldExceptionsBeLogged) {
        logger.exception(ex);
      }
    }
  }

  private void banMaliciousDevs() {
    downloadMaliciousAuthorsDatabase();
    if (config == null || config.getKeys(false).isEmpty()) {
      InputStream databaseInputStream = Utils.getResource("banned-players.yml");
      config = YamlConfiguration.loadConfiguration(databaseInputStream);
      if (config == null || config.getKeys(false).isEmpty()) {
        logger.info(I18n.tl("banned_players_database_not_found"));
        return;
      }
    }
    config.getKeys(false).forEach((key) -> {
      ConfigurationSection section = config.getConfigurationSection(key);
      section.getStringList("uuid").stream().map((uuid) -> {
        if (!isBanned(key, uuid)) {
          addBan(new BanEntry(key, uuid));
        }
        return uuid;
      }).filter((uuid) -> !(!section.isString("previous-names"))).forEachOrdered((uuid) -> {
        section.getStringList("previous-names").stream().filter((previousName) -> (!isBanned(previousName, uuid))).forEachOrdered((previousName) -> {
          addBan(new BanEntry(previousName, uuid));
        });
      });
    });
  }

  private void saveBans() {
    Gson gson = new GsonBuilder().setPrettyPrinting().create();
    JsonArray banEntryArray = new JsonArray();
    BAN_ENTRIES.values().forEach((entry) -> {
      if (!banEntryArray.contains(entry.asJsonObject())) {
        banEntryArray.add(entry.asJsonObject());
      }
    });
    try (Writer writer = new FileWriter("banned-players.json")) {
      gson.toJson(banEntryArray, writer);
    } catch (IOException ex) {
      if (shouldExceptionsBeLogged) {
        logger.exception(ex);
      }
    }
  }

  private void downloadMaliciousAuthorsDatabase() {
    try {
      logger.info(I18n.tl("download_malicious_authors_database"));
      config = YamlConfiguration.loadConfiguration(
       IOUtils.toInputStream(IOUtils.toString(new URL(BANNED_PLAYERS_URL), "UTF-8"), "UTF-8"));
      logger.info(I18n.tl("downlaoded_malicious_authors_database"));
    } catch (MalformedURLException ex) {
      if (shouldExceptionsBeLogged) {
        logger.exception(ex);
      }
    } catch (IOException ex) {
      if (shouldExceptionsBeLogged) {
        logger.exception(ex);
      }
    }
  }

  private void addBan(BanEntry banEntry) {
    if (BAN_ENTRIES.containsKey(banEntry.uuid)) {
      return;
    }
    BAN_ENTRIES.put(banEntry.uuid, banEntry);
    logger.info("Banned " + banEntry.name + "(" + banEntry.uuid + ")");
  }

  public boolean isBanned(String name, String uuid) {
    return BAN_ENTRIES.values().stream().filter((entry) -> (entry.uuid.equals(uuid)))
     .anyMatch((entry) -> (entry.name.equals(name)));
  }

  private void parseBan(JsonObject object) {
    if (object == null) {
      return;
    }
    if (!object.has("uuid") || !object.has("name")) {
      return;
    }
    String created = object.get("created").getAsString();
    String source = object.get("source").getAsString();
    String expires = object.get("expires").getAsString();
    String reason = object.get("reason").getAsString();
    String uuid = object.get("uuid").getAsString();
    String name = object.get("name").getAsString();
    if (!isBanned(name, uuid)) {
      addBan(new BanEntry(name, uuid, created, source, expires, reason));
    }
  }

  @Override
  public void stopService() {
  }

  public class BanEntry {

    private String name;
    private String uuid;
    private String created;
    private String source;
    private String expires;
    private String reason;

    public BanEntry(String name, String uuid) {
      this(name, uuid, Utils.formatTodaysDate(), "MCAntiMalware", "forever", "Malicious Plugin Developer");
    }

    public BanEntry(String name, String uuid, String created, String source, String expires, String reason) {
      this.name = name;
      this.uuid = uuid;
      this.created = created;
      this.source = source;
      this.expires = expires;
      this.reason = reason;
    }

    public JsonObject asJsonObject() {
      JsonObject object = new JsonObject();
      object.addProperty("uuid", uuid);
      object.addProperty("name", name);
      object.addProperty("created", created);
      object.addProperty("source", source);
      object.addProperty("expires", expires);
      object.addProperty("reason", reason);
      return object;
    }

    @Override
    public int hashCode() {
      int result = 17;
      result = 31 * result + name.hashCode();
      result = 31 * result + uuid.hashCode();
      result = 31 * result + created.hashCode();
      result = 31 * result + expires.hashCode();
      result = 31 * result + reason.hashCode();
      result = 31 * result + source.hashCode();
      return result;
    }

    @Override
    public boolean equals(Object obj) {
      if (this == obj) {
        return true;
      }
      if (!(obj instanceof BanEntry)) {
        return false;
      }
      BanEntry entry = (BanEntry) obj;
      return name.equals(entry.name)
       && uuid.equals(entry.uuid)
       && created.equals(entry.created)
       && source.equals(entry.source)
       && expires.equals(entry.expires)
       && reason.equals(entry.reason);
    }

  }
}
