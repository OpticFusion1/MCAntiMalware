package optic_fusion1.mcantimalware.database;

import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import optic_fusion1.mcantimalware.check.CheckResult;
import optic_fusion1.mcantimalware.logging.CustomLogger;

public class AntiMalwareDatabase {

  public static final String DATABASE_URL = "https://raw.githubusercontent.com/OpticFusion1/MCAntiMalwareDatabase/master/database.db";
  private Connection connection;
  private CustomLogger logger;

  public AntiMalwareDatabase(CustomLogger logger) {
    try {
      File tempFile = File.createTempFile("antiMalware", "db");
      try {
        Files.copy(new URL(DATABASE_URL).openStream(), tempFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
      } catch (IOException e) {
        Files.copy(AntiMalwareDatabase.class.getResource("/database.db").openStream(), tempFile.toPath(), StandardCopyOption.REPLACE_EXISTING);
      }
      connection = DriverManager.getConnection("jdbc:sqlite:" + tempFile.toURI());
      this.logger = logger;
    } catch (SQLException | IOException e) {
      e.printStackTrace();
    }
  }

  private final String getBlacklistedWebsites = "SELECT URL FROM BlacklistedWebsites;";

  public HashSet<String> getBlacklistedWebsites() throws SQLException {
    return get(getBlacklistedWebsites, "URL");
  }

  private final String getBlacklistedStrings = "SELECT String FROM BlacklistedStrings;";

  public HashSet<String> getBlacklistedStrings() throws SQLException {
    return get(getBlacklistedStrings, "String");
  }

  private final String getBlacklistedAuthors = "SELECT Name FROM BlacklistedAuthors;";

  public HashSet<String> getBlacklistedAuthors() throws SQLException {
    return get(getBlacklistedAuthors, "Name");
  }

  private final String getBlacklistedClasspaths = "SELECT Classpath FROM BlacklistedClasspaths";

  public HashSet<String> getBlacklistedClasspaths() throws SQLException {
    return get(getBlacklistedClasspaths, "Classpath");
  }

  private final String getBlacklistedChecksums = "SELECT Checksum FROM BlacklistedChecksums;";

  public HashSet<String> getBlacklistedChecksums() throws SQLException {
    return get(getBlacklistedChecksums, "Checksum");
  }

  private HashSet<String> get(String statement, String a) throws SQLException {
    PreparedStatement query = connection.prepareStatement(statement);
    return toHashSet(query, a);
  }

  private <T> HashSet<T> toHashSet(PreparedStatement pSt, String column) throws SQLException {
    HashSet<T> set;
    try (ResultSet result = pSt.executeQuery()) {
      set = new HashSet<>();
      while (result.next()) {
        set.add((T) result.getObject(column));
      }
    }
    return set;
  }

  private final String websiteToCheckResult = "SELECT type, platform, family, variant FROM BlacklistedWebsites INNER JOIN MalwareChecks ON BlacklistedWebsites.MalwareID = MalwareChecks._rowid_ WHERE URL = ?";

  public CheckResult blacklistedWebsiteToCheckResult(String website) {
    try {
      PreparedStatement pSt = connection.prepareStatement(websiteToCheckResult);
      pSt.setString(1, website);
      try (ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          return new CheckResult(rs.getString("platform"), rs.getString("type"), rs.getString("family"),
                  rs.getString("variant"), "plugin.yml", "plugin.yml", -1);
        }
      }
    } catch (SQLException ex) {
      logger.exception(ex);
    }
    return null;
  }

  private final String checksumToCheckResult = "SELECT type, platform, family, variant FROM BlacklistedChecksums INNER JOIN MalwareChecks ON BlacklistedChecksums.MalwareID = MalwareChecks._rowid_ WHERE Checksum = ?";

  public CheckResult blacklistedChecksumToCheckResult(String checksum) {
    try {
      PreparedStatement pSt = connection.prepareStatement(checksumToCheckResult);
      pSt.setString(1, checksum);
      try (ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          return new CheckResult(rs.getString("platform"), rs.getString("type"), rs.getString("family"),
                  rs.getString("variant"));
        }
      } catch (SQLException ex) {
        logger.exception(ex);
      }
    } catch (SQLException ex) {
      logger.exception(ex);
    }
    return null;
  }

  private final String authorToCheckResult = "SELECT type, platform, family, variant FROM BlacklistedAuthors INNER JOIN MalwareChecks ON BlacklistedAuthors.MalwareID = MalwareChecks._rowid_ WHERE Name = ?";

  public CheckResult blacklistedAuthorToCheckResult(String author) {
    try {
      PreparedStatement pSt = connection.prepareStatement(authorToCheckResult);
      pSt.setString(1, author);
      try (ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          return new CheckResult(rs.getString("platform"), rs.getString("type"), rs.getString("family"),
                  rs.getString("variant"), "plugin.yml", "plugin.yml", -1);
        }
      }
    } catch (SQLException ex) {
      logger.exception(ex);
    }
    return null;
  }

  private final String classPathToCheckResult = "SELECT type, platform, family, variant FROM BlacklistedClasspaths INNER JOIN MalwareChecks ON BlacklistedClasspaths.MalwareID = MalwareChecks._rowid_ WHERE Classpath = ?";

  public CheckResult blacklistedClassPathToCheckResult(String classPath) {
    try {
      PreparedStatement pSt = connection.prepareStatement(classPathToCheckResult);
      pSt.setString(1, classPath);
      try (ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          return new CheckResult(rs.getString("platform"), rs.getString("type"), rs.getString("family"),
                  rs.getString("variant"));
        }
      }
    } catch (SQLException ex) {
      logger.exception(ex);
    }
    return null;
  }

  private final String stringToCheckResult = "SELECT type, platform, family, variant FROM BlacklistedStrings INNER JOIN MalwareChecks ON BlacklistedStrings.MalwareID = MalwareChecks._rowid_ WHERE String = ?";

  public CheckResult blacklistedStringToCheckResult(String string) {
    try {
      PreparedStatement pSt = connection.prepareStatement(stringToCheckResult);
      pSt.setString(1, string);
      try (ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          return new CheckResult(rs.getString("platform"), rs.getString("type"), rs.getString("family"),
                  rs.getString("variant"));
        }
      }
    } catch (SQLException ex) {
      logger.exception(ex);
    }
    return null;
  }

  private final String isChecksumBlacklisted = "SELECT count(*) FROM BlacklistedChecksums WHERE Checksum = ?";

  public boolean isChecksumBlacklisted(String checksum) {
    return a(isChecksumBlacklisted, checksum);
  }

  private final String isChecksumWhitelisted = "SELECT count(*) FROM WhitelistedChecksums WHERE Checksum = ?";

  public boolean isChecksumWhitelisted(String checksum) {
    return a(isChecksumWhitelisted, checksum);
  }

  private final String getMaliciousDevs = "SELECT Name, UUID FROM BannedAuthorsNames INNER JOIN BannedAuthorsUUIDs ON BannedAuthorsNames.AuthorID = BannedAuthorsUUIDs.AuthorID\n"
          + "UNION\n"
          + "SELECT Name, UUID FROM BannedAuthors INNER JOIN BannedAuthorsUUIDs ON BannedAuthors._rowid_ = BannedAuthorsUUIDs.AuthorID";

  public List<String[]> getMaliciousDevelopers() throws SQLException {
    PreparedStatement pSt = connection.prepareStatement(getMaliciousDevs);
    try (ResultSet result = pSt.executeQuery()) {
      List<String[]> malDev = new ArrayList<>();
      while (result.next()) {
        malDev.add(new String[]{result.getString("Name"), result.getString("UUID")});
      }
      result.close();
      return malDev;
    }
  }

  private String isExecBlacklisted = "SELECT count(*) FROM BlacklistedExec where Command LIKE ?";

  public boolean isExecBlacklisted(String exec) {
    return a(isExecBlacklisted, exec);
  }

  private String isWriteBlacklisted = "SELECT count(*) FROM BlacklistedWriteFiles where File LIKE ?";

  public boolean isWriteBlacklisted(String write) {
    return a(isWriteBlacklisted, write);
  }

  private String isReadBlacklisted = "SELECT count(*) FROM BlacklistedReadFiles where File LIKE ?";

  public boolean isReadBlacklisted(String read) {
    return a(isReadBlacklisted, read);
  }

  private String isUrlBlacklisted = "SELECT count(*) FROM BlacklistedURLs where Url LIKE ?";

  public boolean isURLBlacklisted(String url) {
    return a(isUrlBlacklisted, url);
  }

  private final String isStringBlacklisted = "SELECT count(*) FROM BlacklistedStrings WHERE String LIKE ?";

  public boolean isStringBlacklisted(String string) {
    return a(isStringBlacklisted, string);
  }

  private final String isWebsiteBlacklisted = "SELECT count(*) FROM BlacklistedWebsites WHERE URL LIKE ?";

  public boolean isWebsiteBlacklisted(String website) {
    return a(isWebsiteBlacklisted, website);
  }

  private final String isFileNameBlacklisted = "SELECT count(*) FROM BlacklistedFileNames WHERE Name LIKE ?";

  public boolean isFileNameBlacklisted(String fileName) {
    return a(isFileNameBlacklisted, fileName);
  }

  private final String fileNameToCheckResult = "SELECT type, platform, family, variant FROM BlacklistedFileNames INNER JOIN MalwareChecks ON BlacklistedFileNames.MalwareID = MalwareChecks._rowid_ WHERE Name = ?";

  public CheckResult blacklistedFileNameToCheckResult(String fileName) {
    try {
      PreparedStatement pSt = connection.prepareStatement(fileNameToCheckResult);
      pSt.setString(1, fileName);
      try (ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          return new CheckResult(rs.getString("platform"), rs.getString("type"), rs.getString("family"),
                  rs.getString("variant"));
        }
      }
    } catch (SQLException ex) {
      logger.exception(ex);
    }
    return null;
  }

  private final String isFilePathBlacklisted = "SELECT count(*) FROM BlacklistedFilePaths WHERE Path LIKE ?";

  public boolean isFilePathBlacklisted(String filePath) {
    return a(isFilePathBlacklisted, filePath);
  }

  private final String filePathToCheckResult = "SELECT type, platform, family, variant FROM BlacklistedFilePaths INNER JOIN MalwareChecks ON BlacklistedFilePaths.MalwareID = MalwareChecks._rowid_ WHERE Path = ?";

  public CheckResult blacklistedFilePathToCheckResult(String filePath) {
    try {
      PreparedStatement pSt = connection.prepareStatement(filePathToCheckResult);
      pSt.setString(1, filePath);
      try (ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          System.out.println(rs);
          return new CheckResult(rs.getString("platform"), rs.getString("type"), rs.getString("family"),
                  rs.getString("variant"));
        }
      }
    } catch (SQLException ex) {
      logger.exception(ex);
    }
    return null;
  }

  //TOOD: Come up with a proper name for the method and "a" parameter
  private boolean a(String query, String a) {
    try {
      PreparedStatement pSt = connection.prepareStatement(query);
      pSt.setString(1, a);
      try (ResultSet rs = pSt.executeQuery()) {
        if (rs.next()) {
          if (rs.getInt("count(*)") > 0) {
            return true;
          }
        }
      }
    } catch (SQLException ex) {
      logger.exception(ex);
    }
    return false;
  }

}
