package optic_fusion1.antimalware.ui.view.components;

import javafx.beans.binding.Bindings;
import javafx.beans.binding.DoubleExpression;
import javafx.beans.binding.ObjectBinding;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.Event;
import javafx.event.EventDispatcher;
import javafx.geometry.Point2D;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.input.MouseEvent;
import javafx.scene.input.PickResult;
import javafx.scene.layout.Region;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.WeakHashMap;

/**
 * This class is used to create overlays which can be used to display additional information.
 */
public class OverlayControl {

    private final List<Region> overlays = new ArrayList<>();
    private final Map<Region, Boolean> layoutsNeeded = new WeakHashMap<>();

    public OverlayControl(Node root) {

        EventDispatcher eventDispatcher = root.getEventDispatcher();
        root.setEventDispatcher((event, tail) -> {

            Event dispatched = eventDispatcher.dispatchEvent(event, tail);
            List<Node> visible = new ArrayList<>(overlays.size());

            for (Node node : overlays)
                if (node.isVisible())
                    visible.add(node);

            if (!visible.isEmpty() && event.getEventType().equals(MouseEvent.MOUSE_PRESSED)) {

                PickResult pickResult = ((MouseEvent) event).getPickResult();
                Node intersectedNode = pickResult.getIntersectedNode();

                for (Node node : visible)
                    if (isOutside(intersectedNode, node))
                        node.setVisible(false);
            }

            return dispatched;
        });
    }

    /**
     * Adds an overlay to the control.
     */
    public void addOverlay(Region node) {

        overlays.add(node);

        node.setManaged(false);
        node.needsLayoutProperty().addListener((observable, oldValue, newValue) -> {

            if (!Boolean.TRUE.equals(newValue))
                return;

            layoutsNeeded.put(node, true);
        });
    }

    /**
     * Shows the given overlay at the given target.
     *
     * @param overlay The overlay to show.
     * @param target The target to show the overlay at.
     */
    public static void show(Region overlay, Node target) {

        overlay.setVisible(true);
        overlay.requestLayout();

        RelocateBinding binding = new RelocateBinding(overlay, overlay.getParent(), target);

        overlay.layoutXProperty().bind(binding.asX());
        overlay.layoutYProperty().bind(binding.asY());

        overlay.visibleProperty().addListener(new ChangeListener() {

            @Override
            public void changed(ObservableValue observable, Object oldValue, Object newValue) {

                overlay.layoutXProperty().unbind();
                overlay.layoutYProperty().unbind();

                overlay.visibleProperty().removeListener(this);
            }
        });
    }

    /**
     * Hides the given overlay.
     * @param overlay The overlay to hide.
     */
    public static void hide(Region overlay) {
        overlay.setVisible(false);
    }

    private static boolean isOutside(Node node, Node target) {

        if (target == node)
            return false;

        Parent parent = node.getParent();
        while (parent != null && parent != target)
            parent = parent.getParent();

        return target != parent;
    }

    private static final class RelocateBinding extends ObjectBinding<Point2D> {

        private final Region overlay;
        private final Parent parent;
        private final Node target;

        private RelocateBinding(Region overlay, Parent parent, Node target) {

            this.overlay = overlay;
            this.parent = parent;
            this.target = target;

            super.bind(overlay.widthProperty());
            super.bind(overlay.heightProperty());
            super.bind(overlay.needsLayoutProperty());
            super.bind(parent.layoutBoundsProperty());
            super.bind(target.layoutBoundsProperty());
        }

        @SuppressWarnings("unchecked")
        @Override
        public ObservableList<?> getDependencies() {
            return FXCollections.observableArrayList(overlay.widthProperty(), overlay.heightProperty(), parent.layoutBoundsProperty(),
                    target.layoutBoundsProperty());
        }

        @Override
        protected Point2D computeValue() {

            double x = target.getLayoutX() + target.getLayoutBounds().getMinX();
            double y = target.getLayoutY() + target.getLayoutBounds().getMinY();

            x += target.getLayoutBounds().getWidth() / 2;
            y += target.getLayoutBounds().getHeight() / 2;

            x -= overlay.getWidth() / 2;
            y -= overlay.getHeight() / 2;

            return new Point2D(x, y);
        }

        private DoubleExpression asX() {
            return Bindings.createDoubleBinding(() -> get().getX(), this);
        }

        private DoubleExpression asY() {
            return Bindings.createDoubleBinding(() -> get().getY(), this);
        }
    }
}
